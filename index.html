<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aera Link</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Leaflet Draw CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    
    <!-- Leaflet Sidebar CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-sidebar-v2@3.2.3/css/leaflet-sidebar.min.css" />
    
    <!-- Heroicons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Avenir Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Ensure the root container stretches to 100vh */
        body {
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .header-container {
            flex: 0 0 auto; /* Header takes only as much space as needed */
        }

        .main-content-container {
            flex: 1 1 auto; /* Main content fills the remaining space */
            display: flex;
            overflow: hidden;
        }

        #map {
            flex: 1 1 auto; /* Map container fills available space */
            position: relative;
        }

        #sidebar {
            flex: 0 0 300px; /* Sidebar has a fixed width */
            overflow-y: auto; /* Enable scrolling for overflowing content */
            z-index: 1200;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Avenir', sans-serif;
        }
        
        .glass-effect {
            background: rgba(17, 25, 40, 0.75);
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.125);
        }
        
        .glass-panel {
            background: rgba(31, 41, 55, 0.8);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(75, 85, 99, 0.3);
        }
        
        .btn-glass {
            background: rgba(20, 184, 166, 0.2);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(20, 184, 166, 0.3);
            transition: all 0.3s ease;
        }
        
        .btn-glass:hover {
            background: rgba(20, 184, 166, 0.4);
            border-color: rgba(20, 184, 166, 0.5);
        }
        
        .leaflet-sidebar {
            background: rgba(17, 25, 40, 0.9) !important;
            backdrop-filter: blur(16px) !important;
            border-right: 1px solid rgba(75, 85, 99, 0.3) !important;
        }
        
        .leaflet-sidebar-content {
            background: transparent !important;
        }
        
        /* Fix sidebar header vertical alignment */
        .leaflet-sidebar-header {
            display: flex !important;
            align-items: center !important;
            justify-content: space-between !important;
            position: relative !important;
            padding: 0.75rem 1rem !important;
            margin-bottom: 1rem !important;
            line-height: 1 !important;
            min-height: 3rem !important;
        }
        
        .leaflet-sidebar-close {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            width: 2rem !important;
            height: 2rem !important;
            border-radius: 0.375rem !important;
            transition: all 0.2s ease !important;
            cursor: pointer !important;
            color: rgba(255, 255, 255, 0.8) !important;
            margin-left: auto !important;
        }
        
        .leaflet-sidebar-close:hover {
            background: rgba(255, 255, 255, 0.1) !important;
            color: white !important;
        }
        
        .leaflet-sidebar-close i {
            font-size: 1rem !important;
            line-height: 1 !important;
        }
        
        .leaflet-control-container .leaflet-top.leaflet-right {
            top: 80px !important;
        }
        
        /* Pin zoom controls inside the map container, above the OS taskbar, and not overlapping the sidebar */
        .leaflet-control-zoom {
            position: absolute !important;
            right: 24px;
            bottom: 24px;
            z-index: 1100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
        }
        
        /* Prevent sidebar from overlapping zoom controls */
        #sidebar {
            z-index: 1200;
        }
        
        .layer-item {
            border: 1px solid rgba(75, 85, 99, 0.3);
            background: rgba(31, 41, 55, 0.6);
        }
        
        /* Drag-and-drop styles only for layer items */
        .layer-item[draggable="true"] {
            cursor: move;
        }
        
        .layer-item.dragging {
            opacity: 0.5;
            transform: scale(0.95);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .layer-item.drag-over {
            border: 2px dashed #14b8a6;
            background: rgba(20, 184, 166, 0.15);
            transform: scale(1.02);
            transition: all 0.2s ease;
        }
        
        .layer-drag-handle {
            color: #9ca3af;
            cursor: grab;
        }
        
        .layer-drag-handle:active {
            cursor: grabbing;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .modal-overlay {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }
        
        .progress-bar {
            background: linear-gradient(90deg, #14b8a6 0%, #06b6d4 100%);
        }
        
        .tooltip {
            position: relative;
        }
        
        .tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
        }
        
        /* Custom popup styling for better UX */
        .custom-popup .leaflet-popup-content-wrapper {
            max-height: 300px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .custom-popup .leaflet-popup-content {
            max-width: 400px;
            word-wrap: break-word;
            margin: 8px 12px;
        }
        
        /* Ensure popup stays within viewport */
        .leaflet-popup {
            max-width: 90vw !important;
        }

        /* Custom Context Menu Styles */
        .custom-context-menu {
            position: fixed;
            background: rgba(31, 41, 55, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(75, 85, 99, 0.8);
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            z-index: 10000;
            min-width: 160px;
            padding: 4px 0;
            font-size: 14px;
            display: none;
        }

        .context-menu-item {
            padding: 8px 16px;
            color: #ffffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            transition: background-color 0.15s ease;
        }

        .context-menu-item:hover {
            background-color: rgba(20, 184, 166, 0.2);
        }

        .context-menu-item i {
            margin-right: 8px;
            width: 16px;
            text-align: center;
            color: #14b8a6;
        }

        .context-menu-item.disabled {
            color: #6b7280;
            cursor: not-allowed;
        }

        .context-menu-item.disabled:hover {
            background-color: transparent;
        }

        .context-menu-item.disabled i {
            color: #6b7280;
        }

        .context-menu-separator {
            height: 1px;
            background-color: rgba(75, 85, 99, 0.5);
            margin: 4px 0;
        }

        /* Draggable Symbology Editor Styles */
        .symbology-editor-draggable {
            position: fixed;
            background: rgba(31, 41, 55, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(75, 85, 99, 0.8);
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            z-index: 9999;
            max-width: 400px;
            min-width: 320px;
            max-height: calc(100vh - 6rem);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .symbology-editor-header {
            background: rgba(55, 65, 81, 0.9);
            padding: 16px;
            border-bottom: 1px solid rgba(75, 85, 99, 0.8);
            border-radius: 8px 8px 0 0;
            cursor: move;
            user-select: none;
        }

        .symbology-editor-header:hover {
            background: rgba(55, 65, 81, 1);
        }

        .symbology-editor-content {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }

        .opacity-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #374151;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .opacity-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #14b8a6;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .opacity-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #14b8a6;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .opacity-value {
            font-size: 12px;
            color: #9ca3af;
            text-align: center;
            margin-top: 4px;
        }

        /* Login Page Styles */
        #loginContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d30 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .login-card {
            background: rgba(31, 41, 55, 0.95);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(75, 85, 99, 0.8);
            border-radius: 16px;
            padding: 3rem;
            min-width: 400px;
            max-width: 450px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            animation: fadeInUp 0.6s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .login-header {
            text-align: center;
            margin-bottom: 2.5rem;
        }

        .login-title {
            font-size: 2.5rem;
            font-weight: 700;
            color: #14b8a6;
            margin-bottom: 0.5rem;
            font-family: 'Inter', sans-serif;
        }

        .login-subtitle {
            font-size: 1rem;
            color: #9ca3af;
            font-weight: 400;
        }

        .login-form {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #e5e7eb;
        }

        .form-input {
            padding: 1rem;
            background: rgba(55, 65, 81, 0.8);
            border: 1px solid rgba(75, 85, 99, 0.6);
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #14b8a6;
            box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.2);
            background: rgba(55, 65, 81, 1);
        }

        .form-input::placeholder {
            color: #9ca3af;
        }

        .login-button {
            padding: 1rem 2rem;
            background: linear-gradient(135deg, #14b8a6 0%, #0891b2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 1rem;
        }

        .login-button:hover:not(:disabled) {
            background: linear-gradient(135deg, #0891b2 0%, #14b8a6 100%);
            transform: translateY(-1px);
            box-shadow: 0 8px 25px rgba(20, 184, 166, 0.3);
        }

        .login-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .error-message {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            color: #fecaca;
            font-size: 0.875rem;
            margin-bottom: 1rem;
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .forgot-password {
            text-align: center;
            margin-top: 1.5rem;
        }

        .forgot-password a {
            color: #14b8a6;
            font-size: 0.875rem;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .forgot-password a:hover {
            color: #0891b2;
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 0.5rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-left: 1rem;
        }

        .user-email {
            color: #e5e7eb;
            font-size: 0.875rem;
        }

        .logout-button {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            color: #fecaca;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .logout-button:hover {
            background: rgba(239, 68, 68, 0.3);
        }

        /* Notification animations */
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        /* Selection Counter Animations and Styling */
        .selection-counter-card {
            background: rgba(31, 41, 55, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(75, 85, 99, 0.3);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
            padding: 1.5rem;
            text-align: center;
            transition: all 0.3s ease;
        }

        .selection-counter-card:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
            transform: translateY(-1px);
        }

        .selection-counter-number {
            font-size: 2.5rem;
            font-weight: 700;
            color: #14b8a6;
            margin-bottom: 0.25rem;
            font-family: 'Inter', monospace;
            text-shadow: 0 0 20px rgba(20, 184, 166, 0.4);
            transition: all 0.2s ease;
        }

        .selection-counter-number.counting {
            animation: pulse-glow 0.15s ease-in-out;
        }

        .selection-counter-label {
            font-size: 0.875rem;
            color: #9ca3af;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        @keyframes pulse-glow {
            0% {
                text-shadow: 0 0 20px rgba(20, 184, 166, 0.4);
                transform: scale(1);
            }
            50% {
                text-shadow: 0 0 30px rgba(20, 184, 166, 0.8);
                transform: scale(1.05);
            }
            100% {
                text-shadow: 0 0 20px rgba(20, 184, 166, 0.4);
                transform: scale(1);
            }
        }

        @keyframes count-up {
            0% {
                opacity: 0.7;
                transform: scale(0.9);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Statistics Result Cards */
        .statistics-result-card {
            background: linear-gradient(135deg, rgba(31, 41, 55, 0.95), rgba(55, 65, 81, 0.9));
            backdrop-filter: blur(12px);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
            padding: 1rem;
            margin-bottom: 0.75rem;
            transition: all 0.3s ease;
            animation: fade-slide-in 0.4s ease-out;
        }

        .statistics-result-card:hover {
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.2);
            transform: translateY(-1px);
            border-color: rgba(59, 130, 246, 0.4);
        }

        .statistics-result-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .statistics-result-operation {
            font-size: 0.875rem;
            font-weight: 600;
            color: #60a5fa;
            text-transform: capitalize;
        }

        .statistics-result-field {
            font-size: 0.75rem;
            color: #9ca3af;
            font-weight: 400;
        }

        .statistics-result-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #10b981;
            font-family: 'Inter', monospace;
            text-shadow: 0 0 15px rgba(16, 185, 129, 0.3);
            animation: result-glow 0.6s ease-out;
        }

        @keyframes fade-slide-in {
            0% {
                opacity: 0;
                transform: translateY(-10px) scale(0.95);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes result-glow {
            0% {
                text-shadow: 0 0 15px rgba(16, 185, 129, 0.3);
                transform: scale(1);
            }
            50% {
                text-shadow: 0 0 25px rgba(16, 185, 129, 0.6);
                transform: scale(1.02);
            }
            100% {
                text-shadow: 0 0 15px rgba(16, 185, 129, 0.3);
                transform: scale(1);
            }
        }

        /* Statistics Operation Checkboxes */
        .statistics-operation-checkbox {
            width: 1rem;
            height: 1rem;
            border-radius: 0.25rem;
            border: 1px solid #6b7280;
            background-color: #374151;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .statistics-operation-checkbox:checked {
            background-color: #14b8a6;
            border-color: #14b8a6;
            background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='m13.854 3.646-7-7a.5.5 0 0 0-.708 0l-3.5 3.5a.5.5 0 0 0 0 .708l7 7a.5.5 0 0 0 .708 0l3.5-3.5a.5.5 0 0 0 0-.708z'/%3e%3c/svg%3e");
        }

        .statistics-operation-checkbox:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(20, 184, 166, 0.2);
        }

        /* Floating Statistics Cards */
        .floating-statistics-card {
            background: rgba(31, 41, 55, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(75, 85, 99, 0.3);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
            padding: 1.5rem;
            text-align: center;
            transition: all 0.3s ease;
            width: 100%;
            min-width: 240px;
            max-width: 320px;
            opacity: 0;
            animation: fadeInAtPosition 0.5s ease-out forwards;
        }

        .floating-statistics-card:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
            transform: translateY(-1px);
        }

        .floating-statistics-header {
            margin-bottom: 0.75rem;
        }

        .floating-statistics-operation {
            font-size: 0.875rem;
            font-weight: 600;
            color: #60a5fa;
            text-transform: capitalize;
            margin-bottom: 0.25rem;
        }

        .floating-statistics-field {
            font-size: 0.75rem;
            color: #9ca3af;
            font-weight: 400;
        }

        .floating-statistics-number {
            font-size: 2.25rem;
            font-weight: 700;
            color: #14b8a6;
            margin-bottom: 0.25rem;
            font-family: 'Inter', monospace;
            text-shadow: 0 0 20px rgba(20, 184, 166, 0.4);
            transition: all 0.2s ease;
            word-break: break-all;
        }

        .floating-statistics-number.counting {
            animation: pulse-glow 0.15s ease-in-out;
        }

        .floating-statistics-label {
            font-size: 0.75rem;
            color: #9ca3af;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .floating-statistics-no-features {
            color: #f59e0b;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .floating-statistics-help-text {
            font-size: 0.625rem;
            color: #6b7280;
            margin-top: 0.5rem;
            font-style: italic;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 640px) {
            .floating-statistics-card {
                padding: 1rem;
            }
            
            .floating-statistics-number {
                font-size: 1.75rem;
            }
            
            .floating-statistics-operation {
                font-size: 0.8rem;
            }
        }

        /* Custom scrollbar for floating container */
        #floatingStatisticsContainer::-webkit-scrollbar {
            width: 4px;
        }

        #floatingStatisticsContainer::-webkit-scrollbar-track {
            background: rgba(75, 85, 99, 0.2);
            border-radius: 2px;
        }

        #floatingStatisticsContainer::-webkit-scrollbar-thumb {
            background: rgba(20, 184, 166, 0.5);
            border-radius: 2px;
        }

        #floatingStatisticsContainer::-webkit-scrollbar-thumb:hover {
            background: rgba(20, 184, 166, 0.7);
        }

        /* Smooth fade-in animation at final position */
        @keyframes fadeInAtPosition {
            0% {
                opacity: 0;
                transform: scale(0.98);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Smooth fade-out animation */
        @keyframes fadeOutAtPosition {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.98);
            }
        }

        /* Modern Feature Popup Styles */
        .modern-feature-popup .leaflet-popup-content-wrapper {
            background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
            border: 2px solid #14b8a6;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3), 0 0 20px rgba(20, 184, 166, 0.1);
            backdrop-filter: blur(10px);
            padding: 0;
            overflow: hidden;
        }

        .modern-feature-popup .leaflet-popup-content {
            margin: 0;
            padding: 0;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            line-height: 1.5;
        }

        .modern-popup-container {
            width: 100%;
            min-width: 280px;
            max-width: 350px;
        }

        .modern-popup-header {
            background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%);
            padding: 12px 16px;
            display: flex;
            align-items: center;
            font-weight: 600;
            font-size: 14px;
            color: #ffffff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modern-popup-header i {
            color: #ffffff;
            font-size: 14px;
        }

        .modern-popup-body {
            padding: 16px;
            background: rgba(30, 58, 138, 0.95);
            max-height: 300px;
            overflow-y: auto;
        }

        .property-row {
            display: flex;
            flex-direction: column;
            margin-bottom: 12px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border-left: 3px solid #14b8a6;
            transition: all 0.2s ease;
        }

        .property-row:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(2px);
        }

        .property-row:last-child {
            margin-bottom: 0;
        }

        .property-key {
            font-weight: 700;
            color: #5eead4;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .property-value {
            color: #f3f4f6;
            font-size: 14px;
            font-weight: 500;
            word-break: break-word;
            line-height: 1.4;
        }

        .no-data-text {
            color: #9ca3af;
            font-style: italic;
            text-align: center;
            padding: 20px 0;
            margin: 0;
            font-size: 14px;
        }

        /* Custom scrollbar for popup body */
        .modern-popup-body::-webkit-scrollbar {
            width: 6px;
        }

        .modern-popup-body::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .modern-popup-body::-webkit-scrollbar-thumb {
            background: #14b8a6;
            border-radius: 3px;
        }

        .modern-popup-body::-webkit-scrollbar-thumb:hover {
            background: #0d9488;
        }

        /* Modern popup tip styling */
        .modern-feature-popup .leaflet-popup-tip {
            background: #14b8a6;
            border: none;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
        }

        /* Animation for popup appearance */
        .modern-feature-popup {
            animation: popupSlideIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes popupSlideIn {
            0% {
                opacity: 0;
                transform: scale(0.8) translateY(-10px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden">
    <!-- Login Container -->
    <div id="loginContainer">
        <div class="login-card">
            <div class="login-header">
                <h1 class="login-title">Aéra Link</h1>
                <p class="login-subtitle">AKL WebGIS Portal</p>
            </div>
            
            <form id="loginForm" class="login-form">
                <div id="errorMessage" class="error-message" style="display: none;"></div>
                
                <div class="form-group">
                    <label for="email" class="form-label">Email Address</label>
                    <input 
                        type="email" 
                        id="email" 
                        name="email" 
                        class="form-input" 
                        placeholder="Enter your email address"
                        required
                    >
                </div>
                
                <div class="form-group">
                    <label for="password" class="form-label">Password</label>
                    <input 
                        type="password" 
                        id="password" 
                        name="password" 
                        class="form-input" 
                        placeholder="Enter your password"
                        required
                    >
                </div>
                
                <button type="submit" id="loginButton" class="login-button">
                    Sign In to WebGIS
                </button>
                
                <div class="forgot-password">
                    <a href="#" id="forgotPasswordLink">Forgot your password?</a>
                </div>
            </form>
        </div>
    </div>

    <!-- WebGIS Container -->
    <div id="webgisContainer" style="display: none;">
        <!-- Header -->
        <div class="header-container">
            <header class="glass-effect fixed top-0 left-0 right-0 z-50 px-6 py-4">
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-4">
                        <img src="AERA LOGO.png" alt="Aera Logo" class="h-12 w-auto">
                    </div>
                    
                    <!-- User Info and Logout -->
                    <div class="user-info">
                        <span id="userEmail" class="user-email"></span>
                        <button id="logoutButton" class="logout-button">
                            <i class="fas fa-sign-out-alt"></i> Logout
                        </button>
                    </div>
                </div>
            </header>
        </div>

    <!-- Main Content -->
    <div class="main-content-container pt-20 h-screen">
        <!-- Map Container -->
        <div id="map"></div>
        
        <!-- Floating Statistics Cards Container -->
        <div id="floatingStatisticsContainer" class="fixed top-24 right-2 sm:right-6 z-[1150] space-y-3 w-64 sm:w-72 lg:w-80 max-w-[90vw] max-h-[calc(100vh-8rem)] overflow-y-auto pr-2 sm:pr-0" style="display: none;">
            <!-- Statistics cards will be dynamically added here -->
        </div>
        
        <!-- Sidebar -->
        <div id="sidebar" class="leaflet-sidebar collapsed">
            <!-- Layers Tab -->
            <div class="leaflet-sidebar-tabs">
                <ul role="tablist">
                    <li><a href="#filter-panel" role="tab"><i class="fas fa-filter"></i></a></li>
                    <li><a href="#print-panel" role="tab"><i class="fas fa-print"></i></a></li>
                    <li><a href="#layers-panel" role="tab"><i class="fas fa-layer-group"></i></a></li>
                    <li><a href="#legend-panel" role="tab"><i class="fas fa-list"></i></a></li>
                    <li><a href="#select-panel" role="tab"><i class="fas fa-draw-polygon"></i></a></li>
                </ul>
            </div>
            
            <div class="leaflet-sidebar-content">
                <!-- Filter Panel -->
                <div class="leaflet-sidebar-pane" id="filter-panel">
                    <h1 class="leaflet-sidebar-header text-white font-bold text-lg mb-4">
                        Filter
                        <span class="leaflet-sidebar-close"><i class="fas fa-times"></i></span>
                    </h1>
                    <div class="space-y-4">
                        <div class="glass-panel rounded-lg p-4">
                            <p class="text-gray-300 text-sm mb-4">Filter features from visible layers based on attribute values.</p>
                            
                            <!-- Step 1: Layer Selection -->
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-300 mb-2">
                                    <i class="fas fa-layer-group mr-2"></i>Select Layer
                                </label>
                                <select id="filterLayerSelect" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                    <option value="">Choose a layer to filter</option>
                                </select>
                            </div>
                            
                            <!-- Step 2: Field Selection -->
                            <div id="filterFieldSection" class="mb-4" style="display: none;">
                                <label class="block text-sm font-medium text-gray-300 mb-2">
                                    <i class="fas fa-table mr-2"></i>Select Field
                                </label>
                                <select id="filterFieldSelect" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                    <option value="">Choose a field to filter by</option>
                                </select>
                            </div>
                            
                            <!-- Step 3: Operator Selection -->
                            <div id="filterOperatorSection" class="mb-4" style="display: none;">
                                <label class="block text-sm font-medium text-gray-300 mb-2">
                                    <i class="fas fa-filter mr-2"></i>Filter Operator
                                </label>
                                <select id="filterOperatorSelect" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                    <option value="">Choose how to filter</option>
                                    <option value="equal">Equal to</option>
                                    <option value="not_equal">Not equal to</option>
                                    <option value="include">Include (any of)</option>
                                    <option value="does_not_include">Does not include (any of)</option>
                                    <option value="contains">Contains text</option>
                                    <option value="does_not_contain">Does not contain text</option>
                                    <option value="starts_with">Starts with</option>
                                    <option value="does_not_start_with">Does not start with</option>
                                    <option value="is_empty">Is empty</option>
                                    <option value="is_not_empty">Is not empty</option>
                                    <option value="is_null">Is null</option>
                                    <option value="is_not_null">Is not null</option>
                                </select>
                            </div>
                            
                            <!-- Step 4: Value Input (Dynamic) -->
                            <div id="filterValueSection" style="display: none;">
                                <label class="block text-sm font-medium text-gray-300 mb-2">
                                    <i class="fas fa-edit mr-2"></i>Filter Value
                                </label>
                                
                                <!-- Single Value Dropdown -->
                                <select id="filterSingleValueSelect" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" style="display: none;">
                                    <option value="">Loading values...</option>
                                </select>
                                
                                <!-- Multi-Value Selection -->
                                <div id="filterMultiValueContainer" style="display: none;">
                                    <div class="bg-gray-800 border border-gray-600 rounded-md p-2 max-h-32 overflow-y-auto">
                                        <div id="filterMultiValueList">
                                            <!-- Checkboxes will be populated here -->
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Text Input -->
                                <input type="text" id="filterTextInput" placeholder="Enter text to filter by" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" style="display: none;">
                            </div>
                            
                            <!-- Action Buttons -->
                            <div id="filterActionsSection" class="mt-6 space-y-2" style="display: none;">
                                <button id="applyFilterBtn" class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors text-sm font-medium">
                                    <i class="fas fa-check mr-2"></i>Apply Filter
                                </button>
                                <button id="clearFilterBtn" class="w-full px-4 py-2 bg-orange-600 hover:bg-orange-700 text-white rounded-md transition-colors text-sm font-medium">
                                    <i class="fas fa-times mr-2"></i>Clear Filter
                                </button>
                            </div>
                            
                            <!-- Filter Status -->
                            <div id="filterStatusSection" style="display: none;">
                                <div class="mt-4 p-3 bg-green-900/30 border border-green-600/50 rounded-md">
                                    <div class="flex items-center">
                                        <i class="fas fa-filter text-green-400 mr-2"></i>
                                        <span class="text-green-300 text-sm font-medium">Filter Active</span>
                                    </div>
                                    <div id="filterStatusText" class="text-gray-300 text-xs mt-1"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Print Map Panel -->
                <div class="leaflet-sidebar-pane" id="print-panel">
                    <h1 class="leaflet-sidebar-header text-white font-bold text-lg mb-4">
                        Print Map
                        <span class="leaflet-sidebar-close"><i class="fas fa-times"></i></span>
                    </h1>
                    <div class="space-y-3">
                        <div class="glass-panel rounded-lg p-4">
                            <p class="text-gray-300 text-sm mb-4">Export the current map view as a high-quality image for printing or presentation.</p>
                            <button id="printBtn" class="w-full px-4 py-3 bg-green-600 hover:bg-green-700 text-white rounded-md transition-colors">
                                <i class="fas fa-print mr-2"></i>Print Map
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Layers Panel -->
                <div class="leaflet-sidebar-pane" id="layers-panel">
                    <h1 class="leaflet-sidebar-header text-white font-bold text-lg mb-4">
                        Layers
                        <span class="leaflet-sidebar-close"><i class="fas fa-times"></i></span>
                    </h1>
                    <div id="layersList" class="space-y-3">
                        <!-- Layers will be dynamically added here -->
                    </div>
                </div>
                
                <!-- Legend Panel -->
                <div class="leaflet-sidebar-pane" id="legend-panel">
                    <h1 class="leaflet-sidebar-header text-white font-bold text-lg mb-4">
                        Legend
                        <span class="leaflet-sidebar-close"><i class="fas fa-times"></i></span>
                    </h1>
                    <div id="legendContent" class="space-y-2">
                        <!-- Legend items will be dynamically added here -->
                    </div>
                </div>
                
                <!-- Select Panel -->
                <div class="leaflet-sidebar-pane" id="select-panel">
                    <h1 class="leaflet-sidebar-header text-white font-bold text-lg mb-4">
                        Select Features
                        <span class="leaflet-sidebar-close"><i class="fas fa-times"></i></span>
                    </h1>
                    <div class="space-y-4">
                        <div class="glass-panel rounded-lg p-4">
                            <div class="mb-3">
                                <label class="block text-sm font-medium text-gray-300 mb-2">Active Layer for Selection</label>
                                <select id="activeLayerSelect" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent">
                                    <option value="">Select a layer first</option>
                                </select>
                            </div>
                            <button id="activateSelectTool" class="w-full px-4 py-2 bg-teal-600 hover:bg-teal-700 text-white rounded-md mb-3" disabled>
                                <i class="fas fa-draw-polygon mr-2"></i>Activate Selection Tool
                            </button>
                            <button id="clearSelection" class="w-full px-4 py-2 bg-orange-600 hover:bg-orange-700 text-white rounded-md" disabled>
                                <i class="fas fa-times mr-2"></i>Clear Selection
                            </button>
                            <button id="showStatistics" class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md mt-3" disabled>
                                <i class="fas fa-chart-bar mr-2"></i>Statistics
                            </button>
                        </div>
                        <div id="selectionInfo" class="selection-counter-card">
                            <div id="selectedCountNumber" class="selection-counter-number">0</div>
                            <div class="selection-counter-label">Features Selected</div>
                            <div id="selectedFeaturesList" class="mt-4 space-y-2 max-h-40 overflow-y-auto" style="display: none;">
                                <!-- Selected features will be listed here when count > 0 -->
                            </div>
                        </div>

                        <!-- Statistics Panel -->
                        <div id="statisticsPanel" class="glass-panel rounded-lg p-4" style="display: none;">
                            <h3 class="text-white font-semibold mb-3">
                                <i class="fas fa-chart-bar mr-2"></i>Statistics
                            </h3>
                            <div class="space-y-3">
                                <div>
                                    <label class="block text-sm font-medium text-gray-300 mb-2">Field</label>
                                    <select id="statisticsFieldSelect" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent">
                                        <option value="">Select a field</option>
                                    </select>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-300 mb-2">Operations</label>
                                    <div class="grid grid-cols-2 gap-2">
                                        <label class="flex items-center space-x-2 text-sm text-gray-300 cursor-pointer">
                                            <input type="checkbox" value="sum" class="statistics-operation-checkbox rounded border-gray-600 bg-gray-700 text-teal-500 focus:ring-teal-500">
                                            <span>Sum</span>
                                        </label>
                                        <label class="flex items-center space-x-2 text-sm text-gray-300 cursor-pointer">
                                            <input type="checkbox" value="average" class="statistics-operation-checkbox rounded border-gray-600 bg-gray-700 text-teal-500 focus:ring-teal-500">
                                            <span>Average</span>
                                        </label>
                                        <label class="flex items-center space-x-2 text-sm text-gray-300 cursor-pointer">
                                            <input type="checkbox" value="mode" class="statistics-operation-checkbox rounded border-gray-600 bg-gray-700 text-teal-500 focus:ring-teal-500">
                                            <span>Mode</span>
                                        </label>
                                        <label class="flex items-center space-x-2 text-sm text-gray-300 cursor-pointer">
                                            <input type="checkbox" value="min" class="statistics-operation-checkbox rounded border-gray-600 bg-gray-700 text-teal-500 focus:ring-teal-500">
                                            <span>Minimum</span>
                                        </label>
                                        <label class="flex items-center space-x-2 text-sm text-gray-300 cursor-pointer">
                                            <input type="checkbox" value="max" class="statistics-operation-checkbox rounded border-gray-600 bg-gray-700 text-teal-500 focus:ring-teal-500">
                                            <span>Maximum</span>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            <div id="statisticsResults" class="mt-4" style="display: none;">
                                <!-- Statistical results will be displayed here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Data Modal -->
    <div id="addDataModal" class="fixed inset-0 modal-overlay z-50 hidden flex items-center justify-center">
        <div class="glass-panel rounded-lg p-6 max-w-md w-full mx-4">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-white">Add Data</h2>
                <button id="closeAddDataModal" class="text-gray-400 hover:text-white">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">Select File</label>
                    <input type="file" id="fileInput" accept=".geojson,.json,.kml,.kmz" 
                           class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                    <p class="text-xs text-gray-400 mt-1"><em>Supports GeoJSON, KML, and KMZ files (max 50MB)</em></p>
                </div>
                
                <div id="uploadProgress" class="hidden">
                    <div class="bg-gray-700 rounded-full h-2">
                        <div id="progressBar" class="progress-bar h-2 rounded-full" style="width: 0%"></div>
                    </div>
                    <p id="progressText" class="text-xs text-gray-400 mt-1">Uploading...</p>
                </div>
                
                <div class="flex justify-end space-x-3">
                    <button id="cancelUpload" class="px-4 py-2 text-gray-400 hover:text-white">Cancel</button>
                    <button id="uploadFile" class="px-4 py-2 bg-teal-600 hover:bg-teal-700 text-white rounded-md">
                        Upload
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Filter Modal -->
    <div id="filterModal" class="fixed inset-0 modal-overlay z-50 hidden flex items-center justify-center">
        <div class="glass-panel rounded-lg p-6 max-w-md w-full mx-4">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-white">Filter Features</h2>
                <button id="closeFilterModal" class="text-gray-400 hover:text-white">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">Layer</label>
                    <select id="filterLayer" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                        <!-- Options will be populated dynamically -->
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">Field</label>
                    <select id="filterField" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                        <!-- Options will be populated dynamically -->
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">Value</label>
                    <input type="text" id="filterValue" placeholder="Enter value to filter by"
                           class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                </div>
                
                <div class="flex justify-end space-x-3">
                    <button id="clearFilter" class="px-4 py-2 text-orange-400 hover:text-orange-300">Clear Filter</button>
                    <button id="applyFilter" class="px-4 py-2 bg-teal-600 hover:bg-teal-700 text-white rounded-md">
                        Apply Filter
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Print Modal -->
    <div id="printModal" class="fixed inset-0 modal-overlay z-50 hidden flex items-center justify-center">
        <div class="glass-panel rounded-lg p-6 max-w-lg w-full mx-4">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-white">Print Map</h2>
                <button id="closePrintModal" class="text-gray-400 hover:text-white">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">Map Title</label>
                    <input type="text" id="mapTitle" value="Aera Map Export"
                           class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                </div>
                
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-300 mb-2">Page Size</label>
                        <select id="pageSize" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                            <option value="1980x720">PPT Slide (1980x720)</option>
                            <option value="1920x1080">Full HD (1920x1080)</option>
                            <option value="1200x800">Standard (1200x800)</option>
                        </select>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium text-gray-300 mb-2">Orientation</label>
                        <select id="orientation" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                            <option value="landscape">Landscape</option>
                            <option value="portrait">Portrait</option>
                        </select>
                    </div>
                </div>
                
                <div class="flex items-center">
                    <input type="checkbox" id="includeLegend" checked class="mr-2">
                    <label class="text-sm text-gray-300">Include Legend</label>
                </div>
                
                <div class="flex justify-end space-x-3">
                    <button id="cancelPrint" class="px-4 py-2 text-gray-400 hover:text-white">Cancel</button>
                    <button id="exportMap" class="px-4 py-2 bg-teal-600 hover:bg-teal-700 text-white rounded-md">
                        Export
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Symbology Modal -->
    <div id="symbologyModal" class="fixed inset-0 modal-overlay z-50 hidden flex items-center justify-center">
        <div class="glass-panel rounded-lg p-6 max-w-lg w-full mx-4">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-white">Layer Symbology</h2>
                <button id="closeSymbologyModal" class="text-gray-400 hover:text-white">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">Style Type</label>
                    <select id="styleType" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                        <option value="single">Single Symbol</option>
                        <option value="categorical">Categorical</option>
                    </select>
                </div>
                
                <div id="singleSymbolOptions">
                    <label class="block text-sm font-medium text-gray-300 mb-2">Color</label>
                    <input type="color" id="singleColor" value="#14b8a6" class="w-16 h-10 bg-transparent border border-gray-600 rounded">
                </div>
                
                <div id="categoricalOptions" class="hidden">
                    <label class="block text-sm font-medium text-gray-300 mb-2">Classify by Field</label>
                    <select id="classifyField" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                        <!-- Options populated dynamically -->
                    </select>
                    <div id="classificationRules" class="mt-4 space-y-2">
                        <!-- Classification rules will be added here -->
                    </div>
                </div>
                
                <div class="flex justify-end space-x-3">
                    <button id="cancelSymbology" class="px-4 py-2 text-gray-400 hover:text-white">Cancel</button>
                    <button id="applySymbology" class="px-4 py-2 bg-teal-600 hover:bg-teal-700 text-white rounded-md">
                        Apply
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Layer Context Menu -->
    <div id="layerContextMenu" class="custom-context-menu">
        <div class="context-menu-item" id="contextZoomToLayer">
            <i class="fas fa-search-plus"></i>
            Zoom to Layer
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="contextRename">
            <i class="fas fa-edit"></i>
            Rename
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="contextProperties">
            <i class="fas fa-palette"></i>
            Properties
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="contextDelete">
            <i class="fas fa-trash"></i>
            Delete
        </div>
    </div>
    </div> <!-- End of webgisContainer -->

    <!-- Scripts -->
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Leaflet Draw JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    
    <!-- Leaflet Sidebar JS -->
    <script src="https://unpkg.com/leaflet-sidebar-v2@3.2.3/js/leaflet-sidebar.min.js"></script>
    
    <!-- toGeoJSON for KML support -->
    <script src="https://unpkg.com/@mapbox/togeojson@0.16.0/togeojson.js"></script>
    
    <!-- Turf.js for precise spatial analysis -->
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    
    <!-- Supabase JavaScript Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <!-- Main Application Script -->
    <script>
        // Global variables
        let map;
        let sidebar;
        let layers = new Map();
        let layerCounter = 0;
        let currentSymbologyLayer = null;
        let activeFilters = new Map();
        let layerOrder = []; // Array to track layer display order
        
        // Supabase Configuration
        const SUPABASE_URL = 'https://xravncpxynlzzewsqawh.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhyYXZuY3B4eW5senpld3NxYXdoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI4NDk5MTEsImV4cCI6MjA2ODQyNTkxMX0.2IE-dzQDVvq8b9u7C0oqy35FwVVMu96OGHBOYQEMSZw';
        let supabase;
        let currentUser = null;
        
        // Initialize Supabase client
        function initializeSupabase() {
            try {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('Supabase client initialized successfully');
                
                // Show warning about missing user_id column
                console.warn(`
⚠️  IMPORTANT: Your layers table is missing the 'user_id' column.
This means layers won't be properly isolated per user.

To fix this, run this SQL in your Supabase SQL Editor:

ALTER TABLE layers ADD COLUMN user_id UUID REFERENCES auth.users(id);
ALTER TABLE layers ALTER COLUMN user_id SET NOT NULL;

-- Enable Row Level Security
ALTER TABLE layers ENABLE ROW LEVEL SECURITY;

-- Add RLS policies
CREATE POLICY "Users can view own layers" ON layers FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own layers" ON layers FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own layers" ON layers FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own layers" ON layers FOR DELETE USING (auth.uid() = user_id);
                `);
                
                console.log('Make sure you have created the "layers" table in your Supabase database with the following SQL:');
                console.log(`
CREATE TABLE layers (
  id SERIAL PRIMARY KEY,
  layer_id VARCHAR(50) UNIQUE NOT NULL,
  name VARCHAR(255) NOT NULL,
  geojson_data JSONB NOT NULL,
  style JSONB,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add RLS (Row Level Security) policies
ALTER TABLE layers ENABLE ROW LEVEL SECURITY;

-- Users can only see and manage their own layers
CREATE POLICY "Users can view own layers" ON layers FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own layers" ON layers FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own layers" ON layers FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own layers" ON layers FOR DELETE USING (auth.uid() = user_id);
                `);
                return true;
            } catch (error) {
                console.error('Error initializing Supabase:', error);
                return false;
            }
        }

        // Authentication Functions
        
        // Check if user is logged in
        async function checkAuthState() {
            try {
                const { data: { session }, error } = await supabase.auth.getSession();
                
                if (error) {
                    console.error('Error checking auth state:', error);
                    return null;
                }
                
                if (session && session.user) {
                    currentUser = session.user;
                    console.log('User is logged in:', currentUser.email);
                    return session.user;
                }
                
                return null;
            } catch (error) {
                console.error('Error checking auth state:', error);
                return null;
            }
        }

        // Sign in user
        async function signInUser(email, password) {
            try {
                const { data, error } = await supabase.auth.signInWithPassword({
                    email: email,
                    password: password
                });

                if (error) {
                    throw error;
                }

                if (data.user) {
                    currentUser = data.user;
                    console.log('User signed in successfully:', currentUser.email);
                    return { success: true, user: data.user };
                }

                return { success: false, error: 'No user data received' };
            } catch (error) {
                console.error('Sign in error:', error);
                return { success: false, error: error.message };
            }
        }

        // Sign out user
        async function signOutUser() {
            try {
                const { error } = await supabase.auth.signOut();
                
                if (error) {
                    throw error;
                }

                currentUser = null;
                console.log('User signed out successfully');
                showLoginPage();
                return { success: true };
            } catch (error) {
                console.error('Sign out error:', error);
                return { success: false, error: error.message };
            }
        }

        // Show/Hide Login Page
        function showLoginPage() {
            document.getElementById('loginContainer').style.display = 'flex';
            document.getElementById('webgisContainer').style.display = 'none';
        }

        function hideLoginPage() {
            document.getElementById('loginContainer').style.display = 'none';
            document.getElementById('webgisContainer').style.display = 'flex';
        }
        
        // Show notification to user
        function showNotification(message, type = 'info', duration = 3000) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            
            // Style the notification
            const baseStyles = {
                position: 'fixed',
                top: '100px',
                right: '20px',
                padding: '12px 20px',
                borderRadius: '8px',
                color: 'white',
                fontWeight: '500',
                fontSize: '14px',
                zIndex: '10001',
                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.3)',
                animation: 'slideInRight 0.3s ease-out',
                maxWidth: '350px',
                wordWrap: 'break-word'
            };
            
            // Type-specific styles
            const typeStyles = {
                success: { backgroundColor: '#059669', border: '1px solid #065f46' },
                error: { backgroundColor: '#dc2626', border: '1px solid #991b1b' },
                info: { backgroundColor: '#0891b2', border: '1px solid #0e7490' }
            };
            
            // Apply styles
            Object.assign(notification.style, baseStyles, typeStyles[type] || typeStyles.info);
            
            // Add to body
            document.body.appendChild(notification);
            
            // Remove after duration
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, duration);
        }
        
        // Selection tool variables
        let drawControl;
        let drawnItems;
        let isSelectionActive = false;
        let selectedFeatures = [];
        let highlightedLayers = [];
        let popupsDisabled = false; // Flag to track if popups are disabled during selection

        // Freehand drawing variables - Two-click mode
        let isDrawing = false;
        let drawingPath = [];
        let currentDrawingLayer = null;
        let currentFillLayer = null;
        let activeSelectionLayerId = null; // Track which layer is active for selection
        let hasStartedDrawing = false; // Track if first click has been made (for two-click mode)

        // Middle mouse button panning variables
        let isMiddleMouseDown = false;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', async function() {
            // Initialize Supabase first
            if (!initializeSupabase()) {
                alert('Failed to connect to Supabase. Some features may not work properly.');
                return;
            }
            
            // Check if user is already logged in
            const user = await checkAuthState();
            
            if (user) {
                // User is logged in, show WebGIS interface
                currentUser = user;
                document.getElementById('userEmail').textContent = user.email;
                hideLoginPage();
                initializeWebGIS();
            } else {
                // User not logged in, show login page
                showLoginPage();
                setupLoginListeners();
            }
        });

        // Initialize WebGIS components
        function initializeWebGIS() {
            initializeMap();
            initializeSidebar();
            initializeEventListeners();
            loadInitialData();
        }

        // Initialize the Leaflet map
        function initializeMap() {
            map = L.map('map', {
                center: [14.5995, 120.9842], // Philippines center
                zoom: 6,
                zoomControl: true,
                dragging: true, // Enable normal left-click dragging
                doubleClickZoom: false, // Disable double-click zoom
                boxZoom: false // Disable Shift+drag zoom box
            });

            // Add ESRI Imagery basemap
            L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles © Esri — Developed by Isaac Enage for Ayala Land, Royal Asia Land, and AKL Properties.'
            }).addTo(map);

            // Move zoom control to bottom
            map.zoomControl.setPosition('bottomright');
            
            // Initialize selection tools
            initializeSelectionTools();
            
            // Add middle mouse button panning functionality
            initializeMiddleMousePanning();
        }

        // Initialize sidebar
        function initializeSidebar() {
            sidebar = L.control.sidebar('sidebar').addTo(map);
        }

        // Initialize event listeners
        function initializeEventListeners() {
            // Disable default browser context menu for the entire WebGIS interface
            document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            });

            // Close context menu when clicking anywhere (but preserve context variables for actions)
            document.addEventListener('click', function(e) {
                // Only hide the context menu if clicking outside of it
                const contextMenu = document.getElementById('layerContextMenu');
                if (contextMenu && !contextMenu.contains(e.target)) {
                    hideLayerContextMenu();
                }
            });

            // Tool button listeners - only Add Data, Filter, and Print buttons remain in header
            // Layers and Legend are accessed via sidebar tabs
            
            // Add Data button will trigger file dialog directly (handled by IIFE at bottom)
            // This is handled by the IIFE function at the bottom of the script

            // Filter and Print buttons - Filter now has comprehensive functionality
            // Filter functionality is now handled by the new filter panel system
            // No button listener needed as the panel is always accessible

            document.getElementById('printBtn').addEventListener('click', () => {
                alert('Print functionality temporarily disabled to prevent header blur issues.');
            });

            // Modal close listeners (but modals won't be opened from header buttons)
            setupModalListeners();
            
            // File upload listeners for modal (if needed)
            setupFileUploadListeners();
            
            // Symbology listeners
            setupSymbologyListeners();
            
            // Selection tool listeners
            setupSelectionListeners();

            // New comprehensive filter system
            setupNewFilterListeners();

            // Context menu listeners
            setupLayerContextMenuListeners();

            // Supabase button listeners
            setupSupabaseButtonListeners();

            // Logout button listener
            setupLogoutListener();
        }

        // Setup login page event listeners
        function setupLoginListeners() {
            const loginForm = document.getElementById('loginForm');
            const loginButton = document.getElementById('loginButton');
            const errorMessage = document.getElementById('errorMessage');
            const forgotPasswordLink = document.getElementById('forgotPasswordLink');

            // Handle login form submission
            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const email = document.getElementById('email').value.trim();
                const password = document.getElementById('password').value;

                // Validate inputs
                if (!email || !password) {
                    showError('Please fill in all fields.');
                    return;
                }

                // Show loading state
                setLoginLoading(true);
                hideError();

                // Attempt sign in
                const result = await signInUser(email, password);

                if (result.success) {
                    // Success - redirect to WebGIS
                    currentUser = result.user;
                    document.getElementById('userEmail').textContent = result.user.email;
                    hideLoginPage();
                    initializeWebGIS();
                } else {
                    // Show error
                    setLoginLoading(false);
                    showError(result.error || 'Sign in failed. Please try again.');
                }
            });

            // Handle forgot password link (placeholder)
            forgotPasswordLink.addEventListener('click', (e) => {
                e.preventDefault();
                alert('Password reset functionality will be implemented soon. Please contact your administrator.');
            });

            // Helper functions for login UI
            function showError(message) {
                errorMessage.textContent = message;
                errorMessage.style.display = 'block';
            }

            function hideError() {
                errorMessage.style.display = 'none';
            }

            function setLoginLoading(loading) {
                const loginButton = document.getElementById('loginButton');
                
                if (loading) {
                    loginButton.disabled = true;
                    loginButton.innerHTML = '<div class="loading-spinner"></div>Signing in...';
                } else {
                    loginButton.disabled = false;
                    loginButton.innerHTML = 'Sign In to WebGIS';
                }
            }
        }

        // Setup logout functionality
        function setupLogoutListener() {
            document.getElementById('logoutButton').addEventListener('click', async () => {
                if (confirm('Are you sure you want to logout?')) {
                    const result = await signOutUser();
                    if (!result.success) {
                        alert('Error logging out: ' + result.error);
                    }
                }
            });
        }

        // Setup Supabase button event listeners (cloud buttons removed)
        function setupSupabaseButtonListeners() {
            // Cloud data functionality has been removed
            console.log('Cloud data buttons removed - setupSupabaseButtonListeners() no longer needed');
        }

        // Setup modal event listeners
        function setupModalListeners() {
            // Add Data Modal
            document.getElementById('closeAddDataModal').addEventListener('click', () => {
                document.getElementById('addDataModal').classList.add('hidden');
            });

            document.getElementById('cancelUpload').addEventListener('click', () => {
                document.getElementById('addDataModal').classList.add('hidden');
            });

            // Filter Modal
            document.getElementById('closeFilterModal').addEventListener('click', () => {
                document.getElementById('filterModal').classList.add('hidden');
            });

            // Print Modal
            document.getElementById('closePrintModal').addEventListener('click', () => {
                document.getElementById('printModal').classList.add('hidden');
            });

            // Symbology Modal
            document.getElementById('closeSymbologyModal').addEventListener('click', () => {
                document.getElementById('symbologyModal').classList.add('hidden');
            });
        }

        // Setup file upload listeners
        function setupFileUploadListeners() {
            document.getElementById('uploadFile').addEventListener('click', handleFileUpload);
        }

        // Handle file upload
        function handleFileUpload() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a file to upload.');
                return;
            }

            // Check file size (50MB limit)
            if (file.size > 50 * 1024 * 1024) {
                alert('File size exceeds 50MB limit.');
                return;
            }

            // Check file type
            const validTypes = ['application/json', 'application/geo+json', 'application/vnd.google-earth.kml+xml'];
            const isValidType = validTypes.includes(file.type) || 
                               file.name.toLowerCase().endsWith('.geojson') || 
                               file.name.toLowerCase().endsWith('.json') || 
                               file.name.toLowerCase().endsWith('.kml') ||
                               file.name.toLowerCase().endsWith('.kmz');

            if (!isValidType) {
                alert('Please upload a valid GeoJSON, KML, or KMZ file.');
                return;
            }

            showUploadProgress();

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    let geoData;
                    
                    if (file.name.toLowerCase().endsWith('.kml')) {
                        // Parse KML
                        const parser = new DOMParser();
                        const kmlDoc = parser.parseFromString(e.target.result, 'text/xml');
                        geoData = toGeoJSON.kml(kmlDoc);
                    } else if (file.name.toLowerCase().endsWith('.kmz')) {
                        // Parse KMZ
                        function processModalKMZ(arrayBuffer) {
                            JSZip.loadAsync(arrayBuffer).then(zip => {
                                let kmlFile = null;
                                zip.forEach((relativePath, zipEntry) => {
                                    if (relativePath.toLowerCase().endsWith('.kml')) {
                                        kmlFile = zipEntry;
                                    }
                                });
                                if (!kmlFile) {
                                    alert('No KML file found inside KMZ.');
                                    hideUploadProgress();
                                    return;
                                }
                                kmlFile.async('string').then(kmlText => {
                                    try {
                                        const parser = new DOMParser();
                                        const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
                                        const geoData = toGeoJSON.kml(kmlDoc);
                                        if (!geoData || geoData.type !== 'FeatureCollection' || !Array.isArray(geoData.features)) {
                                            alert('Invalid or empty KML inside KMZ file.');
                                            hideUploadProgress();
                                            return;
                                        }
                                        addDataToMap(geoData, file.name);
                                        hideUploadProgress();
                                        document.getElementById('addDataModal').classList.add('hidden');
                                        document.getElementById('fileInput').value = '';
                                    } catch (err) {
                                        alert('Unable to read this file. Please upload a valid KMZ.');
                                        hideUploadProgress();
                                    }
                                }).catch(() => {
                                    alert('Unable to read this file. Please upload a valid KMZ.');
                                    hideUploadProgress();
                                });
                            }).catch(() => {
                                alert('Unable to read this file. Please upload a valid KMZ.');
                                hideUploadProgress();
                            });
                        }
                        if (typeof JSZip === 'undefined') {
                            const script = document.createElement('script');
                            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                            script.onload = () => processModalKMZ(e.target.result);
                            document.body.appendChild(script);
                        } else {
                            processModalKMZ(e.target.result);
                        }
                        return;
                    } else {
                        // Parse GeoJSON
                        geoData = JSON.parse(e.target.result);
                    }

                    addDataToMap(geoData, file.name);
                    hideUploadProgress();
                    document.getElementById('addDataModal').classList.add('hidden');
                    fileInput.value = '';

                } catch (error) {
                    console.error('Error parsing file:', error);
                    alert('Error parsing file. Please ensure it\'s a valid GeoJSON, KML, or KMZ file.');
                    hideUploadProgress();
                }
            };

            if (file.name.toLowerCase().endsWith('.kmz')) {
                reader.readAsArrayBuffer(file);
            } else {
                reader.readAsText(file);
            }
        }

        // Show upload progress
        function showUploadProgress() {
            document.getElementById('uploadProgress').classList.remove('hidden');
            
            let progress = 0;
            const interval = setInterval(() => {
                progress += 10;
                document.getElementById('progressBar').style.width = progress + '%';
                
                if (progress >= 100) {
                    clearInterval(interval);
                }
            }, 100);
        }

        // Hide upload progress
        function hideUploadProgress() {
            document.getElementById('uploadProgress').classList.add('hidden');
            document.getElementById('progressBar').style.width = '0%';
        }

        // Add data to map
        function addDataToMap(geoData, fileName, fromDatabase = false, supabaseLayerId = null, isPermanent = false) {
            const layerId = 'layer_' + (++layerCounter);
            const layerName = fileName.replace(/\.(geojson|json|kml)$/i, '');

            console.log(`Adding layer to map:`, {
                layerId: layerId,
                layerName: layerName,
                fileName: fileName,
                fromDatabase: fromDatabase,
                supabaseLayerId: supabaseLayerId,
                isPermanent: isPermanent
            });

            // Validate required parameters
            if (!geoData) {
                console.error('Cannot add layer: geoData is missing');
                return null;
            }
            if (!fileName) {
                console.error('Cannot add layer: fileName is missing');
                return null;
            }
            if (!layerId) {
                console.error('Cannot add layer: layerId generation failed');
                return null;
            }

            // Check if this is a permanent layer (like Aera.geojson) that already exists
            if (isPermanent) {
                const existingPermanentLayer = Array.from(layers.values()).find(l => 
                    l.isPermanent && l.name === layerName
                );
                if (existingPermanentLayer) {
                    console.log(`Permanent layer "${layerName}" already exists, skipping duplicate`);
                    return null;
                }
            }

            const style = {
                color: '#000000',
                weight: 0.5,
                opacity: 1.0,
                fillColor: '#14b8a6',
                fillOpacity: 1.0
            };

            const layer = L.geoJSON(geoData, {
                style: style,
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="text-sm">';
                        for (let key in feature.properties) {
                            popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                        popupContent += '</div>';
                        
                        // Use right-click popup binding (respects selection mode)
                        safeBindPopup(layer, popupContent);
                    }
                }
            }).addTo(map);

            // Store layer information with Supabase reference if applicable
            layers.set(layerId, {
                layer: layer,
                name: layerName,
                data: geoData,
                visible: true,
                style: style,
                originalData: geoData,
                opacity: 1.0, // Default opacity (100%)
                supabaseLayerId: supabaseLayerId, // Track the Supabase layer ID for database layers
                isPermanent: isPermanent, // Mark permanent layers (like Aera.geojson)
                fromDatabase: fromDatabase, // Track if this came from database
                layerId: layerId, // Store the local layer ID for reference
                createdAt: new Date().toISOString() // Track when layer was created locally
            });

            console.log(`Layer stored in layers map:`, {
                layerId: layerId,
                layerName: layerName,
                mapSize: layers.size,
                stored: layers.has(layerId)
            });

            // Add to layer order (new layers go to the beginning for top display)
            layerOrder.unshift(layerId);

            // Zoom to layer
            map.fitBounds(layer.getBounds());

            // Update UI (but skip legend update during loading from database)
            updateLayersList();
            if (!fromDatabase) {
                // Only update legend immediately for user-uploaded layers
                updateLegend();
            }
            // Note: Legend will be updated after symbology is applied for database layers

            // Save to Supabase ONLY if:
            // 1. Not already from database
            // 2. Supabase is connected
            // 3. Not a permanent/built-in layer
            // 4. Not the Aera layer specifically
            if (!fromDatabase && supabase && !isPermanent && 
                layerName !== 'Aera' && layerName !== 'Aera.geojson') {
                // Add async handling to show user feedback
                console.log(`Starting async save for layer "${layerName}" to Supabase...`);
                saveLayerToSupabase(layerId, layerName, geoData).then(() => {
                    // Update UI after successful save to show cloud icon
                    updateLayersList();
                    console.log(`Layer "${layerName}" save completed and UI updated`);
                }).catch(error => {
                    console.error('Failed to save layer to cloud:', error);
                    showNotification(`Failed to save layer "${layerName}" to cloud. Layer will only be available locally.`, 'error');
                });
            } else if (isPermanent) {
                console.log(`Permanent layer "${layerName}" loaded successfully (not saved to cloud)`);
            }

            // Update filter system with new layer
            populateFilterLayers();

            // Return the layer ID for reference
            return layerId;
        }

        // Supabase Functions
        
        // Save layer to Supabase
        async function saveLayerToSupabase(layerId, layerName, geoData) {
            try {
                if (!currentUser) {
                    console.error('User not authenticated, cannot save layer');
                    showNotification('Please log in to save layers to cloud', 'error');
                    return;
                }

                console.log(`Attempting to save layer "${layerName}" to Supabase...`);

                // First check if a layer with the same name already exists for this user
                // Note: Temporarily skip user_id check if column doesn't exist
                let existingLayers = [];
                let checkError = null;
                
                try {
                    const result = await supabase
                        .from('layers')
                        .select('id, name')
                        .eq('name', layerName)
                        .eq('user_id', currentUser.id); // Only check current user's layers
                    
                    existingLayers = result.data || [];
                    checkError = result.error;
                } catch (error) {
                    console.warn('Could not check for existing layers:', error);
                    existingLayers = [];
                    checkError = null;
                }

                if (checkError) {
                    console.error('Error checking for existing layers:', checkError);
                    showNotification(`Error checking cloud storage: ${checkError.message}`, 'error');
                    return;
                }

                // If layer exists, update it instead of creating a new one
                if (existingLayers && existingLayers.length > 0) {
                    console.log(`Updating existing layer "${layerName}" in Supabase...`);
                    const { data, error } = await supabase
                        .from('layers')
                        .update({
                            geojson_data: geoData,
                            style: layers.get(layerId).style,
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', existingLayers[0].id)
                        .eq('user_id', currentUser.id) // Ensure user can only update own layers
                        .select();

                    if (error) {
                        console.error('Error updating layer in Supabase:', error);
                        showNotification(`Failed to update layer "${layerName}" in cloud: ${error.message}`, 'error');
                    } else if (data && data.length > 0) {
                        // Store the Supabase ID in the layer info
                        const layerInfo = layers.get(layerId);
                        if (layerInfo) {
                            layerInfo.supabaseLayerId = data[0].id;
                            layerInfo.fromDatabase = true; // Mark as database layer
                            console.log(`Layer "${layerName}" updated with Supabase ID: ${data[0].id}. LayerInfo updated:`, {
                                layerId: layerId,
                                supabaseLayerId: layerInfo.supabaseLayerId,
                                fromDatabase: layerInfo.fromDatabase,
                                updatedData: data[0]
                            });
                        }
                        console.log('Layer updated in Supabase successfully:', layerName, 'with ID:', data[0].id);
                        showNotification(`Layer "${layerName}" updated in AKL cloud`, 'success');
                    }
                } else {
                    // Create new layer
                    console.log(`Creating new layer "${layerName}" in Supabase...`);
                    const { data, error } = await supabase
                        .from('layers')
                        .insert([
                            {
                                layer_id: layerId,
                                name: layerName,
                                geojson_data: geoData,
                                created_at: new Date().toISOString(),
                                style: layers.get(layerId).style,
                                user_id: currentUser.id // Associate with current user
                            }
                        ])
                        .select();

                    if (error) {
                        console.error('Error saving layer to Supabase:', error);
                        showNotification(`Failed to save layer "${layerName}" to cloud: ${error.message}`, 'error');
                    } else if (data && data.length > 0) {
                        // Store the Supabase ID in the layer info for future reference
                        const layerInfo = layers.get(layerId);
                        if (layerInfo) {
                            layerInfo.supabaseLayerId = data[0].id;
                            layerInfo.fromDatabase = true; // Mark as database layer
                            console.log(`Layer "${layerName}" saved with Supabase ID: ${data[0].id}. LayerInfo updated:`, {
                                layerId: layerId,
                                supabaseLayerId: layerInfo.supabaseLayerId,
                                fromDatabase: layerInfo.fromDatabase,
                                savedData: data[0]
                            });
                        }
                        console.log('Layer saved to Supabase successfully:', layerName, 'with ID:', data[0].id);
                        showNotification(`Layer "${layerName}" saved to AKL cloud`, 'success');
                    }
                }
            } catch (error) {
                console.error('Network error saving to Supabase:', error);
                showNotification(`Network error saving layer "${layerName}" to cloud: ${error.message}`, 'error');
            }
        }

        // Load layers from Supabase
        async function loadLayersFromSupabase() {
            try {
                if (!currentUser) {
                    console.error('User not authenticated, cannot load layers');
                    return;
                }

                console.log('Loading saved layers from Supabase for user:', currentUser.email);

                const { data: savedLayers, error } = await supabase
                    .from('layers')
                    .select('*')
                    .eq('user_id', currentUser.id) // Only load current user's layers
                    .order('created_at', { ascending: false });

                if (error) {
                    console.error('Error loading layers from Supabase:', error);
                    showNotification(`Error loading cloud layers: ${error.message}`, 'error');
                    return;
                }

                if (savedLayers && savedLayers.length > 0) {
                    console.log(`Found ${savedLayers.length} saved layers in Supabase`);
                    
                    let loadedCount = 0;
                    for (const savedLayer of savedLayers) {
                        // Handle Aera layer symbology specially
                        if (savedLayer.name === 'Aera' || savedLayer.name === 'Aera.geojson') {
                            console.log(`Found Aera layer symbology in database, applying to existing layer`);
                            
                            // Find the existing Aera layer and apply stored symbology
                            const aeraLayerEntry = Array.from(layers.entries()).find(([layerId, layerInfo]) => 
                                layerInfo.name === 'Aera'
                            );
                            
                            if (aeraLayerEntry && savedLayer.style) {
                                const [aeraLayerId] = aeraLayerEntry;
                                applyStoredSymbology(aeraLayerId, savedLayer.style);
                                console.log('Applied stored symbology to Aera layer');
                            }
                            continue;
                        }

                        // Skip if layer with the same Supabase ID already exists (exact duplicate from database)
                        const existingLayerBySuperbaseId = Array.from(layers.entries()).find(([layerId, layerInfo]) => 
                            layerInfo.supabaseLayerId && layerInfo.supabaseLayerId === savedLayer.id
                        );
                        if (existingLayerBySuperbaseId) {
                            console.log(`Skipping duplicate layer from database (by Supabase ID): ${savedLayer.name}`);
                            // But still apply symbology if it exists
                            if (savedLayer.style) {
                                const [existingLayerId] = existingLayerBySuperbaseId;
                                applyStoredSymbology(existingLayerId, savedLayer.style);
                            }
                            continue;
                        }

                        // Skip if layer with the same name already exists and is from database
                        const existingLayerByName = Array.from(layers.entries()).find(([layerId, layerInfo]) => 
                            layerInfo.name === savedLayer.name && layerInfo.fromDatabase
                        );
                        if (existingLayerByName) {
                            console.log(`Skipping duplicate layer from database (by name): ${savedLayer.name}`);
                            // But still apply symbology if it exists
                            if (savedLayer.style) {
                                const [existingLayerId] = existingLayerByName;
                                applyStoredSymbology(existingLayerId, savedLayer.style);
                            }
                            continue;
                        }

                        try {
                            // Add the saved layer to map with proper metadata
                            const newLayerId = addDataToMap(savedLayer.geojson_data, savedLayer.name, true, savedLayer.id, false);
                            
                            // Apply stored symbology if it exists
                            if (savedLayer.style && newLayerId) {
                                // Wait a bit for the layer to be fully added
                                setTimeout(() => {
                                    applyStoredSymbology(newLayerId, savedLayer.style);
                                }, 100);
                            }
                            
                            loadedCount++;
                        } catch (layerError) {
                            console.error(`Error loading layer "${savedLayer.name}":`, layerError);
                        }
                    }
                    
                    if (loadedCount > 0) {
                        showNotification(`Loaded ${loadedCount} layers from AKL cloud`, 'success');
                    } else {
                        console.log('No new layers to load from Supabase (all already present)');
                    }
                    
                    // Update legend after all symbology has been applied (with a small delay)
                    setTimeout(() => {
                        updateLegend();
                    }, 200);
                } else {
                    console.log('No saved layers found in Supabase for current user');
                }
            } catch (error) {
                console.error('Network error loading from Supabase:', error);
                showNotification(`Network error loading cloud layers: ${error.message}`, 'error');
            }
        }

        // Update layer in Supabase (for style changes, etc.)
        async function updateLayerInSupabase(layerId) {
            try {
                if (!currentUser) {
                    console.error('User not authenticated, cannot update layer');
                    return;
                }

                const layerInfo = layers.get(layerId);
                if (!layerInfo) return;

                let query = supabase.from('layers').update({
                    style: layerInfo.style,
                    geojson_data: layerInfo.data,
                    updated_at: new Date().toISOString()
                }).eq('user_id', currentUser.id); // Ensure user owns the layer

                // Use Supabase layer ID if available, otherwise fall back to local layer ID
                if (layerInfo.supabaseLayerId) {
                    query = query.eq('id', layerInfo.supabaseLayerId);
                } else {
                    query = query.eq('layer_id', layerId);
                }

                const { error } = await query;

                if (error) {
                    console.error('Error updating layer in Supabase:', error);
                } else {
                    console.log('Layer updated in Supabase successfully');
                }
            } catch (error) {
                console.error('Network error updating Supabase:', error);
            }
        }

        // Delete layer from Supabase
        async function deleteLayerFromSupabase(layerId, layerName = 'Unknown') {
            try {
                if (!currentUser) {
                    console.error('User not authenticated, cannot delete layer');
                    return { success: false, error: 'User not authenticated' };
                }

                const layerInfo = layers.get(layerId);
                if (!layerInfo) {
                    console.error(`Layer info not found for layerId: ${layerId}`);
                    return { success: false, error: 'Layer not found in local storage' };
                }

                // Don't delete permanent layers from database
                if (layerInfo.isPermanent) {
                    console.log(`Skipping database deletion for permanent layer: ${layerName}`);
                    return { success: true }; // Return success since permanent layers shouldn't be in DB anyway
                }

                console.log(`Attempting to delete layer from Supabase:`, {
                    localLayerId: layerId,
                    supabaseLayerId: layerInfo.supabaseLayerId,
                    layerName: layerName,
                    userId: currentUser.id,
                    fromDatabase: layerInfo.fromDatabase,
                    isPermanent: layerInfo.isPermanent,
                    hasSupabaseId: !!(layerInfo.supabaseLayerId && layerInfo.supabaseLayerId !== null && layerInfo.supabaseLayerId !== 'null')
                });

                // If the layer doesn't have a supabaseLayerId and wasn't loaded from database, 
                // it's likely a local-only layer that was never saved
                if (!layerInfo.supabaseLayerId && !layerInfo.fromDatabase) {
                    console.log(`Layer "${layerName}" is local-only (no Supabase ID), skipping database deletion`);
                    return { success: true };
                }

                let query = supabase.from('layers').delete().eq('user_id', currentUser.id); // Ensure user can only delete own layers
                let queryDescription = '';
                
                // Use Supabase layer ID if available (more reliable), otherwise try layer name
                if (layerInfo.supabaseLayerId && layerInfo.supabaseLayerId !== null && layerInfo.supabaseLayerId !== 'null') {
                    query = query.eq('id', layerInfo.supabaseLayerId);
                    queryDescription = `Supabase ID: ${layerInfo.supabaseLayerId}, User ID: ${currentUser.id}`;
                } else if (layerInfo.fromDatabase) {
                    // If it came from database but no supabaseLayerId, try to find by name and layer_id
                    query = query.eq('name', layerName).eq('layer_id', layerId);
                    queryDescription = `Name: ${layerName}, Layer ID: ${layerId}, User ID: ${currentUser.id}`;
                } else {
                    // Last resort: try deleting by layer_id only (for newly uploaded layers)
                    query = query.eq('layer_id', layerId);
                    queryDescription = `Layer ID: ${layerId}, User ID: ${currentUser.id}`;
                }

                console.log(`Executing delete query with ${queryDescription}`);
                const { data, error } = await query;

                console.log(`Delete query result:`, {
                    queryDescription: queryDescription,
                    resultData: data,
                    error: error,
                    hasData: !!data,
                    dataLength: data ? data.length : 0
                });

                if (error) {
                    console.error(`Error deleting layer "${layerName}" from Supabase:`, error);
                    return { success: false, error: `Database error: ${error.message}` };
                } else {
                    console.log(`Layer "${layerName}" deleted from Supabase successfully using ${queryDescription}`);
                    return { success: true };
                }
            } catch (error) {
                console.error(`Network error deleting layer "${layerName}" from Supabase:`, error);
                return { success: false, error: `Network error: ${error.message}` };
            }
        }

        // Load initial Aera.geojson data
        function loadInitialData() {
            // Load local Aera.geojson data - this is a permanent, built-in layer
            fetch('Aera.geojson')
                .then(response => response.json())
                .then(data => {
                    // Mark as permanent layer and from local source
                    addDataToMap(data, 'Aera.geojson', false, null, true);
                })
                .catch(error => {
                    console.error('Error loading Aera.geojson:', error);
                    // Continue without the initial data
                });
            
            // Load saved layers from Supabase after a brief delay to ensure Aera loads first
            if (supabase) {
                setTimeout(() => {
                    loadLayersFromSupabase();
                    // Also check for Aera layer symbology after loading other layers
                    checkAndApplyAeraSymbology();
                }, 500);
            }
        }

        // Check and apply Aera layer symbology from Supabase
        async function checkAndApplyAeraSymbology() {
            if (!supabase || !currentUser) {
                console.log('Cannot check Aera symbology: Supabase not available or user not logged in');
                return;
            }

            try {
                console.log('Checking for stored Aera layer symbology...');
                
                const { data: aeraLayer, error } = await supabase
                    .from('layers')
                    .select('style')
                    .eq('user_id', currentUser.id)
                    .eq('name', 'Aera')
                    .single();

                if (error && error.code !== 'PGRST116') { // PGRST116 is "not found"
                    console.error('Error checking for Aera layer symbology:', error);
                    return;
                }

                if (aeraLayer && aeraLayer.style) {
                    console.log('Found stored Aera symbology, applying...');
                    
                    // Find the Aera layer
                    const aeraLayerEntry = Array.from(layers.entries()).find(([layerId, layerInfo]) => 
                        layerInfo.name === 'Aera'
                    );
                    
                    if (aeraLayerEntry) {
                        const [aeraLayerId] = aeraLayerEntry;
                        applyStoredSymbology(aeraLayerId, aeraLayer.style);
                        console.log('Applied stored symbology to Aera layer');
                    }
                } else {
                    console.log('No stored Aera symbology found, using default');
                }
            } catch (error) {
                console.error('Error checking Aera layer symbology:', error);
            }
        }

        // Update layers list in sidebar
        function updateLayersList() {
            const layersList = document.getElementById('layersList');
            layersList.innerHTML = '';

            // Use layerOrder to maintain consistent ordering
            layerOrder.forEach(layerId => {
                if (!layers.has(layerId)) return; // Skip deleted layers

                const layerInfo = layers.get(layerId);
                const layerDiv = document.createElement('div');
                layerDiv.className = 'layer-item rounded-lg p-3 glass-panel';
                layerDiv.draggable = true;
                layerDiv.setAttribute('data-layer-id', layerId);
                layerDiv.setAttribute('data-layer-name', layerInfo.name);
                
                layerDiv.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <div class="flex items-center space-x-2">
                            <i class="fas fa-grip-vertical layer-drag-handle text-sm"></i>
                            <span class="font-medium ${layerInfo.isPermanent ? 'text-amber-300' : 'text-white'} truncate">
                                ${layerInfo.name}
                                ${layerInfo.isPermanent ? '<i class="fas fa-lock text-xs ml-1" title="Permanent layer - cannot be deleted"></i>' : ''}
                                ${layerInfo.fromDatabase ? '<i class="fas fa-cloud text-xs ml-1 text-blue-400" title="Saved to cloud"></i>' : ''}
                            </span>
                        </div>
                        <div class="flex items-center space-x-3">
                            <button class="symbology-btn text-teal-400 hover:text-teal-300 text-lg transition-colors" data-layer="${layerId}" title="Edit Symbology">
                                <i class="fas fa-palette"></i>
                            </button>
                            <button class="visibility-btn text-lg transition-colors cursor-pointer" data-layer="${layerId}" title="Toggle Visibility">
                                <i class="fas ${layerInfo.visible ? 'fa-eye text-teal-400 hover:text-teal-300' : 'fa-eye-slash text-gray-500 hover:text-gray-400'}"></i>
                            </button>
                        </div>
                    </div>
                    <div class="text-xs text-gray-400 italic">
                        ${Object.keys(layerInfo.data.features || {}).length || layerInfo.data.features?.length || 0} features
                        ${layerInfo.isPermanent ? ' • Built-in layer' : ''}
                        ${layerInfo.fromDatabase && !layerInfo.isPermanent ? ' • Cloud synced' : ''}
                    </div>
                `;

                layersList.appendChild(layerDiv);

                // Setup drag and drop for this layer
                setupLayerDragDrop(layerDiv, layerId);

                // Add existing event listeners
                const visibilityBtn = layerDiv.querySelector('.visibility-btn');
                visibilityBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const currentVisibility = layers.get(layerId).visible;
                    toggleLayerVisibility(layerId, !currentVisibility);
                });

                const symbologyBtn = layerDiv.querySelector('.symbology-btn');
                symbologyBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Symbology button clicked for layer:', layerId);
                    try {
                        openSymbologyEditor(layerId);
                    } catch (error) {
                        console.error('Error opening symbology editor:', error);
                        alert('Error opening symbology editor. Check console for details.');
                    }
                });

                // Add right-click context menu listener to the layer item
                layerDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    showLayerContextMenu(e, layerId, layerInfo.name);
                });
            });
            
            // Update map layer order after UI update
            updateMapLayerOrder();
            
            // Update selection layer dropdown
            updateSelectionLayerDropdown();
        }

        // Setup drag and drop for layer items
        function setupLayerDragDrop(layerDiv, layerId) {
            console.log(`Setting up drag-and-drop for layer: ${layerId}`);

            // Drag start
            layerDiv.addEventListener('dragstart', (e) => {
                console.log(`Drag started for layer: ${layerId}`);
                layerDiv.classList.add('dragging');
                layerDiv.style.opacity = '0.5';
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', layerId);
                
                // Store reference for other event listeners
                layerDiv.setAttribute('data-dragging', 'true');
            });

            // Drag end
            layerDiv.addEventListener('dragend', (e) => {
                console.log(`Drag ended for layer: ${layerId}`);
                layerDiv.classList.remove('dragging');
                layerDiv.style.opacity = '1';
                layerDiv.removeAttribute('data-dragging');
                
                // Remove drag-over class from all layer items
                document.querySelectorAll('.layer-item').forEach(item => {
                    item.classList.remove('drag-over');
                });
            });

            // Drag over - CRITICAL: Must prevent default to allow drop
            layerDiv.addEventListener('dragover', (e) => {
                e.preventDefault(); // This is essential!
                e.stopPropagation();
                
                const draggingElement = document.querySelector('[data-dragging="true"]');
                if (draggingElement && draggingElement !== layerDiv) {
                    e.dataTransfer.dropEffect = 'move';
                    layerDiv.classList.add('drag-over');
                }
            });

            // Drag enter
            layerDiv.addEventListener('dragenter', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                const draggingElement = document.querySelector('[data-dragging="true"]');
                if (draggingElement && draggingElement !== layerDiv) {
                    layerDiv.classList.add('drag-over');
                }
            });

            // Drag leave
            layerDiv.addEventListener('dragleave', (e) => {
                // Only remove drag-over if we're actually leaving this element
                if (!layerDiv.contains(e.relatedTarget)) {
                    layerDiv.classList.remove('drag-over');
                }
            });

            // Drop
            layerDiv.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                console.log(`Drop event on layer: ${layerId}`);
                layerDiv.classList.remove('drag-over');
                
                const draggedLayerId = e.dataTransfer.getData('text/plain');
                const targetLayerId = layerId;
                
                console.log(`Attempting to reorder: ${draggedLayerId} -> ${targetLayerId}`);
                
                if (draggedLayerId && draggedLayerId !== targetLayerId) {
                    reorderLayer(draggedLayerId, targetLayerId);
                }
            });
        }

        // Reorder layers in the layerOrder array
        function reorderLayer(draggedLayerId, targetLayerId) {
            console.log(`Reordering layers:`, {
                draggedLayerId: draggedLayerId,
                targetLayerId: targetLayerId,
                currentOrder: [...layerOrder]
            });

            const draggedIndex = layerOrder.indexOf(draggedLayerId);
            const targetIndex = layerOrder.indexOf(targetLayerId);
            
            if (draggedIndex !== -1 && targetIndex !== -1) {
                // Remove the dragged layer from its current position
                layerOrder.splice(draggedIndex, 1);
                
                // Insert it at the target position
                const newTargetIndex = layerOrder.indexOf(targetLayerId);
                layerOrder.splice(newTargetIndex, 0, draggedLayerId);
                
                console.log(`Layer order updated:`, {
                    oldIndex: draggedIndex,
                    newIndex: layerOrder.indexOf(draggedLayerId),
                    newOrder: [...layerOrder]
                });
                
                // Update the UI and map rendering order
                updateLayersList();
                updateMapLayerOrder();
                
                // Show feedback to user
                const draggedLayerInfo = layers.get(draggedLayerId);
                const draggedLayerName = draggedLayerInfo ? draggedLayerInfo.name : 'Unknown';
                showNotification(`Layer "${draggedLayerName}" reordered successfully`, 'success', 2000);
            }
        }

        // Update map layer rendering order
        function updateMapLayerOrder() {
            console.log('Updating map layer rendering order:', layerOrder);
            
            // CORRECTED LOGIC:
            // - Top layer in panel = highest z-index (rendered on top) 
            // - Bottom layer in panel = lowest z-index (rendered at back)
            // - Process layerOrder directly: first item = top of panel = should be on top of map
            
            // First, bring all layers to back to reset their z-index order
            layerOrder.forEach((layerId) => {
                const layerInfo = layers.get(layerId);
                if (layerInfo && layerInfo.visible && layerInfo.layer) {
                    try {
                        layerInfo.layer.bringToBack();
                    } catch (error) {
                        console.warn(`Could not bring layer ${layerId} to back:`, error);
                    }
                }
            });
            
            // Then, bring layers to front in REVERSE order
            // This ensures the FIRST layer in layerOrder (top of panel) ends up on top of map
            const reversedOrder = [...layerOrder].reverse();
            reversedOrder.forEach((layerId) => {
                const layerInfo = layers.get(layerId);
                if (layerInfo && layerInfo.visible && layerInfo.layer) {
                    try {
                        layerInfo.layer.bringToFront();
                        console.log(`Brought layer "${layerInfo.name}" (${layerId}) to front - Panel position: ${layerOrder.indexOf(layerId) + 1}`);
                    } catch (error) {
                        console.warn(`Could not bring layer ${layerId} to front:`, error);
                    }
                }
            });
            
            console.log('Map layer rendering order updated successfully');
            console.log('Final z-index order (bottom to top):', reversedOrder.map(id => {
                const info = layers.get(id);
                return info ? info.name : id;
            }));
        }

        // Update selection layer dropdown with visible layers
        function updateSelectionLayerDropdown() {
            const activeLayerSelect = document.getElementById('activeLayerSelect');
            const currentValue = activeLayerSelect.value;
            
            // Clear existing options
            activeLayerSelect.innerHTML = '<option value="">Select a layer first</option>';
            
            // Add visible layers to dropdown
            layers.forEach((layerInfo, layerId) => {
                if (layerInfo.visible) {
                    const option = document.createElement('option');
                    option.value = layerId;
                    option.textContent = layerInfo.name;
                    
                    // Keep current selection if still valid
                    if (layerId === currentValue) {
                        option.selected = true;
                    }
                    
                    activeLayerSelect.appendChild(option);
                }
            });
            
            // If current selection is no longer valid, reset
            if (currentValue && !layers.has(currentValue) || (currentValue && !layers.get(currentValue).visible)) {
                activeSelectionLayerId = null;
                activeLayerSelect.value = '';
                
                // Disable activate button
                const activateBtn = document.getElementById('activateSelectTool');
                activateBtn.disabled = true;
                activateBtn.classList.add('opacity-50', 'cursor-not-allowed');
                
                // If selection is active, deactivate it
                if (isSelectionActive) {
                    deactivateSelectionTool();
                }
            }
        }

        // Toggle layer visibility
        function toggleLayerVisibility(layerId, visible) {
            const layerInfo = layers.get(layerId);
            if (layerInfo) {
                if (visible) {
                    map.addLayer(layerInfo.layer);
                } else {
                    map.removeLayer(layerInfo.layer);
                }
                layerInfo.visible = visible;
                
                // Update map layer order after visibility change
                updateMapLayerOrder();
                
                updateLegend();
                updateSelectionLayerDropdown(); // Update selection dropdown when layer visibility changes
                populateFilterLayers(); // Update filter dropdown when layer visibility changes
                updateLayersList(); // Update layer list to refresh icons
            }
        }

        // Layer Context Menu Functions
        let currentContextLayerId = null;
        let currentContextLayerName = null;

        // Show layer context menu
        function showLayerContextMenu(event, layerId, layerName) {
            console.log(`Showing context menu for layer:`, {
                layerId: layerId,
                layerName: layerName,
                layerExists: layers.has(layerId)
            });

            // Validate parameters
            if (!layerId) {
                console.error('Cannot show context menu: layerId is null or undefined');
                return;
            }
            if (!layerName) {
                console.error('Cannot show context menu: layerName is null or undefined');
                return;
            }

            // Verify layer exists in the layers map
            if (!layers.has(layerId)) {
                console.error(`Cannot show context menu: Layer ${layerId} not found in layers map`);
                console.log('Available layers:', Array.from(layers.keys()));
                return;
            }

            const contextMenu = document.getElementById('layerContextMenu');
            const deleteItem = document.getElementById('contextDelete');
            const renameItem = document.getElementById('contextRename');
            
            // Reset and set the context variables for the new layer
            currentContextLayerId = layerId;
            currentContextLayerName = layerName;
            
            console.log(`Context menu variables set:`, {
                currentContextLayerId: currentContextLayerId,
                currentContextLayerName: currentContextLayerName
            });
            
            const layerInfo = layers.get(layerId);
            // Check if this is a permanent layer and disable delete/rename if so
            const isPermanentLayer = layerInfo && layerInfo.isPermanent;
            if (isPermanentLayer) {
                deleteItem.classList.add('disabled');
                renameItem.classList.add('disabled');
            } else {
                deleteItem.classList.remove('disabled');
                renameItem.classList.remove('disabled');
            }
            
            // Position the context menu at cursor location
            contextMenu.style.display = 'block';
            contextMenu.style.left = event.clientX + 'px';
            contextMenu.style.top = event.clientY + 'px';
            
            // Ensure menu stays within viewport
            const rect = contextMenu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            if (rect.right > viewportWidth) {
                contextMenu.style.left = (event.clientX - rect.width) + 'px';
            }
            if (rect.bottom > viewportHeight) {
                contextMenu.style.top = (event.clientY - rect.height) + 'px';
            }
            
            // Prevent event propagation
            event.stopPropagation();
        }

        // Hide layer context menu
        function hideLayerContextMenu() {
            const contextMenu = document.getElementById('layerContextMenu');
            contextMenu.style.display = 'none';
            
            // Don't reset the context variables immediately - they might be needed for menu actions
            // They will be reset when a new context menu is shown
        }

        // Reset context menu variables (called after actions are completed)
        function resetContextMenuVariables() {
            currentContextLayerId = null;
            currentContextLayerName = null;
        }

        // Setup context menu event listeners
        function setupLayerContextMenuListeners() {
            const contextMenu = document.getElementById('layerContextMenu');
            
            // Prevent menu from closing when clicking inside it
            contextMenu.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            // Zoom to Layer
            document.getElementById('contextZoomToLayer').addEventListener('click', function() {
                if (currentContextLayerId) {
                    zoomToLayer(currentContextLayerId);
                    hideLayerContextMenu();
                }
            });
            
            // Rename Layer
            document.getElementById('contextRename').addEventListener('click', function() {
                if (currentContextLayerId && currentContextLayerName) {
                    hideLayerContextMenu();
                    renameLayer(currentContextLayerId, currentContextLayerName);
                }
            });
            
            // Properties (open symbology editor)
            document.getElementById('contextProperties').addEventListener('click', function() {
                if (currentContextLayerId) {
                    try {
                        openSymbologyEditor(currentContextLayerId);
                        hideLayerContextMenu();
                    } catch (error) {
                        console.error('Error opening symbology editor:', error);
                        alert('Error opening symbology editor. Check console for details.');
                    }
                }
            });
            
            // Delete Layer
            document.getElementById('contextDelete').addEventListener('click', async function() {
                console.log(`Delete layer clicked:`, {
                    currentContextLayerId: currentContextLayerId,
                    currentContextLayerName: currentContextLayerName,
                    disabled: this.classList.contains('disabled')
                });

                // Get layer information from the stored context variables
                const layerIdToDelete = currentContextLayerId;
                const layerNameToDelete = currentContextLayerName;

                // Validate we have the required information
                if (!layerIdToDelete) {
                    console.error('Cannot delete layer: No layer ID available from context menu');
                    showNotification('Cannot delete layer: No layer selected.', 'error');
                    hideLayerContextMenu();
                    return;
                }

                if (!layerNameToDelete) {
                    console.error('Cannot delete layer: No layer name available from context menu');
                    showNotification('Cannot delete layer: No layer name available.', 'error');
                    hideLayerContextMenu();
                    return;
                }

                if (!this.classList.contains('disabled')) {
                    // Validate layer exists before attempting deletion
                    if (!layers.has(layerIdToDelete)) {
                        console.error(`Cannot delete layer: Layer ${layerIdToDelete} not found in layers map`);
                        showNotification(`Layer not found in system. Cannot delete.`, 'error');
                        resetContextMenuVariables();
                        return;
                    }

                    // Hide menu first, then delete
                    hideLayerContextMenu();
                    
                    try {
                        await deleteLayer(layerIdToDelete, layerNameToDelete);
                    } finally {
                        // Always reset variables after deletion attempt
                        resetContextMenuVariables();
                    }
                } else if (this.classList.contains('disabled')) {
                    const layerInfo = layers.get(layerIdToDelete);
                    if (layerInfo && layerInfo.isPermanent) {
                        showNotification(`"${layerNameToDelete}" is a permanent layer and cannot be deleted.`, 'info');
                    } else {
                        showNotification('This layer cannot be deleted.', 'info');
                    }
                    resetContextMenuVariables();
                } else {
                    console.error('Delete layer failed: No valid layer ID or name available');
                    showNotification('Cannot delete layer: Invalid layer reference.', 'error');
                    resetContextMenuVariables();
                }
            });
        }

        // Zoom to layer function
        function zoomToLayer(layerId) {
            const layerInfo = layers.get(layerId);
            if (layerInfo && layerInfo.visible && layerInfo.layer) {
                try {
                    const bounds = layerInfo.layer.getBounds();
                    if (bounds && bounds.isValid()) {
                        map.fitBounds(bounds);
                    } else {
                        alert('Unable to determine layer extent.');
                    }
                } catch (error) {
                    console.error('Error zooming to layer:', error);
                    alert('Error zooming to layer.');
                }
            } else {
                alert('Layer is not visible or not found.');
            }
        }

        // Delete layer function
        async function deleteLayer(layerId, layerName) {
            console.log(`Starting deleteLayer function:`, {
                layerId: layerId,
                layerName: layerName,
                layersMapSize: layers.size,
                layerExists: layers.has(layerId)
            });

            // Comprehensive validation
            if (!layerId) {
                const errorMsg = `Cannot delete layer: layerId is null or undefined`;
                console.error(errorMsg);
                showNotification(errorMsg, 'error');
                return;
            }

            if (!layerName) {
                const errorMsg = `Cannot delete layer: layerName is null or undefined for layer ID ${layerId}`;
                console.error(errorMsg);
                showNotification(errorMsg, 'error');
                return;
            }

            // Verify layer exists in layers map
            if (!layers.has(layerId)) {
                const errorMsg = `Layer "${layerName}" (ID: ${layerId}) not found in layers collection`;
                console.error(errorMsg);
                console.log('Available layers:', Array.from(layers.keys()));
                showNotification(errorMsg, 'error');
                return;
            }

            // Get layer info and validate it exists
            const layerInfo = layers.get(layerId);
            if (!layerInfo) {
                const errorMsg = `Layer info for "${layerName}" (ID: ${layerId}) is null or undefined`;
                console.error(errorMsg);
                showNotification(errorMsg, 'error');
                return;
            }

            // Prevent deletion of permanent layers
            if (layerInfo.isPermanent) {
                const msg = `"${layerName}" is a permanent layer and cannot be deleted.`;
                console.log(msg);
                showNotification(msg, 'info');
                return;
            }

            // Confirm deletion
            if (confirm(`Are you sure you want to delete the layer "${layerName}"?`)) {
                console.log(`Starting deletion process for layer:`, {
                    layerId: layerId,
                    layerName: layerName,
                    supabaseLayerId: layerInfo.supabaseLayerId,
                    isPermanent: layerInfo.isPermanent,
                    fromDatabase: layerInfo.fromDatabase
                });
                
                try {
                    // Delete from Supabase first (if it's a database layer or has been saved)
                    if (supabase && !layerInfo.isPermanent) {
                        // Check if this layer should be deleted from database
                        const shouldDeleteFromDB = layerInfo.fromDatabase || 
                                                   (layerInfo.supabaseLayerId && 
                                                    layerInfo.supabaseLayerId !== null && 
                                                    layerInfo.supabaseLayerId !== 'null');
                        
                        if (shouldDeleteFromDB) {
                            console.log(`Deleting layer "${layerName}" from Supabase...`);
                            const deleteResult = await deleteLayerFromSupabase(layerId, layerName);
                            
                            if (!deleteResult.success) {
                                console.error(`Database deletion failed:`, deleteResult.error);
                                if (confirm(`Failed to delete layer from database: ${deleteResult.error}\n\nDo you want to delete it locally anyway?`)) {
                                    console.log('User chose to delete locally despite database error');
                                } else {
                                    return; // User cancelled, don't delete locally
                                }
                            } else {
                                console.log(`Layer "${layerName}" successfully deleted from Supabase`);
                            }
                        } else {
                            console.log(`Layer "${layerName}" is local-only, no database deletion needed`);
                        }
                    } else if (layerInfo.isPermanent) {
                        console.log(`Layer "${layerName}" is permanent, skipping database deletion`);
                    }

                    // Remove layer from map
                    if (layerInfo.layer) {
                        map.removeLayer(layerInfo.layer);
                        console.log(`Layer "${layerName}" removed from map`);
                    } else {
                        console.warn(`Layer "${layerName}" has no map layer to remove`);
                    }
                    
                    // Remove from layers collection
                    layers.delete(layerId);
                    console.log(`Layer "${layerName}" removed from layers collection`);
                    
                    // Remove from layer order
                    const orderIndex = layerOrder.indexOf(layerId);
                    if (orderIndex !== -1) {
                        layerOrder.splice(orderIndex, 1);
                        console.log(`Layer "${layerName}" removed from layer order at index ${orderIndex}`);
                    } else {
                        console.warn(`Layer "${layerName}" not found in layer order array`);
                    }
                    
                    // Remove any active filters for this layer
                    if (activeFilters.has(layerId)) {
                        activeFilters.delete(layerId);
                        console.log(`Filters removed for layer "${layerName}"`);
                    }
                    
                    // If this layer was selected for selection tool, deactivate it
                    if (activeSelectionLayerId === layerId) {
                        activeSelectionLayerId = null;
                        if (isSelectionActive) {
                            deactivateSelectionTool();
                        }
                        console.log(`Selection tool deactivated for deleted layer "${layerName}"`);
                    }
                    
                    // Update UI
                    updateLayersList();
                    updateLegend();
                    updateSelectionLayerDropdown();
                    populateFilterLayers();
                    
                    console.log(`Layer "${layerName}" (${layerId}) deleted successfully`);
                    
                    // Show success notification
                    showNotification(`Layer "${layerName}" deleted successfully`, 'success');
                    
                } catch (error) {
                    console.error('Error during layer deletion:', error);
                    showNotification(`Error deleting layer "${layerName}": ${error.message}`, 'error');
                }
            }
        }

        // Rename layer function
        async function renameLayer(layerId, currentName) {
            console.log(`Starting renameLayer function:`, {
                layerId: layerId,
                currentName: currentName,
                layerExists: layers.has(layerId)
            });

            // Validate parameters
            if (!layerId) {
                console.error('Cannot rename layer: layerId is null or undefined');
                showNotification('Cannot rename layer: No layer ID provided.', 'error');
                return;
            }

            if (!currentName) {
                console.error('Cannot rename layer: currentName is null or undefined');
                showNotification('Cannot rename layer: No current name provided.', 'error');
                return;
            }

            // Verify layer exists in layers map
            if (!layers.has(layerId)) {
                const errorMsg = `Layer "${currentName}" (ID: ${layerId}) not found in layers collection`;
                console.error(errorMsg);
                showNotification(errorMsg, 'error');
                return;
            }

            // Get layer info and validate it exists
            const layerInfo = layers.get(layerId);
            if (!layerInfo) {
                const errorMsg = `Layer info for "${currentName}" (ID: ${layerId}) is null or undefined`;
                console.error(errorMsg);
                showNotification(errorMsg, 'error');
                return;
            }

            // Prevent renaming of permanent layers
            if (layerInfo.isPermanent) {
                const msg = `"${currentName}" is a permanent layer and cannot be renamed.`;
                console.log(msg);
                showNotification(msg, 'info');
                return;
            }

            // Prompt user for new name
            const newName = prompt(`Enter new name for layer "${currentName}":`, currentName);
            
            if (newName === null) {
                // User cancelled
                return;
            }
            
            if (newName.trim() === '') {
                showNotification('Layer name cannot be empty.', 'error');
                return;
            }
            
            if (newName.trim() === currentName) {
                // No change needed
                return;
            }

            const trimmedNewName = newName.trim();

            // Check if another layer already has this name
            const existingLayerWithName = Array.from(layers.values()).find(layer => 
                layer.name === trimmedNewName && layer !== layerInfo
            );
            
            if (existingLayerWithName) {
                showNotification(`A layer named "${trimmedNewName}" already exists.`, 'error');
                return;
            }

            try {
                console.log(`Renaming layer from "${currentName}" to "${trimmedNewName}"`);

                // Update the layer name locally
                layerInfo.name = trimmedNewName;
                
                // Update Supabase if layer is from database or has been saved
                if (supabase && (layerInfo.fromDatabase || layerInfo.supabaseLayerId)) {
                    console.log(`Updating layer name in Supabase...`);
                    const updateResult = await updateLayerNameInSupabase(layerId, trimmedNewName);
                    if (!updateResult.success) {
                        console.error('Failed to update layer name in Supabase:', updateResult.error);
                        showNotification(`Layer renamed locally, but failed to update in cloud: ${updateResult.error}`, 'error');
                    }
                }

                // Update the UI
                updateLayersList();
                updateSelectionLayerDropdown();
                updateLegend();

                // Show success notification
                showNotification(`Layer renamed to "${trimmedNewName}" successfully`, 'success', 2000);
                
                console.log(`Layer renamed successfully:`, {
                    layerId: layerId,
                    oldName: currentName,
                    newName: trimmedNewName
                });

            } catch (error) {
                console.error('Error renaming layer:', error);
                showNotification(`Error renaming layer: ${error.message}`, 'error');
                
                // Revert local name change if error occurred
                layerInfo.name = currentName;
            }
        }

        // Update layer name in Supabase
        async function updateLayerNameInSupabase(layerId, newName) {
            try {
                if (!currentUser) {
                    console.error('User not authenticated, cannot update layer name');
                    return { success: false, error: 'User not authenticated' };
                }

                const layerInfo = layers.get(layerId);
                if (!layerInfo) {
                    return { success: false, error: 'Layer not found in local storage' };
                }

                console.log(`Attempting to update layer name in Supabase:`, {
                    localLayerId: layerId,
                    supabaseLayerId: layerInfo.supabaseLayerId,
                    newName: newName,
                    userId: currentUser.id
                });

                let query = supabase.from('layers').update({
                    name: newName,
                    updated_at: new Date().toISOString()
                }).eq('user_id', currentUser.id); // Ensure user owns the layer

                // Use Supabase layer ID if available, otherwise fall back to local layer ID
                if (layerInfo.supabaseLayerId && layerInfo.supabaseLayerId !== null && layerInfo.supabaseLayerId !== 'null') {
                    query = query.eq('id', layerInfo.supabaseLayerId);
                } else {
                    query = query.eq('layer_id', layerId);
                }

                const { data, error } = await query;

                if (error) {
                    console.error('Error updating layer name in Supabase:', error);
                    return { success: false, error: `Database error: ${error.message}` };
                } else {
                    console.log('Layer name updated in Supabase successfully');
                    return { success: true };
                }
            } catch (error) {
                console.error('Network error updating layer name in Supabase:', error);
                return { success: false, error: `Network error: ${error.message}` };
            }
        }

        // Save symbology settings to Supabase
        async function saveSymbologyToSupabase(layerId, symbologyData) {
            if (!supabase || !currentUser) {
                console.log('Supabase not available or user not logged in, skipping symbology save');
                return;
            }

            try {
                const layerInfo = layers.get(layerId);
                if (!layerInfo) {
                    console.warn('Layer info not found for symbology save:', layerId);
                    return;
                }

                console.log(`Saving symbology to Supabase for layer: ${layerId}`, symbologyData);

                // For Aera.geojson, we need to handle it specially since it's a built-in layer
                if (layerId === 'aera-layer' || layerInfo.name === 'Aera') {
                    // Check if user already has an Aera layer record
                    const { data: existingAera, error: checkError } = await supabase
                        .from('layers')
                        .select('id, style')
                        .eq('user_id', currentUser.id)
                        .eq('name', 'Aera')
                        .single();

                    if (checkError && checkError.code !== 'PGRST116') { // PGRST116 is "not found"
                        console.error('Error checking for existing Aera layer:', checkError);
                        return;
                    }

                    if (existingAera) {
                        // Update existing Aera layer style
                        const { error: updateError } = await supabase
                            .from('layers')
                            .update({
                                style: symbologyData,
                                updated_at: new Date().toISOString()
                            })
                            .eq('id', existingAera.id);

                        if (updateError) {
                            console.error('Error updating Aera layer symbology:', updateError);
                        } else {
                            console.log('Aera layer symbology updated successfully');
                        }
                    } else {
                        // Create new Aera layer record for this user
                        const { error: insertError } = await supabase
                            .from('layers')
                            .insert({
                                layer_id: 'aera-' + currentUser.id,
                                name: 'Aera',
                                geojson_data: layerInfo.data,
                                style: symbologyData,
                                user_id: currentUser.id,
                                created_at: new Date().toISOString(),
                                updated_at: new Date().toISOString()
                            });

                        if (insertError) {
                            console.error('Error creating Aera layer record:', insertError);
                        } else {
                            console.log('Aera layer record created with symbology');
                            layerInfo.fromDatabase = true;
                            layerInfo.supabaseLayerId = 'aera-' + currentUser.id;
                        }
                    }
                } else {
                    // Handle regular user-uploaded layers
                    let query = supabase.from('layers').update({
                        style: symbologyData,
                        updated_at: new Date().toISOString()
                    }).eq('user_id', currentUser.id);

                    // Use Supabase layer ID if available, otherwise fall back to local layer ID
                    if (layerInfo.supabaseLayerId && layerInfo.supabaseLayerId !== null && layerInfo.supabaseLayerId !== 'null') {
                        query = query.eq('id', layerInfo.supabaseLayerId);
                    } else {
                        query = query.eq('layer_id', layerId);
                    }

                    const { error } = await query;

                    if (error) {
                        console.error('Error saving symbology to Supabase:', error);
                    } else {
                        console.log('Symbology saved to Supabase successfully');
                    }
                }
            } catch (error) {
                console.error('Network error saving symbology to Supabase:', error);
            }
        }

        // Apply stored symbology from Supabase data
        function applyStoredSymbology(layerId, symbologyData) {
            console.log('Applying stored symbology for layer:', layerId, symbologyData);
            
            if (!symbologyData) {
                console.log('No symbology data to apply');
                return;
            }

            const layerInfo = layers.get(layerId);
            if (!layerInfo) {
                console.warn('Layer info not found for symbology application:', layerId);
                return;
            }

            try {
                if (symbologyData.symbology_type === 'single') {
                    // Apply single symbol symbology
                    const style = {
                        color: symbologyData.stroke_color || '#ffffff',
                        fillColor: symbologyData.fill_color || '#14b8a6',
                        weight: symbologyData.stroke_weight || 2,
                        opacity: symbologyData.stroke_opacity || 1.0,
                        fillOpacity: symbologyData.fill_opacity || 0.7
                    };

                    layerInfo.layer.setStyle(style);
                    layerInfo.style = style;
                    
                    console.log('Single symbol symbology applied from stored data');
                } else if (symbologyData.symbology_type === 'categorical' && symbologyData.classification_field && symbologyData.categories) {
                    // Apply categorical symbology
                    const field = symbologyData.classification_field;
                    const strokeColor = symbologyData.stroke_color || '#ffffff';
                    const strokeWeight = symbologyData.stroke_weight || 2;
                    
                    // Create color map from stored categories
                    const colorMap = {};
                    symbologyData.categories.forEach(category => {
                        colorMap[category.value] = category.color;
                    });

                    layerInfo.layer.setStyle(function(feature) {
                        const value = feature.properties[field];
                        const fillColor = colorMap[value] || '#999999';
                        return {
                            color: strokeColor,
                            fillColor: fillColor,
                            weight: strokeWeight,
                            opacity: symbologyData.stroke_opacity || 1.0,
                            fillOpacity: symbologyData.fill_opacity || 0.7
                        };
                    });

                    // Store the classification info
                    layerInfo.classification = {
                        field: field,
                        colorMap: colorMap,
                        strokeColor: strokeColor,
                        strokeWidth: strokeWeight
                    };
                    
                    console.log('Categorical symbology applied from stored data');
                } else {
                    console.log('Unknown or incomplete symbology data, applying default style');
                    applyDefaultSymbology(layerId);
                }
                
                // Update legend after symbology has been applied
                updateLegend();
                
            } catch (error) {
                console.error('Error applying stored symbology:', error);
                applyDefaultSymbology(layerId);
            }
        }

        // Apply default symbology to a layer
        function applyDefaultSymbology(layerId) {
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;

            const defaultStyle = {
                color: '#ffffff',
                weight: 2,
                opacity: 1.0,
                fillColor: '#14b8a6',
                fillOpacity: 0.7
            };

            // Special default for Aera layer
            if (layerId === 'aera-layer' || layerInfo.name === 'Aera') {
                defaultStyle.fillColor = '#14b8a6'; // Teal
                defaultStyle.color = '#0d7377'; // Dark teal
                defaultStyle.weight = 1;
            }

            layerInfo.layer.setStyle(defaultStyle);
            layerInfo.style = defaultStyle;
            
            // Update legend after applying default symbology
            updateLegend();
        }

        // Update legend
        function updateLegend() {
            const legendContent = document.getElementById('legendContent');
            legendContent.innerHTML = '';

            // Use layerOrder to display legend items in the same order as the Layer Panel and map rendering
            layerOrder.forEach(layerId => {
                const layerInfo = layers.get(layerId);
                if (layerInfo && layerInfo.visible) {
                    const legendContainer = document.createElement('div');
                    legendContainer.className = 'legend-layer-container mb-3';
                    
                    // Layer name header
                    const layerHeader = document.createElement('div');
                    layerHeader.className = 'text-sm font-medium text-white mb-1';
                    layerHeader.textContent = layerInfo.name;
                    legendContainer.appendChild(layerHeader);
                    
                    // Check if layer has categorical classification
                    if (layerInfo.classification && layerInfo.classification.field && layerInfo.classification.colorMap) {
                        // Categorical symbology - show multiple color swatches with categories
                        const categoriesContainer = document.createElement('div');
                        categoriesContainer.className = 'legend-categories space-y-1';
                        
                        Object.entries(layerInfo.classification.colorMap).forEach(([value, fillColor]) => {
                            const categoryItem = document.createElement('div');
                            categoryItem.className = 'legend-item flex items-center space-x-2';
                            
                            // Get stroke color and width from classification or default
                            const strokeColor = layerInfo.classification.strokeColor || layerInfo.style?.color || '#ffffff';
                            const strokeWidth = layerInfo.classification.strokeWidth || layerInfo.style?.weight || 2;
                            
                            categoryItem.innerHTML = `
                                <div class="legend-color w-4 h-4 rounded border-2" 
                                     style="background-color: ${fillColor}; border-color: ${strokeColor}; border-width: ${Math.min(strokeWidth, 2)}px;"></div>
                                <span class="text-xs text-gray-300">${value}</span>
                            `;
                            
                            categoriesContainer.appendChild(categoryItem);
                        });
                        
                        legendContainer.appendChild(categoriesContainer);
                    } else {
                        // Single symbol - show one color swatch
                        const legendItem = document.createElement('div');
                        legendItem.className = 'legend-item flex items-center space-x-2';
                        
                        // Get fill and stroke colors from current layer style
                        const fillColor = layerInfo.style?.fillColor || '#14b8a6';
                        const strokeColor = layerInfo.style?.color || '#ffffff';
                        const strokeWidth = layerInfo.style?.weight || 2;
                        
                        // Special handling for Aera layer defaults
                        let displayFillColor = fillColor;
                        let displayStrokeColor = strokeColor;
                        if (layerId === 'aera-layer' || layerInfo.name === 'Aera') {
                            displayFillColor = fillColor !== '#14b8a6' ? fillColor : '#14b8a6'; // Teal
                            displayStrokeColor = strokeColor !== '#ffffff' ? strokeColor : '#0d7377'; // Dark teal
                        }
                        
                        legendItem.innerHTML = `
                            <div class="legend-color w-4 h-4 rounded border-2" 
                                 style="background-color: ${displayFillColor}; border-color: ${displayStrokeColor}; border-width: ${Math.min(strokeWidth, 2)}px;"></div>
                            <span class="text-xs text-gray-300">Single Symbol</span>
                        `;
                        
                        legendContainer.appendChild(legendItem);
                    }
                    
                    legendContent.appendChild(legendContainer);
                }
            });
        }

        // Setup filter listeners
        // === NEW COMPREHENSIVE FILTER SYSTEM ===
        
        // Filter state management
        let currentFilterState = {
            selectedLayer: null,
            selectedField: null,
            selectedOperator: null,
            filterValue: null,
            activeFilter: null
        };

        // Setup filter panel listeners
        function setupNewFilterListeners() {
            // Layer selection
            document.getElementById('filterLayerSelect').addEventListener('change', handleFilterLayerChange);
            
            // Field selection
            document.getElementById('filterFieldSelect').addEventListener('change', handleFilterFieldChange);
            
            // Operator selection
            document.getElementById('filterOperatorSelect').addEventListener('change', handleFilterOperatorChange);
            
            // Value controls
            document.getElementById('filterSingleValueSelect').addEventListener('change', handleFilterValueChange);
            document.getElementById('filterTextInput').addEventListener('input', handleFilterValueChange);
            
            // Action buttons
            document.getElementById('applyFilterBtn').addEventListener('click', applyNewFilter);
            document.getElementById('clearFilterBtn').addEventListener('click', clearNewFilter);
        }

        // Populate filter layer dropdown (Step 1)
        function populateFilterLayers() {
            console.log('Populating filter layers...');
            const layerSelect = document.getElementById('filterLayerSelect');
            layerSelect.innerHTML = '<option value="">Choose a layer to filter</option>';

            let layerCount = 0;
            layers.forEach((layerInfo, layerId) => {
                console.log(`Checking layer ${layerId}:`, {
                    visible: layerInfo.visible,
                    hasData: !!(layerInfo.data),
                    hasFeatures: !!(layerInfo.data && layerInfo.data.features),
                    featureCount: layerInfo.data && layerInfo.data.features ? layerInfo.data.features.length : 0
                });
                
                if (layerInfo.visible && layerInfo.data && layerInfo.data.features && layerInfo.data.features.length > 0) {
                    // Check if layer has attribute data
                    const firstFeature = layerInfo.data.features[0];
                    if (firstFeature.properties && Object.keys(firstFeature.properties).length > 0) {
                        const option = document.createElement('option');
                        option.value = layerId;
                        option.textContent = layerInfo.name;
                        layerSelect.appendChild(option);
                        layerCount++;
                        console.log(`Added layer to filter dropdown: ${layerInfo.name}`);
                    } else {
                        console.log(`Layer ${layerId} has no properties, skipping`);
                    }
                } else {
                    console.log(`Layer ${layerId} failed basic checks, skipping`);
                }
            });
            
            console.log(`Populated ${layerCount} layers in filter dropdown`);
        }

        // Handle layer selection change (Step 1 → Step 2)
        function handleFilterLayerChange() {
            const layerId = document.getElementById('filterLayerSelect').value;
            console.log(`Filter layer changed to: ${layerId}`);
            
            currentFilterState.selectedLayer = layerId;
            
            // Reset subsequent steps
            resetFilterSteps(['field', 'operator', 'value', 'actions']);
            
            if (layerId && layers.has(layerId)) {
                console.log(`Layer ${layerId} exists, populating fields...`);
                
                // Show field section first
                document.getElementById('filterFieldSection').style.display = 'block';
                
                // Then populate fields
                populateFilterFields(layerId);
            } else {
                console.log(`Layer ${layerId} does not exist or is invalid`);
                document.getElementById('filterFieldSection').style.display = 'none';
            }
        }

        // Populate field dropdown (Step 2)
        function populateFilterFields(layerId) {
            const fieldSelect = document.getElementById('filterFieldSelect');
            
            console.log(`Populating fields for layer: ${layerId}`);
            
            // Show loading state
            fieldSelect.innerHTML = '<option value="">Loading fields...</option>';

            const layerInfo = layers.get(layerId);
            console.log(`Layer info found:`, layerInfo);
            
            if (!layerInfo) {
                console.error(`Layer ${layerId} not found in layers map`);
                fieldSelect.innerHTML = '<option value="">Layer not found</option>';
                return;
            }

            if (!layerInfo.data) {
                console.error(`Layer ${layerId} has no data`);
                fieldSelect.innerHTML = '<option value="">No layer data available</option>';
                return;
            }

            if (!layerInfo.data.features || layerInfo.data.features.length === 0) {
                console.error(`Layer ${layerId} has no features`);
                fieldSelect.innerHTML = '<option value="">No features in layer</option>';
                return;
            }

            // Get the first feature to examine its properties
            const firstFeature = layerInfo.data.features[0];
            console.log(`First feature:`, firstFeature);
            
            if (!firstFeature.properties) {
                console.error(`First feature has no properties`);
                fieldSelect.innerHTML = '<option value="">No attributes found</option>';
                return;
            }

            const properties = firstFeature.properties;
            const fieldNames = Object.keys(properties);
            console.log(`Available fields:`, fieldNames);

            // Clear loading state and add default option
            fieldSelect.innerHTML = '<option value="">Choose a field to filter by</option>';

            if (fieldNames.length === 0) {
                fieldSelect.innerHTML = '<option value="">No fields available</option>';
                return;
            }

            // Filter out common system/geometry fields that aren't useful for filtering
            const systemFields = ['OBJECTID', 'objectid', 'FID', 'fid', 'Shape__Area', 'Shape__Length', 'Shape_Area', 'Shape_Length'];
            const filteredFields = fieldNames.filter(field => !systemFields.includes(field));
            
            // Sort fields alphabetically for better UX and categorize by data type
            const fieldsToShow = filteredFields.length > 0 ? filteredFields : fieldNames;
            
            // Analyze field types from sample values
            const fieldInfo = [];
            fieldsToShow.forEach(fieldName => {
                const sampleValue = properties[fieldName];
                let dataType = 'text';
                
                if (typeof sampleValue === 'number') {
                    dataType = 'number';
                } else if (typeof sampleValue === 'boolean') {
                    dataType = 'boolean';
                } else if (sampleValue && !isNaN(Date.parse(sampleValue))) {
                    dataType = 'date';
                }
                
                fieldInfo.push({
                    name: fieldName,
                    type: dataType,
                    sample: sampleValue
                });
            });
            
            // Sort by name
            fieldInfo.sort((a, b) => a.name.localeCompare(b.name));
            
            // Add fields to dropdown
            fieldInfo.forEach(field => {
                const option = document.createElement('option');
                option.value = field.name;
                // Show field name with a hint about data type
                option.textContent = `${field.name} (${field.type})`;
                fieldSelect.appendChild(option);
            });

            console.log(`Populated ${fieldsToShow.length} fields into dropdown`);
        }

        // Handle field selection change (Step 2 → Step 3)
        function handleFilterFieldChange() {
            const fieldName = document.getElementById('filterFieldSelect').value;
            currentFilterState.selectedField = fieldName;
            
            // Reset subsequent steps
            resetFilterSteps(['operator', 'value', 'actions']);
            
            if (fieldName) {
                document.getElementById('filterOperatorSection').style.display = 'block';
            } else {
                document.getElementById('filterOperatorSection').style.display = 'none';
            }
        }

        // Handle operator selection change (Step 3 → Step 4)
        function handleFilterOperatorChange() {
            const operator = document.getElementById('filterOperatorSelect').value;
            currentFilterState.selectedOperator = operator;
            
            // Reset value step
            resetFilterSteps(['value', 'actions']);
            
            if (operator) {
                setupFilterValueInput(operator);
                document.getElementById('filterActionsSection').style.display = 'block';
            } else {
                document.getElementById('filterValueSection').style.display = 'none';
                document.getElementById('filterActionsSection').style.display = 'none';
            }
        }

        // Setup appropriate input control based on operator (Step 4)
        function setupFilterValueInput(operator) {
            const valueSection = document.getElementById('filterValueSection');
            const singleSelect = document.getElementById('filterSingleValueSelect');
            const multiContainer = document.getElementById('filterMultiValueContainer');
            const textInput = document.getElementById('filterTextInput');
            
            // Hide all inputs first
            singleSelect.style.display = 'none';
            multiContainer.style.display = 'none';
            textInput.style.display = 'none';
            
            // Logic-only operators don't need value input
            if (['is_empty', 'is_not_empty', 'is_null', 'is_not_null'].includes(operator)) {
                valueSection.style.display = 'none';
                return;
            }
            
            valueSection.style.display = 'block';
            
            // Determine input type based on operator
            if (['equal', 'not_equal'].includes(operator)) {
                // Single value dropdown
                singleSelect.style.display = 'block';
                populateFilterValues('single');
            } else if (['include', 'does_not_include'].includes(operator)) {
                // Multi-value checkboxes
                multiContainer.style.display = 'block';
                populateFilterValues('multi');
            } else {
                // Text input for contains, starts_with, etc.
                textInput.style.display = 'block';
                textInput.value = '';
            }
        }

        // Populate filter values from field data
        function populateFilterValues(type) {
            const layerId = currentFilterState.selectedLayer;
            const fieldName = currentFilterState.selectedField;
            
            if (!layerId || !fieldName) return;
            
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;
            
            // Get unique values from the field
            const uniqueValues = new Set();
            layerInfo.data.features.forEach(feature => {
                const value = feature.properties[fieldName];
                if (value !== null && value !== undefined && value !== '') {
                    uniqueValues.add(value.toString());
                }
            });
            
            const sortedValues = Array.from(uniqueValues).sort();
            
            if (type === 'single') {
                // Populate single select dropdown
                const singleSelect = document.getElementById('filterSingleValueSelect');
                singleSelect.innerHTML = '<option value="">Choose a value</option>';
                
                sortedValues.forEach(value => {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = value;
                    singleSelect.appendChild(option);
                });
            } else if (type === 'multi') {
                // Populate multi-select checkboxes
                const multiList = document.getElementById('filterMultiValueList');
                multiList.innerHTML = '';
                
                sortedValues.forEach(value => {
                    const label = document.createElement('label');
                    label.className = 'flex items-center space-x-2 text-sm text-gray-300 cursor-pointer mb-2';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = value;
                    checkbox.className = 'rounded border-gray-600 bg-gray-700 text-blue-500 focus:ring-blue-500';
                    checkbox.addEventListener('change', handleFilterValueChange);
                    
                    const span = document.createElement('span');
                    span.textContent = value;
                    
                    label.appendChild(checkbox);
                    label.appendChild(span);
                    multiList.appendChild(label);
                });
            }
        }

        // Handle filter value change
        function handleFilterValueChange() {
            const operator = currentFilterState.selectedOperator;
            let value = null;
            
            if (['equal', 'not_equal'].includes(operator)) {
                value = document.getElementById('filterSingleValueSelect').value;
            } else if (['include', 'does_not_include'].includes(operator)) {
                const checkboxes = document.querySelectorAll('#filterMultiValueList input[type="checkbox"]:checked');
                value = Array.from(checkboxes).map(cb => cb.value);
            } else if (['contains', 'does_not_contain', 'starts_with', 'does_not_start_with'].includes(operator)) {
                value = document.getElementById('filterTextInput').value.trim();
            }
            
            currentFilterState.filterValue = value;
        }

        // Apply the new filter
        function applyNewFilter() {
            const { selectedLayer, selectedField, selectedOperator, filterValue } = currentFilterState;
            
            if (!selectedLayer || !selectedField || !selectedOperator) {
                alert('Please complete all filter steps before applying.');
                return;
            }
            
            // Validate value for operators that require it
            const operatorsNeedingValue = ['equal', 'not_equal', 'include', 'does_not_include', 'contains', 'does_not_contain', 'starts_with', 'does_not_start_with'];
            if (operatorsNeedingValue.includes(selectedOperator)) {
                if (!filterValue || (Array.isArray(filterValue) && filterValue.length === 0)) {
                    alert('Please select or enter a filter value.');
                    return;
                }
            }
            
            const layerInfo = layers.get(selectedLayer);
            if (!layerInfo) return;
            
            // Apply filter logic
            const filteredFeatures = layerInfo.originalData.features.filter(feature => {
                return evaluateFilterCondition(feature, selectedField, selectedOperator, filterValue);
            });
            
            if (filteredFeatures.length === 0) {
                alert('No features match the filter criteria.');
                return;
            }
            
            // Create filtered GeoJSON
            const filteredData = {
                type: 'FeatureCollection',
                features: filteredFeatures
            };
            
            // Remove existing layer and add filtered layer
            map.removeLayer(layerInfo.layer);
            
            const filteredLayer = L.geoJSON(filteredData, {
                style: layerInfo.style,
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="modern-popup-container">';
                        popupContent += '<div class="modern-popup-header"><i class="fas fa-info-circle mr-2"></i>Feature Properties</div>';
                        popupContent += '<div class="modern-popup-body">';
                        
                        for (let key in feature.properties) {
                            popupContent += `<div class="property-row">`;
                            popupContent += `<div class="property-key">${key}</div>`;
                            popupContent += `<div class="property-value">${feature.properties[key] || 'N/A'}</div>`;
                            popupContent += `</div>`;
                        }
                        
                        popupContent += '</div></div>';
                        
                        layer.bindPopup(popupContent, {
                            className: 'modern-feature-popup',
                            maxWidth: 350,
                            maxHeight: 400
                        });
                    }
                }
            }).addTo(map);
            
            // Update layer info
            layerInfo.layer = filteredLayer;
            layerInfo.data = filteredData;
            
            // Store active filter
            currentFilterState.activeFilter = {
                layerId: selectedLayer,
                layerName: layerInfo.name,
                field: selectedField,
                operator: selectedOperator,
                value: filterValue
            };
            
            // Show filter status
            showFilterStatus();
            
            // Zoom to filtered features
            if (filteredLayer.getBounds().isValid()) {
                map.fitBounds(filteredLayer.getBounds());
            }
            
            console.log(`Filter applied: ${filteredFeatures.length} features match criteria`);
        }

        // Evaluate filter condition for a feature
        function evaluateFilterCondition(feature, field, operator, value) {
            const fieldValue = feature.properties[field];
            const fieldStr = fieldValue ? fieldValue.toString().toLowerCase() : '';
            
            switch (operator) {
                case 'equal':
                    return fieldValue?.toString() === value;
                case 'not_equal':
                    return fieldValue?.toString() !== value;
                case 'include':
                    return Array.isArray(value) && value.some(v => fieldValue?.toString() === v);
                case 'does_not_include':
                    return Array.isArray(value) && !value.some(v => fieldValue?.toString() === v);
                case 'contains':
                    return fieldStr.includes(value.toLowerCase());
                case 'does_not_contain':
                    return !fieldStr.includes(value.toLowerCase());
                case 'starts_with':
                    return fieldStr.startsWith(value.toLowerCase());
                case 'does_not_start_with':
                    return !fieldStr.startsWith(value.toLowerCase());
                case 'is_empty':
                    return !fieldValue || fieldValue.toString().trim() === '';
                case 'is_not_empty':
                    return fieldValue && fieldValue.toString().trim() !== '';
                case 'is_null':
                    return fieldValue === null || fieldValue === undefined;
                case 'is_not_null':
                    return fieldValue !== null && fieldValue !== undefined;
                default:
                    return true;
            }
        }

        // Show filter status
        function showFilterStatus() {
            const statusSection = document.getElementById('filterStatusSection');
            const statusText = document.getElementById('filterStatusText');
            
            if (currentFilterState.activeFilter) {
                const { layerName, field, operator, value } = currentFilterState.activeFilter;
                let description = `Layer: ${layerName} | Field: ${field} | ${getOperatorText(operator)}`;
                
                if (Array.isArray(value)) {
                    description += ` | Values: ${value.join(', ')}`;
                } else if (value) {
                    description += ` | Value: ${value}`;
                }
                
                statusText.textContent = description;
                statusSection.style.display = 'block';
            } else {
                statusSection.style.display = 'none';
            }
        }

        // Get human-readable operator text
        function getOperatorText(operator) {
            const operatorMap = {
                'equal': 'Equal to',
                'not_equal': 'Not equal to',
                'include': 'Include any of',
                'does_not_include': 'Does not include any of',
                'contains': 'Contains',
                'does_not_contain': 'Does not contain',
                'starts_with': 'Starts with',
                'does_not_start_with': 'Does not start with',
                'is_empty': 'Is empty',
                'is_not_empty': 'Is not empty',
                'is_null': 'Is null',
                'is_not_null': 'Is not null'
            };
            return operatorMap[operator] || operator;
        }

        // Clear the current filter
        function clearNewFilter() {
            if (!currentFilterState.activeFilter) {
                alert('No active filter to clear.');
                return;
            }
            
            const layerId = currentFilterState.activeFilter.layerId;
            const layerInfo = layers.get(layerId);
            
            if (!layerInfo) return;
            
            // Remove current layer
            map.removeLayer(layerInfo.layer);
            
            // Restore original data
            const originalLayer = L.geoJSON(layerInfo.originalData, {
                style: layerInfo.style,
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="modern-popup-container">';
                        popupContent += '<div class="modern-popup-header"><i class="fas fa-info-circle mr-2"></i>Feature Properties</div>';
                        popupContent += '<div class="modern-popup-body">';
                        
                        for (let key in feature.properties) {
                            popupContent += `<div class="property-row">`;
                            popupContent += `<div class="property-key">${key}</div>`;
                            popupContent += `<div class="property-value">${feature.properties[key] || 'N/A'}</div>`;
                            popupContent += `</div>`;
                        }
                        
                        popupContent += '</div></div>';
                        
                        layer.bindPopup(popupContent, {
                            className: 'modern-feature-popup',
                            maxWidth: 350,
                            maxHeight: 400
                        });
                    }
                }
            }).addTo(map);
            
            // Update layer info
            layerInfo.layer = originalLayer;
            layerInfo.data = layerInfo.originalData;
            
            // Clear filter state
            currentFilterState.activeFilter = null;
            
            // Reset UI
            resetFilterSteps(['layer', 'field', 'operator', 'value', 'actions', 'status']);
            
            // Zoom to full layer
            if (originalLayer.getBounds().isValid()) {
                map.fitBounds(originalLayer.getBounds());
            }
            
            console.log('Filter cleared, original layer restored');
        }

        // Reset filter steps UI
        function resetFilterSteps(steps) {
            if (steps.includes('layer')) {
                document.getElementById('filterLayerSelect').selectedIndex = 0;
                currentFilterState.selectedLayer = null;
            }
            if (steps.includes('field')) {
                document.getElementById('filterFieldSelect').innerHTML = '<option value="">Choose a field to filter by</option>';
                document.getElementById('filterFieldSection').style.display = 'none';
                currentFilterState.selectedField = null;
            }
            if (steps.includes('operator')) {
                document.getElementById('filterOperatorSelect').selectedIndex = 0;
                document.getElementById('filterOperatorSection').style.display = 'none';
                currentFilterState.selectedOperator = null;
            }
            if (steps.includes('value')) {
                document.getElementById('filterValueSection').style.display = 'none';
                document.getElementById('filterSingleValueSelect').innerHTML = '<option value="">Loading values...</option>';
                document.getElementById('filterMultiValueList').innerHTML = '';
                document.getElementById('filterTextInput').value = '';
                currentFilterState.filterValue = null;
            }
            if (steps.includes('actions')) {
                document.getElementById('filterActionsSection').style.display = 'none';
            }
            if (steps.includes('status')) {
                document.getElementById('filterStatusSection').style.display = 'none';
            }
        }

        // === END NEW FILTER SYSTEM ===

        // Legacy filter functions (keeping for compatibility but they won't be used)
        function setupFilterListeners() {
            document.getElementById('filterLayer').addEventListener('change', populateFilterFields);
            document.getElementById('applyFilter').addEventListener('click', applyFilter);
            document.getElementById('clearFilter').addEventListener('click', clearFilter);
        }

        // Populate filter modal
        function populateFilterModal() {
            const layerSelect = document.getElementById('filterLayer');
            layerSelect.innerHTML = '<option value="">Select a layer</option>';

            layers.forEach((layerInfo, layerId) => {
                if (layerInfo.visible) {
                    const option = document.createElement('option');
                    option.value = layerId;
                    option.textContent = layerInfo.name;
                    layerSelect.appendChild(option);
                }
            });
        }

        // Populate filter fields
        function populateFilterFields() {
            const layerId = document.getElementById('filterLayer').value;
            const fieldSelect = document.getElementById('filterField');
            fieldSelect.innerHTML = '<option value="">Select a field</option>';

            if (layerId && layers.has(layerId)) {
                const layerInfo = layers.get(layerId);
                const features = layerInfo.data.features;

                if (features && features.length > 0) {
                    const properties = features[0].properties || {};
                    Object.keys(properties).forEach(key => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = key;
                        fieldSelect.appendChild(option);
                    });
                }
            }
        }

        // Apply filter
        function applyFilter() {
            const layerId = document.getElementById('filterLayer').value;
            const field = document.getElementById('filterField').value;
            const value = document.getElementById('filterValue').value.trim();

            if (!layerId || !field || !value) {
                alert('Please fill in all filter criteria.');
                return;
            }

            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;

            // Filter features
            const filteredFeatures = layerInfo.originalData.features.filter(feature => {
                const propValue = feature.properties[field];
                return propValue && propValue.toString().toLowerCase().includes(value.toLowerCase());
            });

            if (filteredFeatures.length === 0) {
                alert('No features match the filter criteria.');
                return;
            }

            // Create filtered GeoJSON
            const filteredData = {
                type: 'FeatureCollection',
                features: filteredFeatures
            };

            // Remove existing layer and add filtered layer
            map.removeLayer(layerInfo.layer);
            
            const filteredLayer = L.geoJSON(filteredData, {
                style: layerInfo.style,
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="text-sm">';
                        for (let key in feature.properties) {
                            popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                        popupContent += '</div>';
                        
                        // Use right-click popup binding (respects selection mode)
                        safeBindPopup(layer, popupContent);
                    }
                }
            }).addTo(map);

            // Update layer info
            layerInfo.layer = filteredLayer;
            layerInfo.data = filteredData;

            // Store filter info
            activeFilters.set(layerId, { field, value });

            // Zoom to filtered features
            map.fitBounds(filteredLayer.getBounds());

            // Close modal
            document.getElementById('filterModal').classList.add('hidden');
        }

        // Clear filter
        function clearFilter() {
            const layerId = document.getElementById('filterLayer').value;
            
            if (!layerId || !layers.has(layerId)) return;

            const layerInfo = layers.get(layerId);
            
            // Remove current layer
            map.removeLayer(layerInfo.layer);
            
            // Restore original data
            const originalLayer = L.geoJSON(layerInfo.originalData, {
                style: layerInfo.style,
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="text-sm">';
                        for (let key in feature.properties) {
                            popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                        popupContent += '</div>';
                        
                        // Use right-click popup binding (respects selection mode)
                        safeBindPopup(layer, popupContent);
                    }
                }
            }).addTo(map);

            // Update layer info
            layerInfo.layer = originalLayer;
            layerInfo.data = layerInfo.originalData;

            // Remove filter info
            activeFilters.delete(layerId);

            // Zoom to full layer
            map.fitBounds(originalLayer.getBounds());

            // Close modal
            document.getElementById('filterModal').classList.add('hidden');
        }

        // Setup print listeners
        function setupPrintListeners() {
            document.getElementById('cancelPrint').addEventListener('click', () => {
                document.getElementById('printModal').classList.add('hidden');
            });

            document.getElementById('exportMap').addEventListener('click', exportMap);
        }

        // Export map
        function exportMap() {
            const title = document.getElementById('mapTitle').value;
            const pageSize = document.getElementById('pageSize').value;
            const orientation = document.getElementById('orientation').value;
            const includeLegend = document.getElementById('includeLegend').checked;

            // Get dimensions
            const [width, height] = pageSize.split('x').map(Number);
            const finalWidth = orientation === 'portrait' ? Math.min(width, height) : Math.max(width, height);
            const finalHeight = orientation === 'portrait' ? Math.max(width, height) : Math.min(width, height);

            // Create a temporary container for export
            const exportContainer = document.createElement('div');
            exportContainer.style.width = finalWidth + 'px';
            exportContainer.style.height = finalHeight + 'px';
            exportContainer.style.position = 'absolute';
            exportContainer.style.top = '-9999px';
            exportContainer.style.background = '#1f2937';
            document.body.appendChild(exportContainer);

            // Create export map
            const exportMap = L.map(exportContainer, {
                center: map.getCenter(),
                zoom: map.getZoom(),
                zoomControl: false,
                attributionControl: false
            });

            // Add base layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(exportMap);

            // Add visible layers
            layers.forEach(layerInfo => {
                if (layerInfo.visible) {
                    L.geoJSON(layerInfo.data, {
                        style: layerInfo.style
                    }).addTo(exportMap);
                }
            });

            // Wait for tiles to load then capture
            setTimeout(() => {
                html2canvas(exportContainer, {
                    width: finalWidth,
                    height: finalHeight,
                    useCORS: true,
                    allowTaint: true
                }).then(canvas => {
                    // Create download link
                    const link = document.createElement('a');
                    link.download = `${title.replace(/[^a-z0-9]/gi, '_')}.png`;
                    link.href = canvas.toDataURL();
                    link.click();

                    // Cleanup
                    exportMap.remove();
                    document.body.removeChild(exportContainer);
                    document.getElementById('printModal').classList.add('hidden');
                }).catch(error => {
                    console.error('Export failed:', error);
                    alert('Export failed. Please try again.');
                    
                    // Cleanup
                    exportMap.remove();
                    document.body.removeChild(exportContainer);
                });
            }, 2000);
        }

        // Setup symbology listeners (kept for compatibility but not used)
        function setupSymbologyListeners() {
            // Old modal listeners - kept for backward compatibility but not used
            // The new symbology editor handles its own listeners
            return;
        }

        // Open symbology editor panel
        function openSymbologyEditor(layerId) {
            console.log('Opening symbology editor for layer:', layerId);
            const layerInfo = layers.get(layerId);
            if (!layerInfo) {
                console.error('Layer not found:', layerId);
                return;
            }

            console.log('Layer info:', layerInfo);

            // Create symbology editor panel
            const editorPanel = document.createElement('div');
            editorPanel.id = 'symbologyEditor';
            editorPanel.className = 'symbology-editor-draggable';
            editorPanel.style.top = '100px';
            editorPanel.style.right = '20px';
            
            // Get current layer opacity (stored as a value between 0 and 1)
            const currentOpacity = layerInfo.opacity || 1.0;
            const opacityPercent = Math.round(currentOpacity * 100);
            
            editorPanel.innerHTML = `
                <div class="symbology-editor-header" id="symbologyEditorHeader">
                    <div class="flex items-center justify-between">
                        <h3 class="text-lg font-semibold text-white flex items-center">
                            <i class="fas fa-palette mr-2 text-teal-400"></i>
                            Symbology Editor
                        </h3>
                        <button id="closeSymbologyEditor" class="text-gray-400 hover:text-white transition-colors">
                            <i class="fas fa-times text-lg"></i>
                        </button>
                    </div>
                    <div class="text-sm text-gray-300 mt-1">Layer: ${layerInfo.name}</div>
                </div>
                
                <div class="symbology-editor-content">
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Symbology Type</label>
                        <select id="symbologyType" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent">
                            <option value="single">Single Symbol</option>
                            <option value="categorical">Categorical</option>
                        </select>
                    </div>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Layer Opacity</label>
                        <input type="range" id="opacitySlider" class="opacity-slider" 
                               min="0" max="100" value="${opacityPercent}" step="1">
                        <div class="opacity-value" id="opacityValue">${opacityPercent}%</div>
                    </div>
                    
                    <div id="singleSymbolOptions" class="border-t border-gray-600 pt-4 mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Fill Color</label>
                        <div class="flex items-center space-x-3 mb-4">
                            <input type="color" id="singleFillColor" value="#14b8a6" 
                                   class="w-16 h-10 bg-transparent border border-gray-600 rounded cursor-pointer">
                            <span class="text-sm text-gray-400">Choose color for all features</span>
                        </div>
                        
                        <label class="block text-sm font-medium text-gray-300 mb-2">Stroke Color</label>
                        <div class="flex items-center space-x-3 mb-4">
                            <input type="color" id="singleStrokeColor" value="#ffffff" 
                                   class="w-16 h-10 bg-transparent border border-gray-600 rounded cursor-pointer">
                            <span class="text-sm text-gray-400">Choose stroke color for all features</span>
                        </div>
                        
                        <label class="block text-sm font-medium text-gray-300 mb-2">Stroke Width (px)</label>
                        <div class="flex items-center space-x-3">
                            <input type="number" id="singleStrokeWidth" value="2" min="0" max="100" step="0.5" 
                                   class="w-20 px-2 py-1 bg-gray-700 border border-gray-600 rounded text-white text-sm">
                            <span class="text-sm text-gray-400">Stroke width in pixels</span>
                        </div>
                    </div>
                    
                    <div id="categoricalOptions" class="border-t border-gray-600 pt-4 mb-4 hidden">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Classification Field</label>
                        <select id="classificationField" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent mb-4">
                            <option value="">Select a field...</option>
                        </select>
                        
                        <label class="block text-sm font-medium text-gray-300 mb-2">Stroke Color</label>
                        <div class="flex items-center space-x-3 mb-4">
                            <input type="color" id="categoricalStrokeColor" value="#ffffff" 
                                   class="w-16 h-10 bg-transparent border border-gray-600 rounded cursor-pointer">
                            <span class="text-sm text-gray-400">Stroke color for all categories</span>
                        </div>
                        
                        <label class="block text-sm font-medium text-gray-300 mb-2">Stroke Width (px)</label>
                        <div class="flex items-center space-x-3">
                            <input type="number" id="categoricalStrokeWidth" value="2" min="0" max="100" step="0.5" 
                                   class="w-20 px-2 py-1 bg-gray-700 border border-gray-600 rounded text-white text-sm">
                            <span class="text-sm text-gray-400">Stroke width in pixels</span>
                        </div>
                    </div>
                    
                    <div id="legendPreview" class="mb-4 hidden">
                        <h4 class="text-sm font-medium text-gray-300 mb-2">Live Legend</h4>
                        <div id="legendItems" class="space-y-2 max-h-48 overflow-y-auto"></div>
                    </div>
                    
                    <div class="flex space-x-2 mt-4">
                        <button id="applySymbology" class="flex-1 bg-teal-600 hover:bg-teal-700 text-white px-4 py-2 rounded-lg transition-colors">
                            Apply
                        </button>
                        <button id="resetSymbology" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg transition-colors">
                            Reset
                        </button>
                    </div>
                </div>
            `;

            // Remove any existing symbology editor
            const existingEditor = document.getElementById('symbologyEditor');
            if (existingEditor) {
                console.log('Removing existing editor');
                existingEditor.remove();
            }

            console.log('Appending new editor panel to body');
            document.body.appendChild(editorPanel);
            
            // Make the panel draggable
            makeDraggable(editorPanel);
            
            // Close panel when clicking outside
            setupOutsideClickClose(editorPanel);

            // Populate field dropdown
            const fieldSelect = editorPanel.querySelector('#classificationField');
            const features = layerInfo.data.features;
            if (features && features.length > 0) {
                const properties = features[0].properties || {};
                Object.keys(properties).forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = key;
                    fieldSelect.appendChild(option);
                });
            }
            
            // Set initial single symbol color from current layer style
            const singleFillColorInput = editorPanel.querySelector('#singleFillColor');
            if (singleFillColorInput && layerInfo.style && layerInfo.style.fillColor) {
                singleFillColorInput.value = layerInfo.style.fillColor;
            }
            
            // Set initial stroke color from current layer style
            const singleStrokeColorInput = editorPanel.querySelector('#singleStrokeColor');
            if (singleStrokeColorInput && layerInfo.style && layerInfo.style.color) {
                singleStrokeColorInput.value = layerInfo.style.color;
            }
            
            // Set initial stroke width from current layer style
            const singleStrokeWidthInput = editorPanel.querySelector('#singleStrokeWidth');
            if (singleStrokeWidthInput && layerInfo.style && layerInfo.style.weight) {
                singleStrokeWidthInput.value = layerInfo.style.weight;
            }
            
            // Set initial categorical stroke values
            const categoricalStrokeColorInput = editorPanel.querySelector('#categoricalStrokeColor');
            if (categoricalStrokeColorInput && layerInfo.style && layerInfo.style.color) {
                categoricalStrokeColorInput.value = layerInfo.style.color;
            }
            
            const categoricalStrokeWidthInput = editorPanel.querySelector('#categoricalStrokeWidth');
            if (categoricalStrokeWidthInput && layerInfo.style && layerInfo.style.weight) {
                categoricalStrokeWidthInput.value = layerInfo.style.weight;
            }
            
            // Set initial categorical field selection if there's existing classification
            if (layerInfo.classification && layerInfo.classification.field) {
                const fieldSelect = editorPanel.querySelector('#classificationField');
                if (fieldSelect) {
                    fieldSelect.value = layerInfo.classification.field;
                    console.log('Restored categorical field selection:', layerInfo.classification.field);
                }
                
                // Set symbology type to categorical if we have classification
                const symbologyTypeSelect = editorPanel.querySelector('#symbologyType');
                if (symbologyTypeSelect) {
                    symbologyTypeSelect.value = 'categorical';
                    
                    // Show categorical options and hide single symbol options
                    const singleSymbolOptions = editorPanel.querySelector('#singleSymbolOptions');
                    const categoricalOptions = editorPanel.querySelector('#categoricalOptions');
                    if (singleSymbolOptions && categoricalOptions) {
                        singleSymbolOptions.classList.add('hidden');
                        categoricalOptions.classList.remove('hidden');
                    }
                }
            }

            // Store current layer for the editor
            editorPanel.dataset.layerId = layerId;

            // Setup event listeners
            setupSymbologyEditorListeners(editorPanel);
        }

        // Setup symbology editor event listeners
        function setupSymbologyEditorListeners(editorPanel) {
            const layerId = editorPanel.dataset.layerId;
            const layerInfo = layers.get(layerId);
            
            // Get UI elements
            const symbologyTypeSelect = editorPanel.querySelector('#symbologyType');
            const singleSymbolOptions = editorPanel.querySelector('#singleSymbolOptions');
            const categoricalOptions = editorPanel.querySelector('#categoricalOptions');
            const singleFillColor = editorPanel.querySelector('#singleFillColor');
            const classificationField = editorPanel.querySelector('#classificationField');
            const legendPreview = editorPanel.querySelector('#legendPreview');
            const applyBtn = editorPanel.querySelector('#applySymbology');
            
            // Opacity slider handling
            const opacitySlider = editorPanel.querySelector('#opacitySlider');
            const opacityValue = editorPanel.querySelector('#opacityValue');
            
            if (opacitySlider && opacityValue) {
                opacitySlider.addEventListener('input', function() {
                    const opacityPercent = parseInt(this.value);
                    const opacityDecimal = opacityPercent / 100;
                    
                    // Update display
                    opacityValue.textContent = opacityPercent + '%';
                    
                    // Update layer opacity immediately
                    updateLayerOpacity(layerId, opacityDecimal);
                });
            }
            
            // Symbology type change handler
            symbologyTypeSelect.addEventListener('change', function() {
                const selectedType = this.value;
                
                if (selectedType === 'single') {
                    // Show single symbol options, hide categorical options
                    singleSymbolOptions.classList.remove('hidden');
                    categoricalOptions.classList.add('hidden');
                    legendPreview.classList.add('hidden');
                } else if (selectedType === 'categorical') {
                    // Show categorical options, hide single symbol options
                    singleSymbolOptions.classList.add('hidden');
                    categoricalOptions.classList.remove('hidden');
                    
                    // Enable Apply button for categorical (field selection will handle further logic)
                    applyBtn.disabled = false;
                }
            });
            
            // Single fill color change handler
            singleFillColor.addEventListener('input', function() {
                const selectedColor = this.value;
                console.log(`Single symbol color changed to: ${selectedColor}`);
                
                // Apply single symbol with current stroke settings
                const strokeColor = editorPanel.querySelector('#singleStrokeColor').value;
                const strokeWidth = editorPanel.querySelector('#singleStrokeWidth').value;
                applySingleSymbolWithStroke(layerId, selectedColor, strokeColor, strokeWidth);
            });
            
            // Single stroke color change handler
            const singleStrokeColor = editorPanel.querySelector('#singleStrokeColor');
            singleStrokeColor.addEventListener('input', function() {
                const strokeColor = this.value;
                console.log(`Single symbol stroke color changed to: ${strokeColor}`);
                
                // Apply single symbol with current fill and stroke settings
                const fillColor = singleFillColor.value;
                const strokeWidth = editorPanel.querySelector('#singleStrokeWidth').value;
                applySingleSymbolWithStroke(layerId, fillColor, strokeColor, strokeWidth);
            });
            
            // Single stroke width change handler
            const singleStrokeWidth = editorPanel.querySelector('#singleStrokeWidth');
            singleStrokeWidth.addEventListener('input', function() {
                const strokeWidth = this.value;
                console.log(`Single symbol stroke width changed to: ${strokeWidth}px`);
                
                // Apply single symbol with current fill and stroke settings
                const fillColor = singleFillColor.value;
                const strokeColor = singleStrokeColor.value;
                applySingleSymbolWithStroke(layerId, fillColor, strokeColor, strokeWidth);
            });
            
            // Categorical stroke color change handler
            const categoricalStrokeColor = editorPanel.querySelector('#categoricalStrokeColor');
            categoricalStrokeColor.addEventListener('input', function() {
                const field = classificationField.value;
                if (field) {
                    console.log(`Categorical stroke color changed to: ${this.value}`);
                    applyCategoricalSymbologyWithStroke(layerId, field);
                }
            });
            
            // Categorical stroke width change handler
            const categoricalStrokeWidth = editorPanel.querySelector('#categoricalStrokeWidth');
            categoricalStrokeWidth.addEventListener('input', function() {
                const field = classificationField.value;
                if (field) {
                    console.log(`Categorical stroke width changed to: ${this.value}px`);
                    applyCategoricalSymbologyWithStroke(layerId, field);
                }
            });
            
            // Close button
            editorPanel.querySelector('#closeSymbologyEditor').addEventListener('click', () => {
                editorPanel.remove();
            });

            // Field selection change for categorical symbology
            classificationField.addEventListener('change', function() {
                const field = this.value;
                
                if (field) {
                    console.log(`Classification field selected: ${field}`);
                    generateLegendPreview(layerId, field, editorPanel);
                    legendPreview.classList.remove('hidden');
                    
                    // Apply categorical symbology - check if we have existing colors
                    const layerInfo = layers.get(layerId);
                    if (layerInfo.classification && layerInfo.classification.field === field && layerInfo.classification.colorMap) {
                        // Use existing custom colors
                        console.log('Using existing custom colors for field:', field);
                        applyCategoricalSymbologyWithCustomColors(layerId, field, layerInfo.classification.colorMap);
                    } else {
                        // Apply with auto-generated colors
                        console.log('Applying with auto-generated colors for field:', field);
                        applyCategoricalSymbologyWithStroke(layerId, field);
                    }
                } else {
                    legendPreview.classList.add('hidden');
                }
            });
            
            // Apply button
            applyBtn.addEventListener('click', function() {
                const symbologyType = symbologyTypeSelect.value;
                
                if (symbologyType === 'single') {
                    const fillColor = singleFillColor.value;
                    const strokeColor = editorPanel.querySelector('#singleStrokeColor').value;
                    const strokeWidth = editorPanel.querySelector('#singleStrokeWidth').value;
                    applySingleSymbolWithStroke(layerId, fillColor, strokeColor, strokeWidth);
                } else if (symbologyType === 'categorical') {
                    const field = classificationField.value;
                    if (field) {
                        // Check if we have existing custom colors or need to collect from color pickers
                        const layerInfo = layers.get(layerId);
                        let customColorMap = null;
                        
                        // Try to get colors from the legend preview color pickers
                        const colorPickers = editorPanel.querySelectorAll('#legendItems .color-picker');
                        if (colorPickers.length > 0) {
                            customColorMap = {};
                            colorPickers.forEach(picker => {
                                const value = picker.dataset.value;
                                const color = picker.value;
                                customColorMap[value] = color;
                            });
                            console.log('Collected custom colors from color pickers:', customColorMap);
                            applyCategoricalSymbologyWithCustomColors(layerId, field, customColorMap);
                        } else if (layerInfo.classification && layerInfo.classification.field === field && layerInfo.classification.colorMap) {
                            // Use existing colors
                            console.log('Using existing custom colors from layer info');
                            applyCategoricalSymbologyWithCustomColors(layerId, field, layerInfo.classification.colorMap);
                        } else {
                            // Fall back to auto-generated colors
                            console.log('Using auto-generated colors');
                            applyCategoricalSymbologyWithStroke(layerId, field);
                        }
                    }
                }
                
                // Close the editor after applying
                editorPanel.remove();
            });
            
            // Reset button
            editorPanel.querySelector('#resetSymbology').addEventListener('click', function() {
                resetLayerSymbology(layerId);
                editorPanel.remove();
            });
            
            // Initialize legend preview if there's existing categorical classification
            if (layerInfo.classification && layerInfo.classification.field) {
                const field = layerInfo.classification.field;
                console.log('Initializing legend preview for existing classification field:', field);
                generateLegendPreview(layerId, field, editorPanel);
                legendPreview.classList.remove('hidden');
            }
        }
                const legendPreview = editorPanel.querySelector('#legendPreview');
                const legendItems = editorPanel.querySelector('#legendItems');

                if (field) {
                    applyBtn.disabled = false;
                    legendPreview.classList.remove('hidden');

                    // Generate preview legend
                    const features = layerInfo.data.features;
                    const uniqueValues = [...new Set(features.map(f => f.properties[field]))];
                    const colors = generateColors(uniqueValues.length);

                    legendItems.innerHTML = '';
                    uniqueValues.forEach((value, index) => {
                        const color = colors[index];
                        const legendItem = document.createElement('div');
                        legendItem.className = 'flex items-center justify-between space-x-2';
                        legendItem.innerHTML = `
                            <div class="flex items-center space-x-2 flex-1 min-w-0">
                                <div class="w-4 h-4 rounded border border-gray-500 flex-shrink-0" style="background-color: ${color}"></div>
                                <span class="text-sm text-gray-300 truncate">${value || 'null'}</span>
                            </div>
                            <input type="color" value="${color}" class="w-6 h-6 rounded border-0 cursor-pointer color-picker" data-value="${value}">
                        `;
                        legendItems.appendChild(legendItem);
                    });
        }

        // Apply single symbol styling to layer
        function applySingleSymbol(layerId, color) {
            console.log(`Applying single symbol with color ${color} to layer ${layerId}`);
            
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;
            
            // Update the layer style
            const newStyle = {
                color: color,
                fillColor: color,
                weight: 2,
                opacity: 1.0,
                fillOpacity: 0.7
            };
            
            // Apply style to the layer
            layerInfo.layer.setStyle(newStyle);
            layerInfo.style = newStyle;
            
            // Update legend
            updateLegend();
            
            console.log(`Single symbol applied successfully`);
        }

        // Apply single symbol styling with stroke controls
        function applySingleSymbolWithStroke(layerId, fillColor, strokeColor, strokeWidth) {
            console.log(`Applying single symbol with fill ${fillColor}, stroke ${strokeColor}, width ${strokeWidth} to layer ${layerId}`);
            
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;
            
            // Update the layer style with stroke controls
            const newStyle = {
                color: strokeColor,
                fillColor: fillColor,
                weight: parseFloat(strokeWidth),
                opacity: 1.0,
                fillOpacity: 0.7
            };
            
            // Apply style to the layer
            layerInfo.layer.setStyle(newStyle);
            layerInfo.style = newStyle;
            
            // Save symbology settings to Supabase
            const symbologyData = {
                symbology_type: 'single',
                fill_color: fillColor,
                stroke_color: strokeColor,
                stroke_weight: parseFloat(strokeWidth),
                fill_opacity: 0.7,
                stroke_opacity: 1.0
            };
            
            saveSymbologyToSupabase(layerId, symbologyData);
            
            // Update legend
            updateLegend();
            
            console.log(`Single symbol with stroke applied successfully`);
        }

        // Apply categorical symbology to layer
        function applyCategoricalSymbology(layerId, field) {
            console.log(`Applying categorical symbology for field ${field} to layer ${layerId}`);
            
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;
            
            const features = layerInfo.data.features;
            if (!features || features.length === 0) return;
            
            // Get unique values and generate colors
            const uniqueValues = [...new Set(features.map(f => f.properties[field]).filter(v => v !== null && v !== undefined))];
            const colorMap = generateColorMap(uniqueValues);
            
            // Apply the styling
            layerInfo.layer.setStyle(function(feature) {
                const value = feature.properties[field];
                const color = colorMap[value] || '#999999';
                return {
                    color: color,
                    fillColor: color,
                    weight: 2,
                    opacity: 1.0,
                    fillOpacity: 0.7
                };
            });
            
            // Store the classification info
            layerInfo.classification = {
                field: field,
                colorMap: colorMap
            };
            
            // Update legend
            updateLegend();
            
            console.log(`Categorical symbology applied successfully`);
        }

        // Apply categorical symbology with stroke controls
        function applyCategoricalSymbologyWithStroke(layerId, field) {
            console.log(`Applying categorical symbology with stroke controls for field ${field} to layer ${layerId}`);
            
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;
            
            const features = layerInfo.data.features;
            if (!features || features.length === 0) return;
            
            // Get stroke settings from the editor panel
            const editorPanel = document.getElementById('symbologyEditor');
            const strokeColor = editorPanel ? editorPanel.querySelector('#categoricalStrokeColor').value : '#ffffff';
            const strokeWidth = editorPanel ? parseFloat(editorPanel.querySelector('#categoricalStrokeWidth').value) : 2;
            
            // Get unique values and generate colors
            const uniqueValues = [...new Set(features.map(f => f.properties[field]).filter(v => v !== null && v !== undefined))];
            const colorMap = generateColorMap(uniqueValues);
            
            // Apply the styling with stroke controls
            layerInfo.layer.setStyle(function(feature) {
                const value = feature.properties[field];
                const fillColor = colorMap[value] || '#999999';
                return {
                    color: strokeColor,
                    fillColor: fillColor,
                    weight: strokeWidth,
                    opacity: 1.0,
                    fillOpacity: 0.7
                };
            });
            
            // Store the classification info with stroke settings
            layerInfo.classification = {
                field: field,
                colorMap: colorMap,
                strokeColor: strokeColor,
                strokeWidth: strokeWidth
            };
            
            // Save symbology settings to Supabase
            const categories = uniqueValues.map(value => ({
                value: value,
                color: colorMap[value]
            }));
            
            const symbologyData = {
                symbology_type: 'categorical',
                stroke_color: strokeColor,
                stroke_weight: strokeWidth,
                fill_opacity: 0.7,
                stroke_opacity: 1.0,
                classification_field: field,
                categories: categories
            };
            
            saveSymbologyToSupabase(layerId, symbologyData);
            
            // Update legend
            updateLegend();
            
            console.log(`Categorical symbology with stroke applied successfully`);
        }

        // Apply categorical symbology with custom user-selected colors
        function applyCategoricalSymbologyWithCustomColors(layerId, field, customColorMap) {
            console.log(`Applying categorical symbology with custom colors for field ${field} to layer ${layerId}`, customColorMap);
            
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;
            
            const features = layerInfo.data.features;
            if (!features || features.length === 0) return;
            
            // Get stroke settings from the editor panel
            const editorPanel = document.getElementById('symbologyEditor');
            const strokeColor = editorPanel ? editorPanel.querySelector('#categoricalStrokeColor').value : '#ffffff';
            const strokeWidth = editorPanel ? parseFloat(editorPanel.querySelector('#categoricalStrokeWidth').value) : 2;
            
            // Apply the styling with custom colors
            layerInfo.layer.setStyle(function(feature) {
                const value = feature.properties[field];
                const fillColor = customColorMap[value] || '#999999';
                return {
                    color: strokeColor,
                    fillColor: fillColor,
                    weight: strokeWidth,
                    opacity: 1.0,
                    fillOpacity: 0.7
                };
            });
            
            // Store the classification info with custom colors
            layerInfo.classification = {
                field: field,
                colorMap: customColorMap,
                strokeColor: strokeColor,
                strokeWidth: strokeWidth
            };
            
            // Save symbology settings to Supabase with custom colors
            const categories = Object.keys(customColorMap).map(value => ({
                value: value,
                color: customColorMap[value]
            }));
            
            const symbologyData = {
                symbology_type: 'categorical',
                stroke_color: strokeColor,
                stroke_weight: strokeWidth,
                fill_opacity: 0.7,
                stroke_opacity: 1.0,
                classification_field: field,
                categories: categories
            };
            
            saveSymbologyToSupabase(layerId, symbologyData);
            
            // Update legend
            updateLegend();
            
            console.log(`Categorical symbology with custom colors applied and saved successfully`);
        }

        // Generate legend preview for categorical symbology
        function generateLegendPreview(layerId, field, editorPanel) {
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;
            
            const features = layerInfo.data.features;
            if (!features || features.length === 0) return;
            
            // Get unique values
            const uniqueValues = [...new Set(features.map(f => f.properties[field]).filter(v => v !== null && v !== undefined))];
            
            if (uniqueValues.length === 0) return;
            
            // Check if we have existing colors from previous classification or use generated colors
            let colorMap;
            if (layerInfo.classification && layerInfo.classification.field === field && layerInfo.classification.colorMap) {
                // Use existing color map if available
                colorMap = layerInfo.classification.colorMap;
            } else {
                // Generate new colors
                colorMap = generateColorMap(uniqueValues);
            }
            
            // Update legend preview
            const legendItems = editorPanel.querySelector('#legendItems');
            legendItems.innerHTML = '';
            
            uniqueValues.forEach(value => {
                const color = colorMap[value] || '#999999';
                const legendItem = document.createElement('div');
                legendItem.className = 'flex items-center space-x-3 text-sm';
                legendItem.innerHTML = `
                    <div class="w-4 h-4 rounded border border-gray-500" style="background-color: ${color}"></div>
                    <span class="text-gray-300 flex-1">${value}</span>
                    <input type="color" value="${color}" class="w-6 h-6 rounded border-0 cursor-pointer color-picker" data-value="${value}">
                `;
                legendItems.appendChild(legendItem);
            });
            
            // Add color picker listeners that update both map and save to database
            legendItems.querySelectorAll('.color-picker').forEach(picker => {
                picker.addEventListener('change', function() {
                    const value = this.dataset.value;
                    const newColor = this.value;
                    
                    console.log(`Manual color change for category "${value}": ${newColor}`);
                    
                    // Update the color map
                    colorMap[value] = newColor;
                    
                    // Update the visual preview
                    const colorDiv = this.parentElement.querySelector('div');
                    colorDiv.style.backgroundColor = newColor;
                    
                    // Apply the updated categorical symbology to the map immediately
                    applyCategoricalSymbologyWithCustomColors(layerId, field, colorMap);
                });
            });
        }

        // Generate color map for unique values
        function generateColorMap(uniqueValues) {
            const colors = [
                '#e53e3e', '#dd6b20', '#d69e2e', '#38a169', '#319795', 
                '#3182ce', '#553c9a', '#b83280', '#805ad5', '#ed8936'
            ];
            
            const colorMap = {};
            uniqueValues.forEach((value, index) => {
                colorMap[value] = colors[index % colors.length];
            });
            
            return colorMap;
        }

        // Reset layer symbology to default
        function resetLayerSymbology(layerId) {
            console.log(`Resetting symbology for layer ${layerId}`);
            
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;
            
            // Reset to default style
            let defaultStyle = {
                color: '#ffffff',
                weight: 2,
                opacity: 1.0,
                fillColor: '#14b8a6',
                fillOpacity: 0.7
            };

            // Special default for Aera layer
            if (layerId === 'aera-layer' || layerInfo.name === 'Aera') {
                defaultStyle.fillColor = '#14b8a6'; // Teal
                defaultStyle.color = '#0d7377'; // Dark teal
                defaultStyle.weight = 1;
            }
            
            layerInfo.layer.setStyle(defaultStyle);
            layerInfo.style = defaultStyle;
            
            // Clear classification info
            if (layerInfo.classification) {
                delete layerInfo.classification;
            }
            
            // Save default symbology to Supabase
            const symbologyData = {
                symbology_type: 'single',
                fill_color: defaultStyle.fillColor,
                stroke_color: defaultStyle.color,
                stroke_weight: defaultStyle.weight,
                fill_opacity: defaultStyle.fillOpacity,
                stroke_opacity: defaultStyle.opacity
            };
            
            saveSymbologyToSupabase(layerId, symbologyData);
            
            // Update legend
            updateLegend();
            
            console.log(`Layer symbology reset to default`);
        }

        // Make panel draggable
        function makeDraggable(element) {
            const header = element.querySelector('#symbologyEditorHeader');
            if (!header) return;
            
            let isDragging = false;
            let startX, startY, startLeft, startTop;

            header.addEventListener('mousedown', function(e) {
                // Don't drag if clicking on close button
                if (e.target.closest('#closeSymbologyEditor')) {
                    return;
                }
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startLeft = element.offsetLeft;
                startTop = element.offsetTop;
                
                // Add dragging class for visual feedback
                header.style.cursor = 'grabbing';
                element.style.userSelect = 'none';
                
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;
                
                // Keep panel within viewport bounds
                const rect = element.getBoundingClientRect();
                const maxLeft = window.innerWidth - rect.width;
                const maxTop = window.innerHeight - rect.height;
                
                newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                newTop = Math.max(0, Math.min(newTop, maxTop));
                
                element.style.left = newLeft + 'px';
                element.style.top = newTop + 'px';
                element.style.right = 'auto';
            });

            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    header.style.cursor = 'move';
                    element.style.userSelect = '';
                }
            });
        }

        // Setup outside click to close panel
        function setupOutsideClickClose(element) {
            // Add a small delay to prevent immediate closing
            setTimeout(() => {
                document.addEventListener('click', function closeOnOutsideClick(e) {
                    if (!element.contains(e.target)) {
                        element.remove();
                        document.removeEventListener('click', closeOnOutsideClick);
                    }
                });
            }, 100);
        }

        // Update layer opacity
        function updateLayerOpacity(layerId, opacityValue) {
            const layerInfo = layers.get(layerId);
            if (!layerInfo || !layerInfo.layer) return;
            
            // Store opacity in layer info
            layerInfo.opacity = opacityValue;
            
            // Update layer style with new opacity
            layerInfo.layer.eachLayer(function(layer) {
                if (layer.setStyle) {
                    const currentStyle = layer.options;
                    
                    // Store original style values if not already stored
                    if (!layer._originalOpacity) {
                        layer._originalOpacity = {
                            fillOpacity: currentStyle.fillOpacity || 1.0,
                            opacity: currentStyle.opacity || 1.0
                        };
                    }
                    
                    // Calculate new opacity values
                    // At 100% (1.0), use full opacity values; at 0% (0.0), use 0 opacity
                    const newFillOpacity = layer._originalOpacity.fillOpacity * opacityValue;
                    const newStrokeOpacity = layer._originalOpacity.opacity * opacityValue;
                    
                    layer.setStyle({
                        ...currentStyle,
                        fillOpacity: newFillOpacity,
                        opacity: newStrokeOpacity
                    });
                }
            });
        }

        // Apply categorical symbology from editor
        function applyCategoricalSymbologyFromEditor(layerId, field, colorMap) {
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;

            // Remove existing layer
            map.removeLayer(layerInfo.layer);

            // Create new styled layer
            const newLayer = L.geoJSON(layerInfo.data, {
                style: (feature) => {
                    const value = feature.properties[field];
                    const color = colorMap[value] || '#14b8a6';
                    return {
                        color: '#ffffff',
                        weight: 2,
                        opacity: 1.0,
                        fillColor: color,
                        fillOpacity: 1.0
                    };
                },
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="text-sm">';
                        for (let key in feature.properties) {
                            popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                        popupContent += '</div>';
                        
                        safeBindPopup(layer, popupContent, {
                            maxWidth: 400,
                            maxHeight: 300,
                            autoPan: false,
                            closePopupOnClick: true,
                            autoClose: true,
                            className: 'custom-popup',
                            offset: [0, -10]
                        });
                    }
                }
            }).addTo(map);

            // Update layer info
            layerInfo.layer = newLayer;
            layerInfo.style = { categoricalField: field, colorMap: colorMap };

            // Reapply opacity if it's not default
            if (layerInfo.opacity !== undefined && layerInfo.opacity !== 1.0) {
                updateLayerOpacity(layerId, layerInfo.opacity);
            }

            updateLegend();
        }

        // Reset layer symbology to default
        function resetLayerSymbology(layerId) {
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;

            const defaultStyle = {
                color: '#ffffff',
                weight: 2,
                opacity: 1.0,
                fillColor: '#14b8a6',
                fillOpacity: 1.0
            };

            // Remove existing layer
            map.removeLayer(layerInfo.layer);

            // Create new layer with default style
            const newLayer = L.geoJSON(layerInfo.data, {
                style: defaultStyle,
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="text-sm">';
                        for (let key in feature.properties) {
                            popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                        popupContent += '</div>';
                        
                        safeBindPopup(layer, popupContent, {
                            maxWidth: 400,
                            maxHeight: 300,
                            autoPan: false,
                            closePopupOnClick: true,
                            autoClose: true,
                            className: 'custom-popup',
                            offset: [0, -10]
                        });
                        
                        layer.on('click', function(e) {
                            if (isSelectionActive) {
                                e.originalEvent.preventDefault();
                                e.originalEvent.stopPropagation();
                                return false;
                            }
                        });
                    }
                }
            }).addTo(map);

            // Update layer info
            layerInfo.layer = newLayer;
            layerInfo.style = defaultStyle;

            // Reapply opacity if it's not default
            if (layerInfo.opacity !== undefined && layerInfo.opacity !== 1.0) {
                updateLayerOpacity(layerId, layerInfo.opacity);
            }

            updateLegend();
        }

        // Toggle symbology options (legacy - kept for compatibility)
        function toggleSymbologyOptions() {
            // Legacy function - not used with new symbology editor
            return;
        }

        // Apply symbology (legacy - kept for compatibility)
        function applySymbology() {
            // Legacy function - not used with new symbology editor
            return;
        }

        // Apply single symbol
        function applySingleSymbol(layerId, color) {
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;

            const newStyle = {
                color: '#ffffff',
                weight: 2,
                opacity: 1.0,
                fillColor: color,
                fillOpacity: 1.0
            };

            // Remove existing layer
            map.removeLayer(layerInfo.layer);

            // Create new styled layer
            const newLayer = L.geoJSON(layerInfo.data, {
                style: newStyle,
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="text-sm">';
                        for (let key in feature.properties) {
                            popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                        popupContent += '</div>';
                        
                        // Bind popup with custom options to prevent map movement and ensure proper sizing
                        safeBindPopup(layer, popupContent, {
                            maxWidth: 400,
                            maxHeight: 300,
                            autoPan: false, // Prevent map from panning to show popup
                            closePopupOnClick: true,
                            autoClose: true, // Close previous popup when opening new one
                            className: 'custom-popup',
                            offset: [0, -10] // Slight offset to avoid covering the clicked feature
                        });
                    }
                }
            }).addTo(map);

            // Update layer info
            layerInfo.layer = newLayer;
            layerInfo.style = newStyle;

            updateLegend();
        }

        // Apply categorical symbol
        function applyCategoricalSymbol(layerId, field) {
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;

            // Get unique values
            const features = layerInfo.data.features;
            const uniqueValues = [...new Set(features.map(f => f.properties[field]))];
            
            // Generate colors
            const colors = generateColors(uniqueValues.length);
            const colorMap = {};
            uniqueValues.forEach((value, index) => {
                colorMap[value] = colors[index];
            });

            // Remove existing layer
            map.removeLayer(layerInfo.layer);

            // Create new styled layer
            const newLayer = L.geoJSON(layerInfo.data, {
                style: (feature) => {
                    const value = feature.properties[field];
                    const color = colorMap[value] || '#14b8a6';
                    return {
                        color: '#ffffff',
                        weight: 2,
                        opacity: 1.0,
                        fillColor: color,
                        fillOpacity: 1.0
                    };
                },
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="text-sm">';
                        for (let key in feature.properties) {
                            popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                        popupContent += '</div>';
                        
                        // Bind popup with custom options to prevent map movement and ensure proper sizing
                        safeBindPopup(layer, popupContent, {
                            maxWidth: 400,
                            maxHeight: 300,
                            autoPan: false, // Prevent map from panning to show popup
                            closePopupOnClick: true,
                            autoClose: true, // Close previous popup when opening new one
                            className: 'custom-popup',
                            offset: [0, -10] // Slight offset to avoid covering the clicked feature
                        });
                    }
                }
            }).addTo(map);

            // Update layer info
            layerInfo.layer = newLayer;
            layerInfo.style = { categoricalField: field, colorMap: colorMap };

            updateLegend();
        }

        // Generate distinct colors
        function generateColors(count) {
            const colors = [
                '#14b8a6', '#06b6d4', '#8b5cf6', '#f59e0b',
                '#ef4444', '#10b981', '#3b82f6', '#f97316',
                '#ec4899', '#84cc16', '#6366f1', '#eab308'
            ];

            if (count <= colors.length) {
                return colors.slice(0, count);
            }

            // Generate additional colors if needed
            const additionalColors = [];
            for (let i = colors.length; i < count; i++) {
                const hue = (i * 137.508) % 360; // Golden angle approximation
                additionalColors.push(`hsl(${hue}, 70%, 50%)`);
            }

            return [...colors, ...additionalColors];
        }

        // Initialize selection tools
        function initializeSelectionTools() {
            // Create a layer group for drawn items
            drawnItems = new L.FeatureGroup();
            map.addLayer(drawnItems);

            // Remove the old draw control - we'll implement custom freehand drawing
            drawControl = null;
        }

        // Initialize middle mouse button panning
        function initializeMiddleMousePanning() {
            const mapContainer = map.getContainer();
            let isDraggingWithMiddle = false;
            let startPoint = null;
            
            // Prevent context menu on middle button
            mapContainer.addEventListener('contextmenu', function(e) {
                if (e.button === 1) {
                    e.preventDefault();
                }
            });

            // Handle middle mouse button down - start custom panning
            mapContainer.addEventListener('mousedown', function(e) {
                if (e.button === 1) { // Middle mouse button
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isMiddleMouseDown = true;
                    isDraggingWithMiddle = false;
                    startPoint = { x: e.clientX, y: e.clientY };
                    
                    // Change cursor to indicate panning mode
                    mapContainer.style.cursor = 'grab';
                }
            });

            // Handle mouse move for middle button panning
            mapContainer.addEventListener('mousemove', function(e) {
                if (isMiddleMouseDown && startPoint) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (!isDraggingWithMiddle) {
                        // Start dragging - change cursor to grabbing
                        mapContainer.style.cursor = 'grabbing';
                        isDraggingWithMiddle = true;
                    }
                    
                    // Calculate movement delta
                    const deltaX = e.clientX - startPoint.x;
                    const deltaY = e.clientY - startPoint.y;
                    
                    // Only pan if there's significant movement to avoid jitter
                    if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                        // Get current map center
                        const currentCenter = map.getCenter();
                        
                        // Convert pixel movement to lat/lng movement
                        const pixelBounds = map.getPixelBounds();
                        const pixelOrigin = map.getPixelOrigin();
                        
                        // Calculate new center based on pixel movement
                        const currentPixel = map.latLngToContainerPoint(currentCenter);
                        const newPixel = L.point(currentPixel.x - deltaX, currentPixel.y - deltaY);
                        const newCenter = map.containerPointToLatLng(newPixel);
                        
                        // Pan to new center
                        map.panTo(newCenter, { animate: false });
                        
                        // Update start point for next movement
                        startPoint = { x: e.clientX, y: e.clientY };
                    }
                }
            });

            // Handle middle mouse button up - stop custom panning
            mapContainer.addEventListener('mouseup', function(e) {
                if (e.button === 1 && isMiddleMouseDown) { // Middle mouse button
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isMiddleMouseDown = false;
                    isDraggingWithMiddle = false;
                    startPoint = null;
                    
                    // Restore appropriate cursor based on current tool
                    if (isSelectionActive) {
                        mapContainer.style.cursor = 'crosshair';
                    } else {
                        mapContainer.style.cursor = '';
                    }
                }
            });

            // Handle mouse leave - stop panning if middle button was held
            mapContainer.addEventListener('mouseleave', function(e) {
                if (isMiddleMouseDown) {
                    isMiddleMouseDown = false;
                    isDraggingWithMiddle = false;
                    startPoint = null;
                    
                    // Restore appropriate cursor
                    if (isSelectionActive) {
                        mapContainer.style.cursor = 'crosshair';
                    } else {
                        mapContainer.style.cursor = '';
                    }
                }
            });

            // Prevent middle button from interfering with other mouse events
            mapContainer.addEventListener('click', function(e) {
                if (e.button === 1) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
        }

        // Setup selection tool event listeners
        function setupSelectionListeners() {
            document.getElementById('activateSelectTool').addEventListener('click', activateSelectionTool);
            document.getElementById('clearSelection').addEventListener('click', clearSelection);
            document.getElementById('showStatistics').addEventListener('click', toggleStatisticsPanel);

            // Real-time statistics field selection handler
            document.getElementById('statisticsFieldSelect').addEventListener('change', function(e) {
                calculateAndUpdateStatistics();
            });

            // Real-time statistics operations checkboxes handlers
            document.addEventListener('change', function(e) {
                if (e.target.classList.contains('statistics-operation-checkbox')) {
                    calculateAndUpdateStatistics();
                }
            });

            // Layer selection dropdown handler
            document.getElementById('activeLayerSelect').addEventListener('change', function(e) {
                activeSelectionLayerId = e.target.value;
                const activateBtn = document.getElementById('activateSelectTool');
                const statisticsBtn = document.getElementById('showStatistics');
                
                if (activeSelectionLayerId) {
                    activateBtn.disabled = false;
                    activateBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    
                    // Enable Statistics button when layer is selected
                    statisticsBtn.disabled = false;
                } else {
                    activateBtn.disabled = true;
                    activateBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    
                    // Disable Statistics button when no layer is selected
                    statisticsBtn.disabled = true;
                    
                    // Hide statistics panel when no layer is selected
                    document.getElementById('statisticsPanel').style.display = 'none';
                    
                    // If selection is active and no layer is selected, deactivate
                    if (isSelectionActive) {
                        deactivateSelectionTool();
                    }
                }
            });

            // Two-click freehand drawing event handlers
            function handleMouseDown(e) {
                if (!isSelectionActive || isMiddleMouseDown) return;
                
                // Only handle left mouse button for selection
                if (e.originalEvent.button !== 0) return;
                
                // ALWAYS prevent default and popup behavior during selection
                e.originalEvent.preventDefault();
                e.originalEvent.stopPropagation();
                
                if (!hasStartedDrawing) {
                    // First click - start drawing
                    hasStartedDrawing = true;
                    isDrawing = true;
                    drawingPath = [e.latlng];
                    
                    // Clear any existing drawing layers
                    if (currentDrawingLayer) {
                        map.removeLayer(currentDrawingLayer);
                    }
                    if (currentFillLayer) {
                        map.removeLayer(currentFillLayer);
                    }
                    
                    // Create initial drawing layer (line only)
                    currentDrawingLayer = L.polyline([e.latlng], {
                        color: '#ff7800',
                        weight: 3,
                        opacity: 0.8,
                        smoothFactor: 1
                    }).addTo(map);
                    
                    // Create initial fill layer (semi-transparent orange fill)
                    currentFillLayer = L.polygon([e.latlng, e.latlng], {
                        color: '#ff7800',
                        weight: 1,
                        opacity: 0.3,
                        fillColor: '#ff7800',
                        fillOpacity: 0.15,
                        smoothFactor: 1
                    }).addTo(map);
                } else {
                    // Second click - end drawing and perform selection
                    hasStartedDrawing = false;
                    isDrawing = false;
                    
                    // Add final point to the path
                    drawingPath.push(e.latlng);
                    
                    // Close the shape and perform selection
                    if (drawingPath.length > 1) {
                        // Close the polygon - use the exact drawn path without buffering
                        const closedPath = [...drawingPath, drawingPath[0]];
                        
                        // Capture modifier key state at the time of selection
                        const modifierKeys = {
                            shiftKey: e.originalEvent.shiftKey || false,
                            ctrlKey: e.originalEvent.ctrlKey || e.originalEvent.metaKey || false
                        };
                        
                        findIntersectingFeaturesWithPolygon(closedPath, modifierKeys);
                    }
                    
                    // Remove the drawing layers after a brief delay to show completion
                    setTimeout(() => {
                        if (currentDrawingLayer) {
                            map.removeLayer(currentDrawingLayer);
                            currentDrawingLayer = null;
                        }
                        if (currentFillLayer) {
                            map.removeLayer(currentFillLayer);
                            currentFillLayer = null;
                        }
                    }, 200);
                    
                    // Clear the drawing path
                    drawingPath = [];
                }
            }

            function handleMouseMove(e) {
                if (!isSelectionActive || !isDrawing || isMiddleMouseDown) return;
                
                // Continuously add points to the drawing path for true freehand drawing
                if (hasStartedDrawing) {
                    // Add current mouse position to the path for smooth freehand drawing
                    drawingPath.push(e.latlng);
                    
                    // Update the drawing layer with the full freehand path
                    if (currentDrawingLayer) {
                        currentDrawingLayer.setLatLngs(drawingPath);
                    }
                    
                    // Update fill layer - create closed shape from the complete drawn path
                    if (currentFillLayer && drawingPath.length > 2) {
                        const fillPath = [...drawingPath, drawingPath[0]]; // Close the shape
                        currentFillLayer.setLatLngs([fillPath]);
                    }
                }
            }

            // Remove the mouse up handler since we're using two-click mode
            function handleMouseUp(e) {
                // No longer needed for two-click mode
                return;
            }

            // Store event handlers for later removal
            map._freehandHandlers = {
                mousedown: handleMouseDown,
                mousemove: handleMouseMove,
                mouseup: handleMouseUp
            };
        }

        // Activate selection tool
        function activateSelectionTool() {
            // Check if an active layer is selected
            if (!activeSelectionLayerId) {
                alert('Please select a layer from the dropdown before activating the selection tool.');
                return;
            }
            
            if (!isSelectionActive) {
                isSelectionActive = true;
                
                // Clear previous selection
                clearSelection();
                
                // Reset drawing state
                hasStartedDrawing = false;
                isDrawing = false;
                
                // DISABLE popups on all layers during selection mode
                disablePopupsOnAllLayers();
                
                // DISABLE map dragging completely when selection tool is active
                map.dragging.disable();
                
                // Add freehand drawing event listeners
                map.on('mousedown', map._freehandHandlers.mousedown);
                map.on('mousemove', map._freehandHandlers.mousemove);
                map.on('mouseup', map._freehandHandlers.mouseup);
                
                // Update button states 
                document.getElementById('activateSelectTool').innerHTML = '<i class="fas fa-draw-polygon mr-2"></i>Selection Active (Shift: Add | Ctrl: Remove)';
                document.getElementById('activateSelectTool').classList.remove('bg-teal-600', 'hover:bg-teal-700');
                document.getElementById('activateSelectTool').classList.add('bg-orange-600', 'hover:bg-orange-700');
                
                // Change cursor to crosshair
                map.getContainer().style.cursor = 'crosshair';
                
                // Add a click handler to deactivate (optional - for user control)
                document.getElementById('activateSelectTool').removeEventListener('click', activateSelectionTool);
                document.getElementById('activateSelectTool').addEventListener('click', deactivateSelectionTool);
            }
        }

        // Deactivate selection tool
        function deactivateSelectionTool() {
            if (isSelectionActive) {
                isSelectionActive = false;
                isDrawing = false;
                hasStartedDrawing = false;
                
                // Remove freehand drawing event listeners
                map.off('mousedown', map._freehandHandlers.mousedown);
                map.off('mousemove', map._freehandHandlers.mousemove);
                map.off('mouseup', map._freehandHandlers.mouseup);
                
                // Clean up any current drawing
                if (currentDrawingLayer) {
                    map.removeLayer(currentDrawingLayer);
                    currentDrawingLayer = null;
                }
                if (currentFillLayer) {
                    map.removeLayer(currentFillLayer);
                    currentFillLayer = null;
                }
                drawingPath = [];
                
                // RE-ENABLE popups on all layers after selection mode
                enablePopupsOnAllLayers();
                
                // RE-ENABLE map dragging when selection tool is deactivated
                map.dragging.enable();
                
                // Reset cursor
                map.getContainer().style.cursor = '';
                
                // Update button states
                document.getElementById('activateSelectTool').innerHTML = '<i class="fas fa-draw-polygon mr-2"></i>Activate Selection Tool';
                document.getElementById('activateSelectTool').classList.remove('bg-orange-600', 'hover:bg-orange-700');
                document.getElementById('activateSelectTool').classList.add('bg-teal-600', 'hover:bg-teal-700');
                
                // Restore original click handler
                document.getElementById('activateSelectTool').removeEventListener('click', deactivateSelectionTool);
                document.getElementById('activateSelectTool').addEventListener('click', activateSelectionTool);
            }
        }

        // Disable popups on all layers during selection mode
        function disablePopupsOnAllLayers() {
            if (popupsDisabled) return; // Already disabled
            
            popupsDisabled = true;
            layers.forEach((layerInfo, layerId) => {
                if (layerInfo.layer) {
                    // Store the original popup content for restoration later
                    layerInfo._originalPopup = layerInfo.layer.getPopup();
                    // Unbind the popup to prevent it from appearing
                    layerInfo.layer.unbindPopup();
                }
            });
            
            console.log('🚫 Popups disabled for all layers during selection mode');
        }

        // Re-enable popups on all layers after selection mode
        function enablePopupsOnAllLayers() {
            if (!popupsDisabled) return; // Already enabled
            
            popupsDisabled = false;
            layers.forEach((layerInfo, layerId) => {
                if (layerInfo.layer) {
                    // First, restore original popups that were stored (convert to right-click)
                    if (layerInfo._originalPopup) {
                        const originalContent = layerInfo._originalPopup.getContent();
                        // Use safeBindPopup to convert to right-click
                        layerInfo.layer.eachLayer(function(sublayer) {
                            if (sublayer && originalContent) {
                                safeBindPopup(sublayer, originalContent);
                            }
                        });
                        delete layerInfo._originalPopup;
                    }
                    
                    // Also handle any pending popup content from layers created during selection
                    layerInfo.layer.eachLayer(function(sublayer) {
                        if (sublayer._pendingPopupContent) {
                            // Use safeBindPopup for right-click behavior
                            safeBindPopup(sublayer, sublayer._pendingPopupContent);
                            delete sublayer._pendingPopupContent;
                        }
                    });
                }
            });
            
            console.log('✅ Popups re-enabled for all layers after selection mode');
        }

        // Helper function to safely bind popups (respects selection mode) - RIGHT-CLICK ONLY
        function safeBindPopup(layer, popupContent) {
            if (!popupsDisabled) {
                // Remove any existing popup bindings first
                layer.unbindPopup();
                
                // Bind popup to right-click (contextmenu) event only
                layer.on('contextmenu', function(e) {
                    // Prevent the default browser context menu for this feature
                    e.originalEvent.preventDefault();
                    e.originalEvent.stopPropagation();
                    
                    // Create modern styled popup content
                    const modernPopupContent = createModernPopupContent(layer.feature ? layer.feature.properties : {});
                    
                    // Create and show popup at the clicked location
                    const popup = L.popup({
                        maxWidth: 350,
                        maxHeight: 400,
                        autoPan: true,
                        closePopupOnClick: true,
                        autoClose: true,
                        className: 'modern-feature-popup',
                        offset: [0, -15]
                    })
                    .setLatLng(e.latlng)
                    .setContent(modernPopupContent)
                    .openOn(map);
                });
            } else {
                // Store popup content for later binding when popups are re-enabled
                layer._pendingPopupContent = popupContent;
            }
        }

        // Create modern styled popup content
        function createModernPopupContent(properties) {
            if (!properties || Object.keys(properties).length === 0) {
                return `
                    <div class="modern-popup-container">
                        <div class="modern-popup-header">
                            <i class="fas fa-info-circle mr-2"></i>
                            <span>Feature Information</span>
                        </div>
                        <div class="modern-popup-body">
                            <p class="no-data-text">No property data available</p>
                        </div>
                    </div>
                `;
            }

            let propertiesHtml = '';
            for (let key in properties) {
                const value = properties[key];
                if (value !== null && value !== undefined && value !== '') {
                    propertiesHtml += `
                        <div class="property-row">
                            <span class="property-key">${key}:</span>
                            <span class="property-value">${value}</span>
                        </div>
                    `;
                }
            }

            return `
                <div class="modern-popup-container">
                    <div class="modern-popup-header">
                        <i class="fas fa-layer-group mr-2"></i>
                        <span>Feature Properties</span>
                    </div>
                    <div class="modern-popup-body">
                        ${propertiesHtml || '<p class="no-data-text">No valid properties found</p>'}
                    </div>
                </div>
            `;
        }

        // Find features that intersect with the drawn freehand polygon using Turf.js
        function findIntersectingFeaturesWithPolygon(polygonPath, modifierKeys = {}) {
            console.log('🔍 Starting strict selection process...');
            
            // Store current selection for modifier key operations
            const previousSelectedFeatures = [...selectedFeatures];
            const newSelectedFeatures = [];
            
            // Only clear highlights and selection if no modifier keys are held
            if (!modifierKeys.shiftKey && !modifierKeys.ctrlKey) {
                selectedFeatures = [];
                clearHighlights();
            } else {
                console.log('🎹 Modifier key detected:', modifierKeys.shiftKey ? 'Shift' : '', modifierKeys.ctrlKey ? 'Ctrl' : '');
            }
            
            // Validate polygon path
            if (!polygonPath || polygonPath.length < 4) { // Need at least 4 points for a closed polygon
                console.warn('❌ Invalid polygon path for selection:', polygonPath);
                updateSelectionInfo();
                return;
            }
            
            // Check if active layer is selected
            if (!activeSelectionLayerId || !layers.has(activeSelectionLayerId)) {
                console.warn('❌ No valid active layer selected for selection');
                alert('Please select a valid layer for selection.');
                updateSelectionInfo();
                return;
            }
            
            const activeLayerInfo = layers.get(activeSelectionLayerId);
            if (!activeLayerInfo.visible || !activeLayerInfo.layer) {
                console.warn('❌ Active layer is not visible or has no layer object');
                alert('The selected layer is not visible on the map.');
                updateSelectionInfo();
                return;
            }
            
            console.log('✅ Selection polygon path:', polygonPath.length, 'points');
            console.log('✅ Active layer for selection:', activeSelectionLayerId, activeLayerInfo.name);
            
            // Check if Turf.js is available
            if (typeof turf === 'undefined') {
                console.error('❌ Turf.js is not loaded! Using fallback selection...');
                performBoundsBasedSelectionOnActiveLayer(polygonPath);
                return;
            }
            
            // Convert the drawn path to a Turf Polygon for selection
            const coordinates = polygonPath.map(point => [point.lng, point.lat]);
            console.log('📍 Raw selection coordinates:', coordinates.length, 'points');
            console.log('📍 First 3 coordinates [lng,lat]:', coordinates.slice(0, 3));
            console.log('📍 Last 3 coordinates [lng,lat]:', coordinates.slice(-3));
            
            // Validate coordinate ranges (basic sanity check)
            const validCoords = coordinates.every(coord => 
                coord[0] >= -180 && coord[0] <= 180 && coord[1] >= -90 && coord[1] <= 90
            );
            console.log('📍 All coordinates within valid ranges:', validCoords);
            
            // Ensure the polygon is properly closed for Turf.js
            const firstPoint = coordinates[0];
            const lastPoint = coordinates[coordinates.length - 1];
            if (firstPoint[0] !== lastPoint[0] || firstPoint[1] !== lastPoint[1]) {
                coordinates.push(firstPoint);
                console.log('🔄 Auto-closed polygon - added first point to end');
            } else {
                console.log('✅ Polygon was already closed');
            }
            
            // Ensure minimum points for valid polygon (need at least 4: 3 unique + 1 closing)
            if (coordinates.length < 4) {
                console.warn('❌ Not enough points for polygon:', coordinates.length);
                performBoundsBasedSelectionOnActiveLayer(polygonPath);
                return;
            }
            
            let drawnPolygon;
            try {
                // Always create a polygon for area-based selection
                drawnPolygon = turf.polygon([coordinates]);
                const bbox = turf.bbox(drawnPolygon);
                console.log('✅ Created selection polygon with', coordinates.length, 'coordinates');
                console.log('✅ Polygon bounding box [minX, minY, maxX, maxY]:', bbox);
                console.log('✅ Polygon area (sq degrees):', turf.area(drawnPolygon));
                
                // Remove center point containment test
                console.log('🎯 Skipping center point test – using polygon directly for intersection checks');
                
            } catch (error) {
                console.warn('❌ Failed to create selection polygon:', error);
                console.error('Invalid coordinates:', coordinates);
                // Fallback to simple bounds-based selection
                performBoundsBasedSelectionOnActiveLayer(polygonPath);
                return;
            }
            
            // Check only the active layer for intersecting features
            let layerFeatureCount = 0;
            let layerSelectedCount = 0;
            
            console.log(`🔎 Checking active layer with STRICT intersection: "${activeLayerInfo.name}"`);
            console.log('🔍 Active layer object:', activeLayerInfo.layer);
            console.log('🔍 Layer has eachLayer method:', typeof activeLayerInfo.layer.eachLayer === 'function');
            
            activeLayerInfo.layer.eachLayer(function(leafletFeature) {
                layerFeatureCount++;
                console.log(`📊 Processing feature ${layerFeatureCount}/${activeLayerInfo.layer.getLayers().length}:`, leafletFeature);
                
                // Additional debugging for Aera.geojson features
                if (activeLayerInfo.name === 'Aera') {
                    console.log('🗺️ Processing Aera.geojson feature:');
                    console.log('   Feature type:', leafletFeature.feature ? leafletFeature.feature.type : 'No feature object');
                    console.log('   Geometry type:', leafletFeature.feature && leafletFeature.feature.geometry ? leafletFeature.feature.geometry.type : 'No geometry');
                    console.log('   Has getLatLng:', typeof leafletFeature.getLatLng === 'function');
                    console.log('   Has getLatLngs:', typeof leafletFeature.getLatLngs === 'function');
                    if (leafletFeature.getLatLngs) {
                        const latLngs = leafletFeature.getLatLngs();
                        console.log('   LatLngs structure depth:', Array.isArray(latLngs) ? (Array.isArray(latLngs[0]) ? (Array.isArray(latLngs[0][0]) ? 3 : 2) : 1) : 0);
                    }
                }
                
                try {
                    // Validate feature before processing
                    if (!leafletFeature.feature || leafletFeature.feature.type !== 'Feature') {
                        console.log('⚠️ Skipping feature: not a valid GeoJSON Feature');
                        return;
                    }
                    
                    const geometryType = leafletFeature.feature.geometry ? leafletFeature.feature.geometry.type : null;
                    
                    // Convert Leaflet feature to GeoJSON for Turf.js
                    let geoJsonFeature;
                    let intersects = false;
                    
                    if (leafletFeature.getLatLng) {
                        // Point feature - test if point is inside the selection polygon
                        const point = leafletFeature.getLatLng();
                        geoJsonFeature = turf.point([point.lng, point.lat]);
                        
                        intersects = turf.booleanPointInPolygon(geoJsonFeature, drawnPolygon);
                        console.log(`📍 Point [${point.lat.toFixed(6)}, ${point.lng.toFixed(6)}] inside polygon: ${intersects}`);
                        
                        // Debug: Also log the point coordinates vs polygon bounds
                        const bbox = turf.bbox(drawnPolygon);
                        const inBounds = point.lng >= bbox[0] && point.lng <= bbox[2] && point.lat >= bbox[1] && point.lat <= bbox[3];
                        console.log(`📍 Point in polygon bounds: ${inBounds} (bounds check)`);
                        
                    } else if (leafletFeature.getLatLngs) {
                        // Only process Polygon and MultiPolygon features
                        if (geometryType !== 'Polygon' && geometryType !== 'MultiPolygon') {
                            console.log(`⚠️ Skipping feature: geometry type '${geometryType}' not supported (only Polygon/MultiPolygon allowed)`);
                            return;
                        }
                        
                        // Polygon or LineString feature
                        const latLngs = leafletFeature.getLatLngs();

                        if (Array.isArray(latLngs[0])) {
                            // Multi-ring polygon or MultiPolygon feature
                            try {
                                // Check if this is a MultiPolygon (nested arrays) or regular polygon with holes
                                let coordinates = [];
                                let isMultiPolygon = Array.isArray(latLngs[0][0]);
                                
                                console.log(`🔶 Processing ${isMultiPolygon ? 'MultiPolygon' : 'Polygon'} feature`);
                                
                                if (isMultiPolygon) {
                                    // This is a MultiPolygon - each top-level element is a complete polygon
                                    latLngs.forEach((polygon, polygonIndex) => {
                                        const rings = polygon.map(ring => {
                                            if (!Array.isArray(ring) || ring.length < 3) return null;
                                            const coords = ring.map(point => [point.lng, point.lat]);
                                            // Ensure ring is closed
                                            if (coords[0][0] !== coords[coords.length-1][0] || coords[0][1] !== coords[coords.length-1][1]) {
                                                coords.push(coords[0]);
                                            }
                                            return coords;
                                        }).filter(ring => ring !== null && ring.length >= 4);
                                        
                                        if (rings.length > 0) {
                                            coordinates.push(rings);
                                        }
                                    });
                                    
                                    // For MultiPolygon, test each polygon part separately
                                    for (let i = 0; i < coordinates.length; i++) {
                                        try {
                                            const singlePolygon = turf.polygon(coordinates[i]);
                                            intersects = turf.booleanIntersects(singlePolygon, drawnPolygon);
                                            console.log(`🔶 MultiPolygon part ${i+1}/${coordinates.length} intersection: ${intersects}`);
                                            if (intersects) break; // Found intersection, no need to test other parts
                                        } catch (partError) {
                                            console.warn(`⚠️ MultiPolygon part ${i+1} processing failed:`, partError);
                                        }
                                    }
                                } else {
                                    // This is a regular polygon with potential holes
                                    coordinates = latLngs.map(ring => {
                                        if (!Array.isArray(ring) || ring.length < 3) return null;
                                        const coords = ring.map(point => [point.lng, point.lat]);
                                        // Ensure ring is closed
                                        if (coords[0][0] !== coords[coords.length-1][0] || coords[0][1] !== coords[coords.length-1][1]) {
                                            coords.push(coords[0]);
                                        }
                                        return coords;
                                    }).filter(ring => ring !== null && ring.length >= 4);

                                    if (coordinates.length > 0) {
                                        geoJsonFeature = turf.polygon(coordinates);
                                        intersects = turf.booleanIntersects(geoJsonFeature, drawnPolygon);
                                        console.log(`🔶 Polygon feature intersection: ${intersects}`);
                                    }
                                }
                            } catch (polyError) {
                                console.warn('⚠️ Polygon processing failed:', polyError);
                            }
                        } else {
                            // Simple LineString feature
                            try {
                                if (latLngs.length >= 2) {
                                    const coordinates = latLngs.map(point => [point.lng, point.lat]);
                                    geoJsonFeature = turf.lineString(coordinates);

                                    // Strict geometry-to-geometry intersection test
                                    intersects = turf.booleanIntersects(geoJsonFeature, drawnPolygon);
                                    console.log(`📏 LineString feature intersection: ${intersects}`);
                                }
                            } catch (lineError) {
                                console.warn('⚠️ LineString processing failed:', lineError);
                            }
                        }
                    }
                    
                    if (intersects) {
                        layerSelectedCount++;
                        console.log('🎯 Feature INTERSECTS! Adding to selection...');
                        newSelectedFeatures.push({
                            layerId: activeSelectionLayerId,
                            layerName: activeLayerInfo.name,
                            feature: leafletFeature,
                            properties: leafletFeature.feature ? leafletFeature.feature.properties : {}
                        });
                    } else {
                        console.log('❌ Feature does NOT intersect selection polygon');
                    }
                    
                } catch (error) {
                    console.warn('⚠️ Feature processing failed:', error);
                    console.log('Feature type:', typeof leafletFeature);
                    console.log('Has getLatLng:', typeof leafletFeature.getLatLng);
                    console.log('Has getLatLngs:', typeof leafletFeature.getLatLngs);
                }
            });
            
            console.log(`📊 Selection complete: ${layerFeatureCount} total features, ${layerSelectedCount} selected`);
            console.log('New intersected features:', newSelectedFeatures.length);
            
            // Apply modifier key logic
            if (modifierKeys.shiftKey) {
                // Shift + Selection: Add to current selection
                console.log('➕ Shift+Selection: Adding to existing selection');
                
                // Create a Set of existing feature references for efficient lookup
                const existingFeatureRefs = new Set(selectedFeatures.map(item => item.feature));
                
                // Add new features that aren't already selected
                newSelectedFeatures.forEach(newItem => {
                    if (!existingFeatureRefs.has(newItem.feature)) {
                        selectedFeatures.push(newItem);
                        highlightFeature(newItem.feature);
                    }
                });
                
            } else if (modifierKeys.ctrlKey) {
                // Ctrl + Selection: Remove from current selection
                console.log('➖ Ctrl+Selection: Removing from existing selection');
                
                // Create a Set of features to remove for efficient lookup
                const featuresToRemove = new Set(newSelectedFeatures.map(item => item.feature));
                
                // Filter out intersected features from current selection and remove highlights
                selectedFeatures = selectedFeatures.filter(existingItem => {
                    if (featuresToRemove.has(existingItem.feature)) {
                        // Remove highlight from this feature
                        if (existingItem.feature._originalStyle) {
                            existingItem.feature.setStyle(existingItem.feature._originalStyle);
                            delete existingItem.feature._originalStyle;
                        }
                        return false; // Remove from selection
                    }
                    return true; // Keep in selection
                });
                
                // Remove from highlighted layers array
                highlightedLayers = highlightedLayers.filter(layer => !featuresToRemove.has(layer));
                
            } else {
                // Default behavior: Replace selection entirely
                console.log('🔄 Default selection: Replacing current selection');
                selectedFeatures = [...newSelectedFeatures];
                
                // Clear all previous highlights first
                clearHighlights();
                
                // Highlight all newly selected features
                newSelectedFeatures.forEach(item => {
                    highlightFeature(item.feature);
                });
            }
            
            console.log('Final selected features:', selectedFeatures.length);
            
            // Update selection info
            updateSelectionInfo();
        }
        
        // Check if point is inside polygon (updated for LatLng objects)
        function isPointInPolygon(point, polygon) {
            const x = point.lat, y = point.lng;
            let inside = false;
            
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].lat, yi = polygon[i].lng;
                const xj = polygon[j].lat, yj = polygon[j].lng;
                
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // Strict point-in-polygon test for accurate selection
        function isPointInPolygonStrict(point, polygon) {
            const x = point.lat, y = point.lng;
            let inside = false;
            
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].lat, yi = polygon[i].lng;
                const xj = polygon[j].lat, yj = polygon[j].lng;
                
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // Check if bounds intersect with polygon (simplified)
        function boundsIntersectPolygon(bounds, polygon) {
            const corners = [
                bounds.getNorthWest(),
                bounds.getNorthEast(),
                bounds.getSouthEast(),
                bounds.getSouthWest()
            ];
            
            // Check if any corner is inside the polygon
            return corners.some(corner => isPointInPolygon(corner, polygon));
        }

        // Highlight selected feature
        function highlightFeature(feature) {
            // Store current style before highlighting
            if (!feature._originalStyle) {
                feature._originalStyle = {
                    color: feature.options.color,
                    weight: feature.options.weight,
                    opacity: feature.options.opacity,
                    fillColor: feature.options.fillColor,
                    fillOpacity: feature.options.fillOpacity
                };
            }
            
            const highlightStyle = {
                color: '#ffff00',
                weight: 4,
                opacity: 1,
                fillColor: '#ffff00',
                fillOpacity: 0.7
            };
            
            feature.setStyle(highlightStyle);
            highlightedLayers.push(feature);
        }

        // Clear all highlights
        function clearHighlights() {
            highlightedLayers.forEach(feature => {
                if (feature._originalStyle) {
                    feature.setStyle(feature._originalStyle);
                    delete feature._originalStyle;
                } else {
                    // Restore default style from the layer
                    const layerInfo = Array.from(layers.values()).find(layer => 
                        layer.layer.hasLayer && layer.layer.hasLayer(feature)
                    );
                    if (layerInfo && layerInfo.style) {
                        feature.setStyle(layerInfo.style);
                    }
                }
            });
            highlightedLayers = [];
        }

        // Clear selection
        function clearSelection() {
            selectedFeatures = [];
            clearHighlights();
            updateSelectionInfo();
            
            // Stop any current drawing and reset drawing state
            if (isDrawing || hasStartedDrawing) {
                isDrawing = false;
                hasStartedDrawing = false;
                
                if (currentDrawingLayer) {
                    map.removeLayer(currentDrawingLayer);
                    currentDrawingLayer = null;
                }
                if (currentFillLayer) {
                    map.removeLayer(currentFillLayer);
                    currentFillLayer = null;
                }
                drawingPath = [];
                
                // Only re-enable dragging if selection tool is not active
                if (!isSelectionActive) {
                    map.dragging.enable();
                }
            }
            
            // Update button states
            document.getElementById('clearSelection').disabled = true;
            document.getElementById('showStatistics').disabled = !activeSelectionLayerId;
        }

        // Update selection info panel
        function updateSelectionInfo() {
            const countNumberElement = document.getElementById('selectedCountNumber');
            const listElement = document.getElementById('selectedFeaturesList');
            const clearButton = document.getElementById('clearSelection');
            const statisticsButton = document.getElementById('showStatistics');
            
            const targetCount = selectedFeatures.length;
            const currentCount = parseInt(countNumberElement.textContent) || 0;
            
            // Update button states
            clearButton.disabled = targetCount === 0;
            // Statistics button is enabled when a layer is selected, not just when features are selected
            statisticsButton.disabled = !activeSelectionLayerId;
            
            // Only hide statistics panel if no layer is selected
            if (!activeSelectionLayerId) {
                document.getElementById('statisticsPanel').style.display = 'none';
                document.getElementById('statisticsResults').style.display = 'none';
                document.getElementById('statisticsResults').innerHTML = '';
            }
            
            // Animate the count change
            if (targetCount !== currentCount) {
                animateCounter(countNumberElement, currentCount, targetCount);
                
                // Trigger real-time statistics update when selection changes
                calculateAndUpdateStatistics();
            }
            
            // Hide feature list - we only show the count now
            listElement.style.display = 'none';
            listElement.innerHTML = '';
        }

        // Animate counter from current value to target value
        function animateCounter(element, startValue, endValue) {
            const duration = Math.min(800, Math.abs(endValue - startValue) * 40); // Max 800ms, min based on difference
            const startTime = performance.now();
            
            // Add counting animation class
            element.classList.add('counting');
            
            function updateCounter(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Use easeOutCubic for smooth animation
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                const currentValue = Math.round(startValue + (endValue - startValue) * easeProgress);
                
                element.textContent = currentValue;
                
                if (progress < 1) {
                    requestAnimationFrame(updateCounter);
                } else {
                    // Animation complete
                    element.textContent = endValue;
                    element.classList.remove('counting');
                }
            }
            
            requestAnimationFrame(updateCounter);
        }

        // Statistics Panel Functions
        function toggleStatisticsPanel() {
            const panel = document.getElementById('statisticsPanel');
            const isVisible = panel.style.display !== 'none';
            
            if (isVisible) {
                panel.style.display = 'none';
            } else {
                panel.style.display = 'block';
                populateFieldDropdown();
            }
        }

        function populateFieldDropdown() {
            const fieldSelect = document.getElementById('statisticsFieldSelect');
            const results = document.getElementById('statisticsResults');
            
            // Clear previous options and results
            fieldSelect.innerHTML = '<option value="">Select a field</option>';
            results.style.display = 'none';
            results.innerHTML = '';
            
            // Check if we have an active layer selected (not just selected features)
            if (!activeSelectionLayerId || !layers.has(activeSelectionLayerId)) {
                return;
            }
            
            const activeLayerInfo = layers.get(activeSelectionLayerId);
            if (!activeLayerInfo || !activeLayerInfo.data || !activeLayerInfo.data.features) {
                return;
            }
            
            // Collect all unique field names from the active layer's features
            const fieldNames = new Set();
            const numericFields = new Set();
            
            activeLayerInfo.data.features.forEach(feature => {
                if (feature.properties) {
                    Object.keys(feature.properties).forEach(key => {
                        fieldNames.add(key);
                        
                        // Check if field is numeric
                        const value = feature.properties[key];
                        if (typeof value === 'number' || (!isNaN(parseFloat(value)) && isFinite(value))) {
                            numericFields.add(key);
                        }
                    });
                }
            });
            
            // Add numeric fields to dropdown
            Array.from(numericFields).sort().forEach(field => {
                const option = document.createElement('option');
                option.value = field;
                option.textContent = field;
                fieldSelect.appendChild(option);
            });
            
            // Add non-numeric fields for count operation only
            Array.from(fieldNames).filter(field => !numericFields.has(field)).sort().forEach(field => {
                const option = document.createElement('option');
                option.value = field;
                option.textContent = `${field} (text - count only)`;
                option.dataset.isText = 'true';
                fieldSelect.appendChild(option);
            });
        }

        // Real-time statistics calculation and display as floating cards
        function calculateAndUpdateStatistics() {
            const fieldSelect = document.getElementById('statisticsFieldSelect');
            const selectedField = fieldSelect.value;
            const floatingContainer = document.getElementById('floatingStatisticsContainer');
            
            // Get selected operations from checkboxes
            const selectedOperations = Array.from(document.querySelectorAll('.statistics-operation-checkbox:checked'))
                .map(checkbox => checkbox.value);
            
            // Hide container if no field or operations selected
            if (!selectedField || selectedOperations.length === 0) {
                floatingContainer.style.display = 'none';
                clearFloatingStatisticsCards();
                return;
            }
            
            // Show container
            floatingContainer.style.display = 'block';
            
            const isTextField = fieldSelect.options[fieldSelect.selectedIndex].dataset.isText === 'true';
            const hasSelectedFeatures = selectedFeatures.length > 0;
            
            // Get currently displayed operations to compare
            const existingCards = Array.from(floatingContainer.querySelectorAll('.floating-statistics-card'));
            const existingOperations = existingCards.map(card => card.dataset.operation);
            
            // Remove cards for unchecked operations
            existingCards.forEach(card => {
                const operation = card.dataset.operation;
                if (!selectedOperations.includes(operation)) {
                    card.style.animation = 'fadeOutAtPosition 0.3s ease-in forwards';
                    setTimeout(() => {
                        if (card.parentNode) {
                            card.remove();
                        }
                    }, 300);
                }
            });
            
            // Process each selected operation and create floating cards
            selectedOperations.forEach((operation) => {
                // Always update existing cards to ensure real-time responsiveness
                if (existingOperations.includes(operation)) {
                    // Force update existing card content for every selection change
                    updateExistingCard(operation, selectedField, isTextField, hasSelectedFeatures);
                    return; // Only return from this iteration, continue with next operation
                }
                
                let resultValue = null;
                let isValidOperation = true;
                
                if (!hasSelectedFeatures) {
                    resultValue = "No features selected";
                } else {
                    // Extract values from selected features
                    const values = selectedFeatures.map(feature => {
                        const value = feature.properties[selectedField];
                        if (isTextField) return value;
                        return typeof value === 'number' ? value : parseFloat(value);
                    }).filter(val => val !== null && val !== undefined && (!isTextField ? !isNaN(val) : true));
                    
                    // Calculate based on operation
                    switch (operation) {
                        case 'sum':
                            if (isTextField) isValidOperation = false;
                            else resultValue = values.reduce((sum, val) => sum + val, 0);
                            break;
                        case 'average':
                            if (isTextField) isValidOperation = false;
                            else resultValue = values.length > 0 ? values.reduce((sum, val) => sum + val, 0) / values.length : 0;
                            break;
                        case 'mode':
                            if (values.length > 0) {
                                const frequency = {};
                                values.forEach(val => frequency[val] = (frequency[val] || 0) + 1);
                                const maxFreq = Math.max(...Object.values(frequency));
                                const modes = Object.keys(frequency).filter(val => frequency[val] === maxFreq);
                                resultValue = modes.length === 1 ? (isTextField ? modes[0] : parseFloat(modes[0])) : modes.join(', ');
                            } else resultValue = isTextField ? 'N/A' : 0;
                            break;
                        case 'min':
                            if (isTextField) isValidOperation = false;
                            else resultValue = values.length > 0 ? Math.min(...values) : 0;
                            break;
                        case 'max':
                            if (isTextField) isValidOperation = false;
                            else resultValue = values.length > 0 ? Math.max(...values) : 0;
                            break;
                    }
                }
                
                // Only display if it's a valid operation - create new card
                if (isValidOperation) {
                    createFloatingStatisticsCard(selectedField, operation, resultValue, hasSelectedFeatures ? selectedFeatures.length : 0, hasSelectedFeatures);
                }
            });
        }

        // Update content of existing card without recreating it
        function updateExistingCard(operation, field, isTextField, hasSelectedFeatures) {
            const floatingContainer = document.getElementById('floatingStatisticsContainer');
            const existingCard = floatingContainer.querySelector(`[data-operation="${operation}"]`);
            
            if (!existingCard) return;
            
            let resultValue = null;
            
            if (!hasSelectedFeatures) {
                resultValue = "No features selected";
            } else {
                // Extract values from selected features
                const values = selectedFeatures.map(feature => {
                    const value = feature.properties[field];
                    if (isTextField) return value;
                    return typeof value === 'number' ? value : parseFloat(value);
                }).filter(val => val !== null && val !== undefined && (!isTextField ? !isNaN(val) : true));
                
                // Calculate based on operation
                switch (operation) {
                    case 'sum':
                        if (isTextField) resultValue = 'N/A';
                        else resultValue = values.reduce((sum, val) => sum + val, 0);
                        break;
                    case 'average':
                        if (isTextField) resultValue = 'N/A';
                        else resultValue = values.length > 0 ? values.reduce((sum, val) => sum + val, 0) / values.length : 0;
                        break;
                    case 'mode':
                        if (values.length > 0) {
                            const frequency = {};
                            values.forEach(val => frequency[val] = (frequency[val] || 0) + 1);
                            const maxFreq = Math.max(...Object.values(frequency));
                            const modes = Object.keys(frequency).filter(val => frequency[val] === maxFreq);
                            resultValue = modes.length === 1 ? (isTextField ? modes[0] : parseFloat(modes[0])) : modes.join(', ');
                        } else resultValue = isTextField ? 'N/A' : 0;
                        break;
                    case 'min':
                        if (isTextField) resultValue = 'N/A';
                        else resultValue = values.length > 0 ? Math.min(...values) : 0;
                        break;
                    case 'max':
                        if (isTextField) resultValue = 'N/A';
                        else resultValue = values.length > 0 ? Math.max(...values) : 0;
                        break;
                    default:
                        resultValue = 'N/A';
                        break;
                }
            }
            
            // Update the card content - always force updates for responsiveness
            const fieldElement = existingCard.querySelector('.floating-statistics-field');
            const numberElement = existingCard.querySelector('.floating-statistics-number');
            const noFeaturesElement = existingCard.querySelector('.floating-statistics-no-features');
            
            if (resultValue === "No features selected") {
                if (fieldElement) fieldElement.textContent = `of "${field}"`;
                if (noFeaturesElement) noFeaturesElement.textContent = resultValue;
                if (numberElement) numberElement.style.display = 'none';
            } else {
                // If transitioning from "No features" to actual values, recreate the card structure
                if (noFeaturesElement && !numberElement) {
                    // Recreate the card with proper structure for displaying values
                    existingCard.innerHTML = `
                        <div class="floating-statistics-header">
                            <div class="floating-statistics-operation">${operation}</div>
                            <div class="floating-statistics-field">of "${field}" (${selectedFeatures.length} features)</div>
                        </div>
                        <div class="floating-statistics-number" data-target-value="${typeof resultValue === 'number' ? resultValue : 0}">0</div>
                        <div class="floating-statistics-label">${operation}</div>
                    `;
                    
                    // Get the new number element after recreation
                    const newNumberElement = existingCard.querySelector('.floating-statistics-number');
                    if (newNumberElement && typeof resultValue === 'number') {
                        setTimeout(() => {
                            animateFloatingCounter(newNumberElement, 0, resultValue, operation);
                        }, 50);
                    } else if (newNumberElement) {
                        const formattedValue = typeof resultValue === 'number' ? 
                            Number(resultValue.toFixed(4)).toLocaleString() : 
                            resultValue;
                        newNumberElement.textContent = formattedValue;
                    }
                } else {
                    // Normal update for existing structure - force update every time
                    if (fieldElement) fieldElement.textContent = `of "${field}" (${selectedFeatures.length} features)`;
                    if (noFeaturesElement) noFeaturesElement.style.display = 'none';
                    if (numberElement) {
                        numberElement.style.display = 'block';
                        
                        // Get current displayed value (parse from formatted text)
                        const currentDisplayText = numberElement.textContent.replace(/,/g, '');
                        const currentValue = parseFloat(currentDisplayText) || 0;
                        
                        if (typeof resultValue === 'number' && hasSelectedFeatures) {
                            // Force animation even for identical values to provide visual feedback
                            // This ensures updates are visible even when switching between features with same values
                            animateFloatingCounter(numberElement, currentValue, resultValue, operation);
                        } else {
                            // For non-numeric values, update immediately
                            const formattedValue = typeof resultValue === 'number' ? 
                                Number(resultValue.toFixed(4)).toLocaleString() : 
                                resultValue;
                            numberElement.textContent = formattedValue;
                        }
                    }
                }
            }
        }

        // Clear all floating statistics cards
        function clearFloatingStatisticsCards() {
            const floatingContainer = document.getElementById('floatingStatisticsContainer');
            
            // Animate out existing cards simultaneously for smooth transition
            const existingCards = floatingContainer.querySelectorAll('.floating-statistics-card');
            existingCards.forEach((card) => {
                card.style.animation = 'fadeOutAtPosition 0.3s ease-in forwards';
            });
            
            // Remove all cards after animation completes
            setTimeout(() => {
                existingCards.forEach(card => {
                    if (card.parentNode) {
                        card.remove();
                    }
                });
            }, 300);
        }

        // Create animated floating statistics cards
        function createFloatingStatisticsCard(field, operation, value, count, hasFeatures) {
            const floatingContainer = document.getElementById('floatingStatisticsContainer');
            
            // Format the result value
            let formattedValue;
            let isNoFeaturesMessage = false;
            
            if (value === "No features selected") {
                formattedValue = value;
                isNoFeaturesMessage = true;
            } else if (typeof value === 'number') {
                if (operation === 'count') {
                    formattedValue = value.toLocaleString();
                } else {
                    formattedValue = Number(value.toFixed(4)).toLocaleString();
                }
            } else {
                formattedValue = value;
            }
            
            // Create the floating card
            const card = document.createElement('div');
            card.className = 'floating-statistics-card';
            card.dataset.operation = operation;
            
            if (isNoFeaturesMessage) {
                // Special styling for "No features selected" message
                card.innerHTML = `
                    <div class="floating-statistics-header">
                        <div class="floating-statistics-operation">${operation}</div>
                        <div class="floating-statistics-field">of "${field}"</div>
                    </div>
                    <div class="floating-statistics-no-features">${formattedValue}</div>
                    <div class="floating-statistics-help-text">Select features on the map to calculate statistics</div>
                `;
            } else {
                // Normal result display with animated counter
                card.innerHTML = `
                    <div class="floating-statistics-header">
                        <div class="floating-statistics-operation">${operation}</div>
                        <div class="floating-statistics-field">of "${field}" (${count} features)</div>
                    </div>
                    <div class="floating-statistics-number" data-target-value="${typeof value === 'number' ? value : 0}">0</div>
                    <div class="floating-statistics-label">${operation}</div>
                `;
            }
            
            floatingContainer.appendChild(card);
            
            // Animate the counter if it's a numeric value and we have features
            if (typeof value === 'number' && hasFeatures) {
                const numberElement = card.querySelector('.floating-statistics-number');
                if (numberElement) {
                    setTimeout(() => {
                        animateFloatingCounter(numberElement, 0, value, operation);
                    }, 50); // Reduced delay for smoother appearance
                }
            } else if (hasFeatures && typeof value !== 'number') {
                // For non-numeric values, just show the value directly
                const numberElement = card.querySelector('.floating-statistics-number');
                if (numberElement) {
                    numberElement.textContent = formattedValue;
                }
            }
        }

        // Animate floating statistics counter
        function animateFloatingCounter(element, startValue, endValue, operation) {
            // Remove any existing counting class to prevent conflicts
            element.classList.remove('counting');
            
            // If values are the same or very close, update immediately without animation
            if (Math.abs(endValue - startValue) < 0.0001) {
                const finalValue = Number(endValue.toFixed(4)).toLocaleString();
                element.textContent = finalValue;
                return;
            }
            
            const duration = Math.min(800, Math.abs(endValue - startValue) * 40);
            const startTime = performance.now();
            
            // Add counting animation class
            element.classList.add('counting');
            
            function updateCounter(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Use easeOutCubic for smooth animation
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                const currentValue = startValue + (endValue - startValue) * easeProgress;
                
                // Format the value based on operation type
                let displayValue;
                displayValue = Number(currentValue.toFixed(4)).toLocaleString();
                
                element.textContent = displayValue;
                
                if (progress < 1) {
                    requestAnimationFrame(updateCounter);
                } else {
                    // Animation complete
                    const finalValue = Number(endValue.toFixed(4)).toLocaleString();
                    element.textContent = finalValue;
                    element.classList.remove('counting');
                }
            }
            
            requestAnimationFrame(updateCounter);
        }

        // Add Data button functionality and drag-and-drop support
        (function() {
            // Wait for DOM to be fully loaded
            function initializeFileHandling() {
                // Allowed file types
                const allowedTypes = [
                    'application/geo+json', 'application/json', 'application/vnd.google-earth.kml+xml',
                    '.geojson', '.kml', '.kmz'
                ];
                const maxSize = 50 * 1024 * 1024; // 50MB

                // Define cleanup effects function first
                function cleanupEffects() {
                    // Remove all potential classes that might cause blur/lock effects
                    document.body.classList.remove('overflow-hidden', 'backdrop-blur', 'z-50', 'modal-open');
                    document.documentElement.classList.remove('overflow-hidden', 'backdrop-blur', 'z-50', 'modal-open');
                    
                    // Reset map container
                    const mapEl = document.getElementById('map');
                    if (mapEl) {
                        mapEl.style.pointerEvents = '';
                        mapEl.style.overflow = '';
                        mapEl.style.filter = '';
                        mapEl.style.opacity = '';
                        mapEl.classList.remove('blur', 'backdrop-blur');
                    }
                    
                    // Remove any modal overlays
                    const overlays = document.querySelectorAll('.modal-overlay');
                    overlays.forEach(overlay => {
                        overlay.classList.add('hidden');
                        overlay.style.display = 'none';
                    });
                    
                    // Reset header effects
                    const header = document.querySelector('header');
                    if (header) {
                        header.style.filter = '';
                        header.style.backdropFilter = '';
                        header.style.webkitBackdropFilter = '';
                        header.style.opacity = '';
                        header.style.pointerEvents = '';
                        header.classList.remove('blur', 'backdrop-blur');
                    }
                    
                    // Reset any other potentially affected elements
                    const mainContent = document.querySelector('.main-content-container');
                    if (mainContent) {
                        mainContent.style.filter = '';
                        mainContent.style.opacity = '';
                        mainContent.style.pointerEvents = '';
                    }
                    
                    // Force a complete page repaint
                    document.body.style.transform = 'translateZ(0)';
                    setTimeout(() => {
                        document.body.style.transform = '';
                    }, 10);
                }

                // Function to process file (shared between button and drag-drop)
                function processFile(file, fromDragDrop = false) {
                    // Validate file type
                    const ext = file.name.split('.').pop().toLowerCase();
                    if (!["geojson","kml","kmz"].includes(ext)) {
                        alert('Invalid file type. Only .geojson, .kml, and .kmz files are allowed.');
                        return;
                    }
                    
                    // Validate file size
                    if (file.size > maxSize) {
                        alert('File size exceeds 50MB limit.');
                        return;
                    }

                    // Show loading indicator for drag-drop
                    if (fromDragDrop) {
                        console.log(`Loading ${file.name}...`);
                    }

                    // Read file
                    const reader = new FileReader();
                    reader.onload = function(evt) {
                        let geojson = null;
                        try {
                            if (ext === 'geojson' || ext === 'json') {
                                geojson = JSON.parse(evt.target.result);
                            } else if (ext === 'kml') {
                                // KML to GeoJSON
                                const parser = new DOMParser();
                                const kmlDoc = parser.parseFromString(evt.target.result, 'text/xml');
                                geojson = toGeoJSON.kml(kmlDoc);
                            } else if (ext === 'kmz') {
                                // KMZ to GeoJSON (requires JSZip and togeojson)
                                function processKMZ(arrayBuffer, fileName) {
                                    JSZip.loadAsync(arrayBuffer).then(zip => {
                                        let kmlFile = null;
                                        zip.forEach((relativePath, zipEntry) => {
                                            if (relativePath.toLowerCase().endsWith('.kml')) {
                                                kmlFile = zipEntry;
                                            }
                                        });
                                        if (!kmlFile) {
                                            alert('No KML file found inside KMZ.');
                                            return;
                                        }
                                        kmlFile.async('string').then(kmlText => {
                                            try {
                                                const parser = new DOMParser();
                                                const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
                                                const geojson = toGeoJSON.kml(kmlDoc);
                                                if (!geojson || geojson.type !== 'FeatureCollection' || !Array.isArray(geojson.features)) {
                                                    alert('Invalid or empty KML inside KMZ file.');
                                                    return;
                                                }
                                                addDataToMap(geojson, fileName);
                                            } catch (err) {
                                                alert('Unable to read this file. Please upload a valid KMZ.');
                                            }
                                        }).catch(() => {
                                            alert('Unable to read this file. Please upload a valid KMZ.');
                                        });
                                    }).catch(() => {
                                        alert('Unable to read this file. Please upload a valid KMZ.');
                                    });
                                }
                                if (typeof JSZip === 'undefined') {
                                    const script = document.createElement('script');
                                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                                    script.onload = () => processKMZ(evt.target.result, file.name);
                                    document.body.appendChild(script);
                                } else {
                                    processKMZ(evt.target.result, file.name);
                                }
                                return;
                            }
                        } catch (err) {
                            alert('Error parsing file. Please ensure it is a valid GeoJSON or KML/KMZ file.');
                            return;
                        }
                        if (!geojson || !geojson.type || geojson.type !== 'FeatureCollection') {
                            alert('Invalid or empty GeoJSON/KML file.');
                            return;
                        }
                        addDataToMap(geojson, file.name);
                        
                        // Restore map interactivity and force re-render
                        setTimeout(function() {
                            cleanupEffects();
                            if (typeof map !== 'undefined' && map) {
                                map.invalidateSize();
                            }
                        }, 100);
                    };
                    
                    if (ext === 'kmz') {
                        reader.readAsArrayBuffer(file);
                    } else {
                        reader.readAsText(file);
                    }
                }
                
                // Make processFile available globally for debugging
                window.processFile = processFile;

                // Create a hidden file input for Add Data button with improved positioning
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.geojson,.kml,.kmz,application/geo+json,application/json,application/vnd.google-earth.kml+xml';
                
                // FIXED: More robust hidden styling to prevent conflicts
                fileInput.style.cssText = `
                    position: absolute !important;
                    left: -9999px !important;
                    top: -9999px !important;
                    width: 1px !important;
                    height: 1px !important;
                    opacity: 0 !important;
                    z-index: -1 !important;
                    visibility: hidden !important;
                    pointer-events: none !important;
                    overflow: hidden !important;
                    border: none !important;
                    background: transparent !important;
                    outline: none !important;
                    margin: 0 !important;
                    padding: 0 !important;
                `;
                fileInput.multiple = false;
                fileInput.id = 'hidden-file-input-for-add-data';
                fileInput.tabIndex = -1;
                
                // FIXED: Safe DOM insertion with error handling
                try {
                    document.body.appendChild(fileInput);
                    console.log('📁 File input successfully added to DOM');
                } catch (error) {
                    console.error('❌ Failed to add file input to DOM:', error);
                    return; // Exit if we can't create the file input
                }
                
                // Verify it was added
                const addedInput = document.getElementById('hidden-file-input-for-add-data');
                if (!addedInput) {
                    console.error('❌ File input was not properly added to DOM');
                    return;
                }
                
                console.log('📁 File input created and verified in DOM');
                console.log('📁 File input parent:', addedInput.parentNode?.tagName);
                console.log('📁 File input position in body:', Array.from(document.body.children).indexOf(addedInput));

                // File input change handler with enhanced debugging
                fileInput.addEventListener('change', function(e) {
                    console.log('📁 File input change event triggered');
                    console.log('📁 Files selected:', e.target.files?.length || 0);
                    console.log('📁 Event target:', e.target);
                    console.log('📁 Event type:', e.type);
                    
                    const file = e.target.files?.[0];
                    
                    // Clean up effects regardless
                    cleanupEffects();
                    
                    // If no file selected (dialog was cancelled), return
                    if (!file) {
                        console.log('� No file selected (dialog cancelled or no files)');
                        return;
                    }

                    console.log('✅ File selected successfully:', {
                        name: file.name,
                        size: `${(file.size / 1024 / 1024).toFixed(2)} MB`,
                        type: file.type,
                        lastModified: new Date(file.lastModified).toISOString()
                    });
                    
                    // Process the selected file
                    processFile(file, false);
                }, { passive: false });

                // Add Data button click handler with comprehensive search and debugging
                let addDataButton = document.getElementById('addDataBtn');
                
                // If not found by ID, try multiple approaches
                if (!addDataButton) {
                    // Try finding by text content
                    addDataButton = Array.from(document.querySelectorAll('button')).find(btn => 
                        btn.textContent.trim().toLowerCase().includes('add data') || 
                        btn.textContent.trim().toLowerCase().includes('adddata')
                    );
                }
                
                // If still not found, try finding by class or other attributes
                if (!addDataButton) {
                    addDataButton = document.querySelector('[class*="add-data"], [class*="adddata"], [data-action="add-data"]');
                }
                
                console.log('🔍 Searching for Add Data button...');
                console.log('Button found:', !!addDataButton);
                console.log('Button element:', addDataButton);
                console.log('Button ID:', addDataButton?.id);
                console.log('Button classes:', addDataButton?.className);
                console.log('Button text:', addDataButton?.textContent?.trim());
                
                if (addDataButton) {
                    console.log('✅ Add Data button located successfully!');
                    
                    // FIXED: Use event delegation instead of cloning button
                    // This prevents issues with DOM replacement
                    document.addEventListener('click', function(e) {
                        if (e.target && (e.target.id === 'addDataBtn' || e.target.closest('#addDataBtn'))) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            
                            console.log('🔥 Add Data button clicked via event delegation!'); 
                            console.log('File input element exists:', !!fileInput);
                            console.log('File input in DOM:', !!fileInput.parentNode);
                            
                            // Ensure file input is properly reset
                            fileInput.value = '';
                            
                            // FIXED: Simplified and reliable file dialog trigger
                            try {
                                fileInput.style.display = 'block';
                                fileInput.style.position = 'fixed';
                                fileInput.style.top = '50%';
                                fileInput.style.left = '50%';
                                fileInput.style.zIndex = '999999';
                                fileInput.style.opacity = '0.01';
                                fileInput.focus();
                                fileInput.click();
                                
                                // Hide it again after click
                                setTimeout(() => {
                                    fileInput.style.display = 'none';
                                    fileInput.style.position = 'absolute';
                                    fileInput.style.top = '-9999px';
                                    fileInput.style.left = '-9999px';
                                    fileInput.style.opacity = '0';
                                    fileInput.style.zIndex = '-1';
                                }, 100);
                                
                                console.log('✅ File dialog triggered successfully');
                            } catch (error) {
                                console.error('❌ File dialog failed:', error);
                                // Fallback: Create fresh input
                                const fallbackInput = document.createElement('input');
                                fallbackInput.type = 'file';
                                fallbackInput.accept = '.geojson,.kml,.kmz';
                                fallbackInput.style.cssText = 'position: fixed; top: 50%; left: 50%; z-index: 999999; opacity: 0.1;';
                                
                                fallbackInput.addEventListener('change', function(e) {
                                    const file = e.target.files[0];
                                    if (file) {
                                        console.log('✅ Fallback file selected:', file.name);
                                        processFile(file, false);
                                    }
                                    document.body.removeChild(fallbackInput);
                                });
                                
                                document.body.appendChild(fallbackInput);
                                fallbackInput.click();
                                
                                console.log('✅ Used fallback method successfully');
                            }
                        }
                    });
                    
                    console.log('✅ Add Data button event delegation attached successfully');
                    
                    // Add visual feedback for debugging
                    addDataButton.style.outline = '2px solid #22c55e';
                    setTimeout(() => {
                        if (addDataButton && addDataButton.style) {
                            addDataButton.style.outline = '';
                        }
                    }, 2000);
                    
                } else {
                    console.error('❌ Add Data button not found anywhere in the DOM!');
                    console.log('📋 All available buttons:');
                    document.querySelectorAll('button').forEach((btn, index) => {
                        console.log(`Button ${index}:`, {
                            id: btn.id || 'no-id',
                            text: btn.textContent?.trim() || 'no-text',
                            classes: btn.className || 'no-classes'
                        });
                    });
                    
                    // Create manual test function as fallback
                    window.manualAddData = function() {
                        console.log('🔧 Manual Add Data function triggered');
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.accept = '.geojson,.kml,.kmz';
                        input.onchange = function(e) {
                            const file = e.target.files[0];
                            if (file) {
                                console.log('Manual file selected:', file.name);
                                processFile(file, false);
                            }
                        };
                        input.click();
                    };
                    console.log('💡 Use window.manualAddData() in console as a workaround');
                }

                // Add manual trigger for debugging (remove this later)
                window.testAddDataButton = function() {
                    console.log('🧪 Manual test triggered');
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.geojson,.kml,.kmz';
                    input.onchange = function(e) {
                        const file = e.target.files[0];
                        if (file) {
                            console.log('Manual test file selected:', file.name);
                            processFile(file, false);
                        }
                    };
                    input.click();
                };

                // Enhanced drag and drop functionality with comprehensive event prevention
                let dragCounter = 0;
                let dropZoneVisible = false;

                // Create drop zone overlay
                const dropZone = document.createElement('div');
                dropZone.id = 'file-drop-zone';
                dropZone.innerHTML = `
                    <div class="drop-zone-content">
                        <div class="drop-zone-icon">📁</div>
                        <div class="drop-zone-text">Drop GeoJSON, KML, or KMZ files here</div>
                        <div class="drop-zone-subtext">Supported formats: .geojson, .kml, .kmz (Max: 50MB)</div>
                    </div>
                `;
                dropZone.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    backdrop-filter: blur(5px);
                    -webkit-backdrop-filter: blur(5px);
                    display: none;
                    justify-content: center;
                    align-items: center;
                    z-index: 99999;
                    pointer-events: none;
                    user-select: none;
                `;
                
                dropZone.querySelector('.drop-zone-content').style.cssText = `
                    background: white;
                    padding: 40px;
                    border-radius: 12px;
                    text-align: center;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                    border: 3px dashed #3b82f6;
                    max-width: 400px;
                    pointer-events: none;
                    user-select: none;
                `;
                
                dropZone.querySelector('.drop-zone-icon').style.cssText = `
                    font-size: 48px;
                    margin-bottom: 16px;
                    user-select: none;
                `;
                
                dropZone.querySelector('.drop-zone-text').style.cssText = `
                    font-size: 18px;
                    font-weight: 600;
                    color: #1f2937;
                    margin-bottom: 8px;
                    user-select: none;
                `;
                
                dropZone.querySelector('.drop-zone-subtext').style.cssText = `
                    font-size: 14px;
                    color: #6b7280;
                    user-select: none;
                `;
                
                document.body.appendChild(dropZone);

                // Show drop zone
                function showDropZone() {
                    if (!dropZoneVisible) {
                        dropZone.style.display = 'flex';
                        dropZoneVisible = true;
                        console.log('🎯 Drop zone shown');
                    }
                }

                // Hide drop zone
                function hideDropZone() {
                    if (dropZoneVisible) {
                        dropZone.style.display = 'none';
                        dropZoneVisible = false;
                        dragCounter = 0;
                        console.log('🎯 Drop zone hidden');
                    }
                }

                // Comprehensive event prevention for drag and drop
                const dragEvents = ['dragenter', 'dragover', 'dragleave', 'drop'];
                
                // Prevent default behaviors on the entire document
                dragEvents.forEach(eventName => {
                    document.addEventListener(eventName, function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }, { passive: false, capture: true });
                    
                    window.addEventListener(eventName, function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }, { passive: false, capture: true });
                });

                // Prevent file opening in browser
                window.addEventListener('beforeunload', function(e) {
                    // This helps prevent accidental navigation
                    if (dragCounter > 0) {
                        e.preventDefault();
                        e.returnValue = '';
                        return '';
                    }
                });

                document.addEventListener('dragenter', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('📥 Drag enter detected');
                    
                    dragCounter++;
                    
                    // Only show for file drags
                    if (e.dataTransfer && e.dataTransfer.types && e.dataTransfer.types.includes('Files')) {
                        console.log('📥 File drag detected, showing drop zone');
                        showDropZone();
                    }
                }, { passive: false });

                document.addEventListener('dragleave', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    dragCounter--;
                    console.log('📤 Drag leave, counter:', dragCounter);
                    
                    if (dragCounter <= 0) {
                        hideDropZone();
                    }
                }, { passive: false });

                document.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (e.dataTransfer && e.dataTransfer.types && e.dataTransfer.types.includes('Files')) {
                        e.dataTransfer.dropEffect = 'copy';
                        console.log('📥 Drag over with files');
                    } else {
                        e.dataTransfer.dropEffect = 'none';
                    }
                }, { passive: false });

                document.addEventListener('drop', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('📦 Drop event triggered');
                    
                    hideDropZone();
                    
                    if (!e.dataTransfer || !e.dataTransfer.files || e.dataTransfer.files.length === 0) {
                        console.log('❌ No dataTransfer or files found');
                        return;
                    }
                    
                    const files = Array.from(e.dataTransfer.files);
                    console.log('📦 Files dropped:', files.length);
                    console.log('📦 File details:', files.map(f => ({ name: f.name, size: f.size, type: f.type })));
                    
                    const validFiles = files.filter(file => {
                        const ext = file.name.split('.').pop().toLowerCase();
                        return ["geojson", "kml", "kmz"].includes(ext);
                    });

                    console.log('📦 Valid files to process:', validFiles.length);

                    if (validFiles.length === 0) {
                        if (files.length > 0) {
                            alert('Please drop valid GeoJSON, KML, or KMZ files.');
                        }
                        return;
                    }

                    // Process each valid file
                    validFiles.forEach((file, index) => {
                        console.log(`📦 Processing file ${index + 1}/${validFiles.length}: ${file.name}`);
                        processFile(file, true);
                    });

                    if (validFiles.length !== files.length) {
                        const skipped = files.length - validFiles.length;
                        alert(`${validFiles.length} file(s) processed successfully. ${skipped} file(s) skipped (invalid format).`);
                    } else if (validFiles.length > 0) {
                        console.log(`✅ All ${validFiles.length} files processed successfully`);
                    }
                }, { passive: false });
            }

            // Initialize when DOM is ready - FIXED VERSION
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function() {
                    // Additional delay to ensure all elements are rendered
                    setTimeout(initializeFileHandling, 100);
                });
            } else {
                // Document already loaded, but add small delay to ensure DOM is stable
                setTimeout(initializeFileHandling, 100);
            }
        })();

        // Reusable safeBind helper for debugging event listeners
        window.safeBind = function(id, event, callback) {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener(event, callback);
                console.log(`✅ Event listener attached: ${id}.${event}`);
                return true;
            } else {
                console.warn(`⚠️ Element not found for binding: ${id}.${event}`);
                return false;
            }
        };

        // Quick test function to verify Add Data button works
        window.testAddDataButton = function() {
            const button = document.getElementById('addDataBtn');
            if (button) {
                console.log('🧪 Testing Add Data button...');
                button.click();
                return true;
            } else {
                console.error('❌ Add Data button not found');
                return false;
            }
        };

        console.log('🚀 File handling system loaded - use window.testAddDataButton() to test manually');

        // Global openAddDataModal function for compatibility with inline onclick handlers
        window.openAddDataModal = function() {
            console.log('🔧 Global openAddDataModal function called');
            const button = document.getElementById('addDataBtn');
            if (button) {
                button.click();
            } else {
                console.error('❌ Add Data button not found for global function');
                // Direct file dialog as fallback
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.geojson,.kml,.kmz';
                input.style.cssText = 'position: fixed; top: 50%; left: 50%; z-index: 999999; opacity: 0.1;';
                input.onchange = function(e) {
                    const file = e.target.files[0];
                    if (file && window.processFile) {
                        window.processFile(file, false);
                    }
                    document.body.removeChild(input);
                };
                document.body.appendChild(input);
                input.click();
            }
        };

        // Enhanced validation function
        window.validateFileUploadSystem = function() {
            console.log('🔧 Validating file upload system...');
            
            const results = {
                button: !!document.getElementById('addDataBtn'),
                hiddenInput: !!document.getElementById('hidden-file-input-for-add-data'),
                dropZone: !!document.getElementById('file-drop-zone'),
                processFile: typeof window.processFile === 'function',
                openAddDataModal: typeof window.openAddDataModal === 'function',
                libraries: {
                    toGeoJSON: typeof toGeoJSON !== 'undefined',
                    JSZip: typeof JSZip !== 'undefined',
                    addDataToMap: typeof addDataToMap !== 'undefined'
                }
            };
            
            console.log('📊 Validation results:', results);
            
            // Check for CSS issues
            const button = document.getElementById('addDataBtn');
            if (button) {
                const style = window.getComputedStyle(button);
                const cssIssues = {
                    pointerEvents: style.pointerEvents,
                    display: style.display,
                    visibility: style.visibility,
                    zIndex: style.zIndex,
                    position: style.position
                };
                console.log('🎨 Button CSS properties:', cssIssues);
                
                // Check if button is covered
                const rect = button.getBoundingClientRect();
                const elementAtPoint = document.elementFromPoint(rect.left + rect.width/2, rect.top + rect.height/2);
                console.log('👆 Element at button center:', elementAtPoint);
                console.log('🔍 Is button accessible at click point:', elementAtPoint === button || button.contains(elementAtPoint));
            }
            
            return results;
        };

    </script>

    <!-- HTML2Canvas for map export -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
</body>
</html>
