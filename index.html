<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aera Link</title>
    
    <!-- Tailwind CSS (Development version) -->
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio,line-clamp"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // Custom colors for the app
                    }
                }
            }
        }
    </script>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Leaflet Draw CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    
    <!-- Leaflet Sidebar CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-sidebar-v2@3.2.3/css/leaflet-sidebar.min.css" />
    
    <!-- Heroicons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Avenir Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Ensure the root container stretches to 100vh */
        body {
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .header-container {
            flex: 0 0 auto; /* Header takes only as much space as needed */
        }

        .main-content-container {
            flex: 1 1 auto; /* Main content fills the remaining space */
            display: flex;
            overflow: hidden;
        }

        #map {
            flex: 1 1 auto; /* Map container fills available space */
            position: relative;
        }

        #sidebar {
            flex: 0 0 300px; /* Sidebar has a fixed width */
            overflow-y: auto; /* Enable scrolling for overflowing content */
            z-index: 1200;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Avenir', sans-serif;
        }
        
        .glass-effect {
            background: rgba(17, 25, 40, 0.75);
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.125);
        }
        
        .glass-panel {
            background: rgba(31, 41, 55, 0.8);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(75, 85, 99, 0.3);
        }
        
        .btn-glass {
            background: rgba(20, 184, 166, 0.2);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(20, 184, 166, 0.3);
            transition: all 0.3s ease;
        }
        
        .btn-glass:hover {
            background: rgba(20, 184, 166, 0.4);
            border-color: rgba(20, 184, 166, 0.5);
        }
        
        .leaflet-sidebar {
            background: rgba(17, 25, 40, 0.9) !important;
            backdrop-filter: blur(16px) !important;
            border-right: 1px solid rgba(75, 85, 99, 0.3) !important;
        }
        
        .leaflet-sidebar-content {
            background: transparent !important;
        }
        
        /* Fix sidebar header vertical alignment */
        .leaflet-sidebar-header {
            display: flex !important;
            align-items: center !important;
            justify-content: space-between !important;
            position: relative !important;
            padding: 0.75rem 1rem !important;
            margin-bottom: 1rem !important;
            line-height: 1 !important;
            min-height: 3rem !important;
        }
        
        .leaflet-sidebar-close {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            width: 2rem !important;
            height: 2rem !important;
            border-radius: 0.375rem !important;
            transition: all 0.2s ease !important;
            cursor: pointer !important;
            color: rgba(255, 255, 255, 0.8) !important;
            margin-left: auto !important;
        }
        
        .leaflet-sidebar-close:hover {
            background: rgba(255, 255, 255, 0.1) !important;
            color: white !important;
        }
        
        .leaflet-sidebar-close i {
            font-size: 1rem !important;
            line-height: 1 !important;
        }
        
        .leaflet-control-container .leaflet-top.leaflet-right {
            top: 80px !important;
        }
        
        /* Pin zoom controls inside the map container, above the OS taskbar, and not overlapping the sidebar */
        .leaflet-control-zoom {
            position: absolute !important;
            right: 24px;
            bottom: 24px;
            z-index: 1100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
        }
        
        /* Prevent sidebar from overlapping zoom controls */
        #sidebar {
            z-index: 1200;
        }
        
        .layer-item {
            border: 1px solid rgba(75, 85, 99, 0.3);
            background: rgba(31, 41, 55, 0.6);
        }
        
        /* Drag-and-drop styles only for layer items */
        .layer-item[draggable="true"] {
            cursor: move;
        }
        
        .layer-item.dragging {
            opacity: 0.5;
            transform: scale(0.95);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .layer-item.drag-over {
            border: 2px dashed #14b8a6;
            background: rgba(20, 184, 166, 0.15);
            transform: scale(1.02);
            transition: all 0.2s ease;
        }
        
        .layer-drag-handle {
            color: #9ca3af;
            cursor: grab;
        }
        
        .layer-drag-handle:active {
            cursor: grabbing;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .modal-overlay {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }
        
        /* Custom Confirmation Modal Styles */
        .confirm-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(20, 28, 38, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .confirm-modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        
        .confirm-modal {
            background: rgba(31, 41, 55, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(75, 85, 99, 0.3);
            border-radius: 1rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            max-width: 360px;
            width: 90%;
            padding: 2rem;
            transform: scale(0.9) translateY(20px);
            transition: all 0.3s ease;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }
        
        .confirm-modal-overlay.show .confirm-modal {
            transform: scale(1) translateY(0);
        }
        
        .confirm-modal-icon {
            text-align: center;
            margin-bottom: 1rem;
            font-size: 2.5rem;
            line-height: 1;
        }
        
        .confirm-modal-icon.success {
            color: #10b981;
        }
        
        .confirm-modal-icon.warning {
            color: #f59e0b;
        }
        
        .confirm-modal-icon.error {
            color: #ef4444;
        }
        
        .confirm-modal-icon.info {
            color: #3b82f6;
        }
        
        .confirm-modal-icon.question {
            color: #14b8a6;
        }
        
        .confirm-modal-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #f9fafb;
            margin-bottom: 0.75rem;
            text-align: center;
        }
        
        .confirm-modal-message {
            color: #d1d5db;
            font-size: 0.875rem;
            line-height: 1.5;
            text-align: center;
            margin-bottom: 2rem;
            white-space: pre-line;
        }
        
        .confirm-modal-input-container {
            margin-bottom: 2rem;
        }
        
        .confirm-modal-input {
            width: 100%;
            padding: 0.75rem 1rem;
            background: rgba(55, 65, 81, 0.8);
            border: 1px solid rgba(75, 85, 99, 0.6);
            border-radius: 0.5rem;
            color: white;
            font-size: 0.875rem;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            transition: all 0.3s ease;
        }
        
        .confirm-modal-input:focus {
            outline: none;
            border-color: #14b8a6;
            box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.2);
            background: rgba(55, 65, 81, 1);
        }
        
        .confirm-modal-input::placeholder {
            color: #9ca3af;
        }
        
        .confirm-modal-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
        }
        
        .confirm-modal-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 80px;
        }
        
        .confirm-modal-btn-ok {
            background: linear-gradient(135deg, #14b8a6, #059669);
            color: white;
            box-shadow: 0 4px 6px -1px rgba(20, 184, 166, 0.3);
        }
        
        .confirm-modal-btn-ok:hover {
            background: linear-gradient(135deg, #0f766e, #047857);
            transform: translateY(-1px);
            box-shadow: 0 6px 8px -1px rgba(20, 184, 166, 0.4);
        }
        
        .confirm-modal-btn-cancel {
            background: rgba(75, 85, 99, 0.8);
            color: #d1d5db;
            border: 1px solid rgba(75, 85, 99, 0.4);
        }
        
        .confirm-modal-btn-cancel:hover {
            background: rgba(55, 65, 81, 0.9);
            color: white;
            transform: translateY(-1px);
        }
        
        .progress-bar {
            background: linear-gradient(90deg, #14b8a6 0%, #06b6d4 100%);
        }
        
        .tooltip {
            position: relative;
        }
        
        .tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
        }
        
        /* Custom popup styling for better UX */
        .custom-popup .leaflet-popup-content-wrapper {
            max-height: 300px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .custom-popup .leaflet-popup-content {
            max-width: 400px;
            word-wrap: break-word;
            margin: 8px 12px;
        }
        
        /* Ensure popup stays within viewport */
        .leaflet-popup {
            max-width: 90vw !important;
        }

        /* Custom Context Menu Styles */
        .custom-context-menu {
            position: fixed;
            background: rgba(31, 41, 55, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(75, 85, 99, 0.8);
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            z-index: 10000;
            min-width: 160px;
            padding: 4px 0;
            font-size: 14px;
            display: none;
        }

        .context-menu-item {
            padding: 8px 16px;
            color: #ffffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            transition: background-color 0.15s ease;
        }

        .context-menu-item:hover {
            background-color: rgba(20, 184, 166, 0.2);
        }

        .context-menu-item i {
            margin-right: 8px;
            width: 16px;
            text-align: center;
            color: #14b8a6;
        }

        .context-menu-item.disabled {
            color: #6b7280;
            cursor: not-allowed;
        }

        .context-menu-item.disabled:hover {
            background-color: transparent;
        }

        .context-menu-item.disabled i {
            color: #6b7280;
        }

        .context-menu-separator {
            height: 1px;
            background-color: rgba(75, 85, 99, 0.5);
            margin: 4px 0;
        }

        /* Context Menu Submenu Styles */
        .context-menu-parent {
            position: relative;
        }

        .context-menu-arrow {
            margin-left: auto;
            margin-right: 0;
            font-size: 12px;
            opacity: 0.7;
        }

        .context-submenu {
            position: absolute;
            left: 100%;
            top: 0;
            background: rgba(31, 41, 55, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(75, 85, 99, 0.8);
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            min-width: 200px;
            max-width: 250px;
            padding: 4px 0;
            display: none;
            z-index: 10001;
            max-height: 400px;
            overflow-y: auto;
        }

        .context-menu-parent:hover .context-submenu {
            display: block;
        }

        /* Group Header Styles */
        .context-menu-group-header {
            padding: 8px 16px 4px 16px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            color: #9ca3af;
            letter-spacing: 0.5px;
            border-bottom: 1px solid rgba(75, 85, 99, 0.3);
            margin-bottom: 4px;
            background: rgba(17, 24, 39, 0.5);
        }

        /* Satellite Options with Label Toggle */
        .satellite-option {
            flex-direction: column;
            align-items: flex-start;
            padding: 8px 16px;
        }

        .satellite-option > span {
            display: flex;
            align-items: center;
            width: 100%;
        }

        .label-toggle {
            display: flex;
            align-items: center;
            margin-top: 6px;
            margin-left: 26px;
            font-size: 12px;
            cursor: pointer;
        }

        .label-checkbox {
            margin-right: 6px;
            cursor: pointer;
        }

        .label-text {
            color: #10b981;
            font-size: 11px;
        }

        .satellite-option:hover .label-text {
            color: #34d399;
        }

        .context-menu-parent:hover .context-submenu {
            display: block;
        }

        .basemap-option {
            white-space: nowrap;
            font-size: 13px;
        }

        .basemap-option:hover {
            background-color: rgba(20, 184, 166, 0.3);
        }

        /* Scrollbar styling for submenu */
        .context-submenu::-webkit-scrollbar {
            width: 6px;
        }

        .context-submenu::-webkit-scrollbar-track {
            background: rgba(75, 85, 99, 0.3);
            border-radius: 3px;
        }

        .context-submenu::-webkit-scrollbar-thumb {
            background: rgba(20, 184, 166, 0.5);
            border-radius: 3px;
        }

        .context-submenu::-webkit-scrollbar-thumb:hover {
            background: rgba(20, 184, 166, 0.7);
        }

        /* Draggable Symbology Editor Styles */
        .symbology-editor-draggable {
            position: fixed;
            background: rgba(31, 41, 55, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(75, 85, 99, 0.8);
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            z-index: 9999;
            max-width: 400px;
            min-width: 320px;
            max-height: calc(100vh - 6rem);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .symbology-editor-header {
            background: rgba(55, 65, 81, 0.9);
            padding: 16px;
            border-bottom: 1px solid rgba(75, 85, 99, 0.8);
            border-radius: 8px 8px 0 0;
            cursor: move;
            user-select: none;
        }

        .symbology-editor-header:hover {
            background: rgba(55, 65, 81, 1);
        }

        .symbology-editor-content {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }

        .opacity-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #374151;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .opacity-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #14b8a6;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .opacity-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #14b8a6;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .opacity-value {
            font-size: 12px;
            color: #9ca3af;
            text-align: center;
            margin-top: 4px;
        }

        /* Login Page Styles */
        #loginContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('Home.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        #loginContainer::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            z-index: -1;
        }

        .login-card {
            background: rgba(31, 41, 55, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 3rem;
            min-width: 400px;
            max-width: 450px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.1);
            animation: fadeInUp 0.6s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .login-header {
            text-align: center;
            margin-bottom: 2.5rem;
        }

        .login-title {
            font-size: 2.5rem;
            font-weight: 700;
            color: #14b8a6;
            margin-bottom: 0.5rem;
            font-family: 'Inter', sans-serif;
        }

        .login-subtitle {
            font-size: 1rem;
            color: #9ca3af;
            font-weight: 400;
        }

        .login-form {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .password-input-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .password-toggle-btn {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.3s ease;
            z-index: 10;
        }

        .password-toggle-btn:hover {
            color: #14b8a6;
        }

        .password-toggle-btn i {
            font-size: 16px;
        }

        .form-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #e5e7eb;
        }

        .form-input {
            padding: 1rem;
            background: rgba(55, 65, 81, 0.8);
            border: 1px solid rgba(75, 85, 99, 0.6);
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            transition: all 0.3s ease;
            width: 100%;
        }

        .form-input.has-toggle {
            padding-right: 3rem;
        }

        .form-input:focus {
            outline: none;
            border-color: #14b8a6;
            box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.2);
            background: rgba(55, 65, 81, 1);
        }

        .form-input::placeholder {
            color: #9ca3af;
        }

        .login-button {
            padding: 1rem 2rem;
            background: linear-gradient(135deg, #14b8a6 0%, #0891b2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 1rem;
        }

        .login-button:hover:not(:disabled) {
            background: linear-gradient(135deg, #0891b2 0%, #14b8a6 100%);
            transform: translateY(-1px);
            box-shadow: 0 8px 25px rgba(20, 184, 166, 0.3);
        }

        .login-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .error-message {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            color: #fecaca;
            font-size: 0.875rem;
            margin-bottom: 1rem;
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .forgot-password {
            text-align: center;
            margin-top: 1.5rem;
        }

        .forgot-password a {
            color: #14b8a6;
            font-size: 0.875rem;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .forgot-password a:hover {
            color: #0891b2;
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 0.5rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-left: 1rem;
        }

        .user-email {
            color: #e5e7eb;
            font-size: 0.875rem;
        }

        .logout-button {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            color: #fecaca;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .logout-button:hover {
            background: rgba(239, 68, 68, 0.3);
        }

        /* Notification animations */
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        /* Selection Counter Animations and Styling */
        .selection-counter-card {
            background: rgba(31, 41, 55, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(75, 85, 99, 0.3);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
            padding: 1.5rem;
            text-align: center;
            transition: all 0.3s ease;
        }

        .selection-counter-card:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
            transform: translateY(-1px);
        }

        .selection-counter-number {
            font-size: 2.5rem;
            font-weight: 700;
            color: #14b8a6;
            margin-bottom: 0.25rem;
            font-family: 'Inter', monospace;
            text-shadow: 0 0 20px rgba(20, 184, 166, 0.4);
            transition: all 0.2s ease;
        }

        .selection-counter-number.counting {
            animation: pulse-glow 0.15s ease-in-out;
        }

        .selection-counter-label {
            font-size: 0.875rem;
            color: #9ca3af;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        @keyframes pulse-glow {
            0% {
                text-shadow: 0 0 20px rgba(20, 184, 166, 0.4);
                transform: scale(1);
            }
            50% {
                text-shadow: 0 0 30px rgba(20, 184, 166, 0.8);
                transform: scale(1.05);
            }
            100% {
                text-shadow: 0 0 20px rgba(20, 184, 166, 0.4);
                transform: scale(1);
            }
        }

        @keyframes count-up {
            0% {
                opacity: 0.7;
                transform: scale(0.9);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Statistics Result Cards */
        .statistics-result-card {
            background: linear-gradient(135deg, rgba(31, 41, 55, 0.95), rgba(55, 65, 81, 0.9));
            backdrop-filter: blur(12px);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
            padding: 1rem;
            margin-bottom: 0.75rem;
            transition: all 0.3s ease;
            animation: fade-slide-in 0.4s ease-out;
        }

        .statistics-result-card:hover {
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.2);
            transform: translateY(-1px);
            border-color: rgba(59, 130, 246, 0.4);
        }

        .statistics-result-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .statistics-result-operation {
            font-size: 0.875rem;
            font-weight: 600;
            color: #60a5fa;
            text-transform: capitalize;
        }

        .statistics-result-field {
            font-size: 0.75rem;
            color: #9ca3af;
            font-weight: 400;
        }

        .statistics-result-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #10b981;
            font-family: 'Inter', monospace;
            text-shadow: 0 0 15px rgba(16, 185, 129, 0.3);
            animation: result-glow 0.6s ease-out;
        }

        @keyframes fade-slide-in {
            0% {
                opacity: 0;
                transform: translateY(-10px) scale(0.95);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes result-glow {
            0% {
                text-shadow: 0 0 15px rgba(16, 185, 129, 0.3);
                transform: scale(1);
            }
            50% {
                text-shadow: 0 0 25px rgba(16, 185, 129, 0.6);
                transform: scale(1.02);
            }
            100% {
                text-shadow: 0 0 15px rgba(16, 185, 129, 0.3);
                transform: scale(1);
            }
        }

        /* Statistics Operation Checkboxes */
        .statistics-operation-checkbox {
            width: 1rem;
            height: 1rem;
            border-radius: 0.25rem;
            border: 1px solid #6b7280;
            background-color: #374151;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .statistics-operation-checkbox:checked {
            background-color: #14b8a6;
            border-color: #14b8a6;
            background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='m13.854 3.646-7-7a.5.5 0 0 0-.708 0l-3.5 3.5a.5.5 0 0 0 0 .708l7 7a.5.5 0 0 0 .708 0l3.5-3.5a.5.5 0 0 0 0-.708z'/%3e%3c/svg%3e");
        }

        .statistics-operation-checkbox:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(20, 184, 166, 0.2);
        }

        /* Floating Statistics Cards */
        .floating-statistics-card {
            background: rgba(31, 41, 55, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(75, 85, 99, 0.3);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
            padding: 1.5rem;
            text-align: center;
            transition: all 0.3s ease;
            width: 100%;
            min-width: 240px;
            max-width: 320px;
            opacity: 0;
            animation: fadeInAtPosition 0.5s ease-out forwards;
        }

        .floating-statistics-card:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
            transform: translateY(-1px);
        }

        .floating-statistics-header {
            margin-bottom: 0.75rem;
        }

        .floating-statistics-operation {
            font-size: 0.875rem;
            font-weight: 600;
            color: #60a5fa;
            text-transform: capitalize;
            margin-bottom: 0.25rem;
        }

        .floating-statistics-field {
            font-size: 0.75rem;
            color: #9ca3af;
            font-weight: 400;
        }

        .floating-statistics-number {
            font-size: 2.25rem;
            font-weight: 700;
            color: #14b8a6;
            margin-bottom: 0.25rem;
            font-family: 'Inter', monospace;
            text-shadow: 0 0 20px rgba(20, 184, 166, 0.4);
            transition: all 0.2s ease;
            word-break: break-all;
        }

        .floating-statistics-number.counting {
            animation: pulse-glow 0.15s ease-in-out;
        }

        .floating-statistics-label {
            font-size: 0.75rem;
            color: #9ca3af;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .floating-statistics-no-features {
            color: #f59e0b;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .floating-statistics-help-text {
            font-size: 0.625rem;
            color: #6b7280;
            margin-top: 0.5rem;
            font-style: italic;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 640px) {
            .floating-statistics-card {
                padding: 1rem;
            }
            
            .floating-statistics-number {
                font-size: 1.75rem;
            }
            
            .floating-statistics-operation {
                font-size: 0.8rem;
            }
        }

        /* Custom scrollbar for floating container */
        #floatingStatisticsContainer::-webkit-scrollbar {
            width: 4px;
        }

        #floatingStatisticsContainer::-webkit-scrollbar-track {
            background: rgba(75, 85, 99, 0.2);
            border-radius: 2px;
        }

        #floatingStatisticsContainer::-webkit-scrollbar-thumb {
            background: rgba(20, 184, 166, 0.5);
            border-radius: 2px;
        }

        #floatingStatisticsContainer::-webkit-scrollbar-thumb:hover {
            background: rgba(20, 184, 166, 0.7);
        }

        /* Smooth fade-in animation at final position */
        @keyframes fadeInAtPosition {
            0% {
                opacity: 0;
                transform: scale(0.98);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Smooth fade-out animation */
        @keyframes fadeOutAtPosition {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.98);
            }
        }

        /* Modern Feature Popup Styles */
        .modern-feature-popup .leaflet-popup-content-wrapper {
            background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
            border: 2px solid #14b8a6;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3), 0 0 20px rgba(20, 184, 166, 0.1);
            backdrop-filter: blur(10px);
            padding: 0;
            overflow: hidden;
        }

        .modern-feature-popup .leaflet-popup-content {
            margin: 0;
            padding: 0;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            line-height: 1.5;
        }

        .modern-popup-container {
            width: 100%;
            min-width: 280px;
            max-width: 350px;
        }

        .modern-popup-header {
            background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%);
            padding: 12px 16px;
            display: flex;
            align-items: center;
            font-weight: 600;
            font-size: 14px;
            color: #ffffff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modern-popup-header i {
            color: #ffffff;
            font-size: 14px;
        }

        .modern-popup-body {
            padding: 16px;
            background: rgba(30, 58, 138, 0.95);
            max-height: 300px;
            overflow-y: auto;
        }

        .property-row {
            display: flex;
            flex-direction: column;
            margin-bottom: 12px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border-left: 3px solid #14b8a6;
            transition: all 0.2s ease;
        }

        .property-row:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(2px);
        }

        .property-row:last-child {
            margin-bottom: 0;
        }

        .property-key {
            font-weight: 700;
            color: #5eead4;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .property-value {
            color: #f3f4f6;
            font-size: 14px;
            font-weight: 500;
            word-break: break-word;
            line-height: 1.4;
        }

        .no-data-text {
            color: #9ca3af;
            font-style: italic;
            text-align: center;
            padding: 20px 0;
            margin: 0;
            font-size: 14px;
        }

        /* Custom scrollbar for popup body */
        .modern-popup-body::-webkit-scrollbar {
            width: 6px;
        }

        .modern-popup-body::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .modern-popup-body::-webkit-scrollbar-thumb {
            background: #14b8a6;
            border-radius: 3px;
        }

        .modern-popup-body::-webkit-scrollbar-thumb:hover {
            background: #0d9488;
        }

        /* Modern popup tip styling */
        .modern-feature-popup .leaflet-popup-tip {
            background: #14b8a6;
            border: none;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
        }

        /* Animation for popup appearance */
        .modern-feature-popup {
            animation: popupSlideIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes popupSlideIn {
            0% {
                opacity: 0;
                transform: scale(0.8) translateY(-10px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        /* Print Layout Editor Styles */
        #printModal {
            z-index: 50000 !important;
        }
        
        .print-layout-toolbar {
            z-index: 50001 !important;
            position: relative;
        }
        
        .print-layout-canvas {
            z-index: 50001 !important;
            position: relative;
        }
        
        #printCanvas {
            z-index: 50002 !important;
            position: relative;
        }
        
        .resize-container {
            position: relative;
            z-index: 50003 !important;
        }

        .resize-handle {
            position: absolute;
            background: #3b82f6;
            border: 2px solid white;
            width: 8px;
            height: 8px;
            z-index: 50010 !important;
            /* DISABLED: Hide all resize handles - map frame auto-fits canvas */
            display: none !important;
            visibility: hidden !important;
        }

        .resize-handle:hover {
            background: #1d4ed8;
        }

        .resize-handle-nw { top: -4px; left: -4px; cursor: nw-resize; }
        .resize-handle-ne { top: -4px; right: -4px; cursor: ne-resize; }
        .resize-handle-sw { bottom: -4px; left: -4px; cursor: sw-resize; }
        .resize-handle-se { bottom: -4px; right: -4px; cursor: se-resize; }
        .resize-handle-n { top: -4px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .resize-handle-s { bottom: -4px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .resize-handle-w { top: 50%; left: -4px; transform: translateY(-50%); cursor: w-resize; }
        .resize-handle-e { top: 50%; right: -4px; transform: translateY(-50%); cursor: e-resize; }

        .resize-container.dragging {
            z-index: 50020 !important;
        }

        .resize-container.resizing {
            z-index: 50020 !important;
        }

        #printCanvas {
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        #mapFrame {
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
            transition: box-shadow 0.2s ease;
        }

        #mapFrame:hover {
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
        }

        #mapFrame.active {
            border-color: #1d4ed8;
            box-shadow: 0 8px 20px rgba(29, 78, 216, 0.5);
        }

        #printMapContainer {
            border-radius: 2px;
            overflow: hidden;
            z-index: 50004 !important;
            position: relative;
        }

        /* Print map styles */
        .print-map {
            width: 100%;
            height: 100%;
            z-index: 50004 !important;
            position: relative;
        }
        
        /* Ensure print map leaflet elements don't interfere */
        #printModal .leaflet-container {
            z-index: 50004 !important;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Fix for tile grid lines/seams in all Leaflet maps */
        .leaflet-container .leaflet-tile-container img {
            width: 256.5px !important;
            height: 256.5px !important;
            margin: 0 -0.25px -0.25px 0 !important;
        }
        
        #printModal .leaflet-control-container {
            z-index: 50005 !important;
        }
        
        /* Title area styling */
        #titleArea {
            z-index: 50006 !important;
            position: absolute;
        }
        
        /* Force visibility for all print modal elements */
        #printModal * {
            visibility: visible !important;
        }
        
        /* Prevent any child elements from being hidden behind map */
        #printModal .glass-panel {
            z-index: 50001 !important;
            position: relative;
        }
        
        /* Ensure all interactive elements are above the map */
        #printModal button,
        #printModal select,
        #printModal input {
            z-index: 50007 !important;
            position: relative;
        }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden">
    <!-- Custom Confirmation Modal -->
    <div id="customModal" class="confirm-modal-overlay">
        <div class="confirm-modal">
            <div id="customModalIcon" class="confirm-modal-icon"></div>
            <div id="customModalTitle" class="confirm-modal-title">Confirm Action</div>
            <div id="customModalMessage" class="confirm-modal-message">
                Are you sure you want to continue?
            </div>
            <div id="customModalInput" class="confirm-modal-input-container" style="display: none;">
                <input type="text" id="customModalInputField" class="confirm-modal-input" placeholder="Enter value...">
            </div>
            <div id="customModalButtons" class="confirm-modal-buttons">
                <button id="customModalOkBtn" class="confirm-modal-btn confirm-modal-btn-ok">OK</button>
                <button id="customModalCancelBtn" class="confirm-modal-btn confirm-modal-btn-cancel" style="display: none;">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Login Container -->
    <div id="loginContainer">
        <div class="login-card">
            <div class="login-header">
                <h1 class="login-title">Aéra Link</h1>
                <p class="login-subtitle">AKL WebGIS Portal</p>
            </div>
            
            <form id="loginForm" class="login-form">
                <div id="errorMessage" class="error-message" style="display: none;"></div>
                
                <div class="form-group">
                    <label for="email" class="form-label">Email Address</label>
                    <input 
                        type="email" 
                        id="email" 
                        name="email" 
                        class="form-input" 
                        placeholder="Enter your email address"
                        required
                    >
                </div>
                
                <div class="form-group">
                    <label for="password" class="form-label">Password</label>
                    <div class="password-input-container">
                        <input 
                            type="password" 
                            id="password" 
                            name="password" 
                            class="form-input has-toggle" 
                            placeholder="Enter your password"
                            required
                        >
                        <button type="button" class="password-toggle-btn" id="passwordToggle">
                            <i class="fas fa-eye" id="passwordToggleIcon"></i>
                        </button>
                    </div>
                </div>
                
                <button type="submit" id="loginButton" class="login-button">
                    Sign In to WebGIS
                </button>
                
                <div class="forgot-password">
                    <a href="#" id="forgotPasswordLink">Forgot your password?</a>
                </div>
            </form>
        </div>
    </div>

    <!-- WebGIS Container -->
    <div id="webgisContainer" style="display: none;">
        <!-- Header -->
        <div class="header-container">
            <header class="glass-effect fixed top-0 left-0 right-0 z-50 px-6 py-4">
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-4">
                        <img src="AERA LOGO.png" alt="Aera Logo" class="h-12 w-auto">
                    </div>
                    
                    <!-- User Info and Logout -->
                    <div class="user-info">
                        <span id="userEmail" class="user-email"></span>
                        <button id="logoutButton" class="logout-button">
                            <i class="fas fa-sign-out-alt"></i> Logout
                        </button>
                    </div>
                </div>
            </header>
        </div>

    <!-- Main Content -->
    <div class="main-content-container pt-20 h-screen">
        <!-- Map Container -->
        <div id="map"></div>
        
        <!-- Floating Statistics Cards Container -->
        <div id="floatingStatisticsContainer" class="fixed top-24 right-2 sm:right-6 z-[1150] space-y-3 w-64 sm:w-72 lg:w-80 max-w-[90vw] max-h-[calc(100vh-8rem)] overflow-y-auto pr-2 sm:pr-0" style="display: none;">
            <!-- Statistics cards will be dynamically added here -->
        </div>
        
        <!-- Sidebar -->
        <div id="sidebar" class="leaflet-sidebar collapsed">
            <!-- Layers Tab -->
            <div class="leaflet-sidebar-tabs">
                <ul role="tablist">
                    <li><a href="#filter-panel" role="tab"><i class="fas fa-filter"></i></a></li>
                    <li><a href="#print-panel" role="tab"><i class="fas fa-print"></i></a></li>
                    <li><a href="#layers-panel" role="tab"><i class="fas fa-layer-group"></i></a></li>
                    <li><a href="#legend-panel" role="tab"><i class="fas fa-list"></i></a></li>
                    <li><a href="#select-panel" role="tab"><i class="fas fa-draw-polygon"></i></a></li>
                </ul>
            </div>
            
            <div class="leaflet-sidebar-content">
                <!-- Filter Panel -->
                <div class="leaflet-sidebar-pane" id="filter-panel">
                    <h1 class="leaflet-sidebar-header text-white font-bold text-lg mb-4">
                        Filter
                        <span class="leaflet-sidebar-close"><i class="fas fa-times"></i></span>
                    </h1>
                    <div class="space-y-4">
                        <div class="glass-panel rounded-lg p-4">
                            <p class="text-gray-300 text-sm mb-4">Filter features from visible layers based on attribute values.</p>
                            
                            <!-- Step 1: Layer Selection -->
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-300 mb-2">
                                    <i class="fas fa-layer-group mr-2"></i>Select Layer
                                </label>
                                <select id="filterLayerSelect" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                    <option value="">Choose a layer to filter</option>
                                </select>
                            </div>
                            
                            <!-- Step 2: Field Selection -->
                            <div id="filterFieldSection" class="mb-4" style="display: none;">
                                <label class="block text-sm font-medium text-gray-300 mb-2">
                                    <i class="fas fa-table mr-2"></i>Select Field
                                </label>
                                <select id="filterFieldSelect" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                    <option value="">Choose a field to filter by</option>
                                </select>
                            </div>
                            
                            <!-- Step 3: Operator Selection -->
                            <div id="filterOperatorSection" class="mb-4" style="display: none;">
                                <label class="block text-sm font-medium text-gray-300 mb-2">
                                    <i class="fas fa-filter mr-2"></i>Filter Operator
                                </label>
                                <select id="filterOperatorSelect" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                    <option value="">Choose how to filter</option>
                                    <option value="equal">Equal to</option>
                                    <option value="not_equal">Not equal to</option>
                                    <option value="include">Include (any of)</option>
                                    <option value="does_not_include">Does not include (any of)</option>
                                    <option value="contains">Contains text</option>
                                    <option value="does_not_contain">Does not contain text</option>
                                    <option value="starts_with">Starts with</option>
                                    <option value="does_not_start_with">Does not start with</option>
                                    <option value="is_empty">Is empty</option>
                                    <option value="is_not_empty">Is not empty</option>
                                    <option value="is_null">Is null</option>
                                    <option value="is_not_null">Is not null</option>
                                </select>
                            </div>
                            
                            <!-- Step 4: Value Input (Dynamic) -->
                            <div id="filterValueSection" style="display: none;">
                                <label class="block text-sm font-medium text-gray-300 mb-2">
                                    <i class="fas fa-edit mr-2"></i>Filter Value
                                </label>
                                
                                <!-- Single Value Dropdown -->
                                <select id="filterSingleValueSelect" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" style="display: none;">
                                    <option value="">Loading values...</option>
                                </select>
                                
                                <!-- Multi-Value Selection -->
                                <div id="filterMultiValueContainer" style="display: none;">
                                    <div class="bg-gray-800 border border-gray-600 rounded-md p-2 max-h-32 overflow-y-auto">
                                        <div id="filterMultiValueList">
                                            <!-- Checkboxes will be populated here -->
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Text Input -->
                                <input type="text" id="filterTextInput" placeholder="Enter text to filter by" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" style="display: none;">
                            </div>
                            
                            <!-- Action Buttons -->
                            <div id="filterActionsSection" class="mt-6 space-y-2" style="display: none;">
                                <button id="applyFilterBtn" class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors text-sm font-medium">
                                    <i class="fas fa-check mr-2"></i>Apply Filter
                                </button>
                                <button id="clearFilterBtn" class="w-full px-4 py-2 bg-orange-600 hover:bg-orange-700 text-white rounded-md transition-colors text-sm font-medium">
                                    <i class="fas fa-times mr-2"></i>Clear Filter
                                </button>
                            </div>
                            
                            <!-- Filter Selected Button (Always Visible) -->
                            <div class="mt-6">
                                <button id="filterSelectedBtn" class="w-full px-4 py-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white rounded-md transition-colors text-sm font-medium" disabled>
                                    <i class="fas fa-layer-group mr-2"></i>Filter Selected Features
                                </button>
                                <div class="text-xs text-gray-400 mt-1 text-center">
                                    <span id="selectedFeaturesCount">No features selected</span>
                                </div>
                            </div>
                            
                            <!-- Filter Status -->
                            <div id="filterStatusSection" style="display: none;">
                                <div class="mt-4 p-3 bg-green-900/30 border border-green-600/50 rounded-md">
                                    <div class="flex items-center">
                                        <i class="fas fa-filter text-green-400 mr-2"></i>
                                        <span class="text-green-300 text-sm font-medium">Filter Active</span>
                                    </div>
                                    <div id="filterStatusText" class="text-gray-300 text-xs mt-1"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Print Map Panel -->
                <div class="leaflet-sidebar-pane" id="print-panel">
                    <h1 class="leaflet-sidebar-header text-white font-bold text-lg mb-4">
                        Print Map
                        <span class="leaflet-sidebar-close"><i class="fas fa-times"></i></span>
                    </h1>
                    <div class="space-y-3">
                        <div class="glass-panel rounded-lg p-4">
                            <p class="text-gray-300 text-sm mb-4">Export the current map view as a high-quality image for printing or presentation.</p>
                            <button id="printBtn" class="w-full px-4 py-3 bg-green-600 hover:bg-green-700 text-white rounded-md transition-colors">
                                <i class="fas fa-print mr-2"></i>Print Map
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Layers Panel -->
                <div class="leaflet-sidebar-pane" id="layers-panel">
                    <h1 class="leaflet-sidebar-header text-white font-bold text-lg mb-4">
                        Layers
                        <span class="leaflet-sidebar-close"><i class="fas fa-times"></i></span>
                    </h1>
                    <div id="layersList" class="space-y-3">
                        <!-- Layers will be dynamically added here -->
                    </div>
                </div>
                
                <!-- Legend Panel -->
                <div class="leaflet-sidebar-pane" id="legend-panel">
                    <h1 class="leaflet-sidebar-header text-white font-bold text-lg mb-4">
                        Legend
                        <span class="leaflet-sidebar-close"><i class="fas fa-times"></i></span>
                    </h1>
                    <div id="legendContent" class="space-y-2">
                        <!-- Legend items will be dynamically added here -->
                    </div>
                </div>
                
                <!-- Select Panel -->
                <div class="leaflet-sidebar-pane" id="select-panel">
                    <h1 class="leaflet-sidebar-header text-white font-bold text-lg mb-4">
                        Select Features
                        <span class="leaflet-sidebar-close"><i class="fas fa-times"></i></span>
                    </h1>
                    <div class="space-y-4">
                        <div class="glass-panel rounded-lg p-4">
                            <div class="mb-3">
                                <label class="block text-sm font-medium text-gray-300 mb-2">Active Layer for Selection</label>
                                <select id="activeLayerSelect" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent">
                                    <option value="">Select a layer first</option>
                                </select>
                            </div>
                            <button id="activateSelectTool" class="w-full px-4 py-2 bg-teal-600 hover:bg-teal-700 text-white rounded-md mb-3" disabled>
                                <i class="fas fa-draw-polygon mr-2"></i>Activate Selection Tool
                            </button>
                            <button id="clearSelection" class="w-full px-4 py-2 bg-orange-600 hover:bg-orange-700 text-white rounded-md" disabled>
                                <i class="fas fa-times mr-2"></i>Clear Selection
                            </button>
                            <button id="showStatistics" class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md mt-3" disabled>
                                <i class="fas fa-chart-bar mr-2"></i>Statistics
                            </button>
                        </div>
                        <div id="selectionInfo" class="selection-counter-card">
                            <div id="selectedCountNumber" class="selection-counter-number">0</div>
                            <div class="selection-counter-label">Features Selected</div>
                            <div id="selectedFeaturesList" class="mt-4 space-y-2 max-h-40 overflow-y-auto" style="display: none;">
                                <!-- Selected features will be listed here when count > 0 -->
                            </div>
                        </div>

                        <!-- Statistics Panel -->
                        <div id="statisticsPanel" class="glass-panel rounded-lg p-4" style="display: none;">
                            <h3 class="text-white font-semibold mb-3">
                                <i class="fas fa-chart-bar mr-2"></i>Statistics
                            </h3>
                            <div class="space-y-3">
                                <div>
                                    <label class="block text-sm font-medium text-gray-300 mb-2">Field</label>
                                    <select id="statisticsFieldSelect" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent">
                                        <option value="">Select a field</option>
                                    </select>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-300 mb-2">Operations</label>
                                    <div class="grid grid-cols-2 gap-2">
                                        <label class="flex items-center space-x-2 text-sm text-gray-300 cursor-pointer">
                                            <input type="checkbox" value="sum" class="statistics-operation-checkbox rounded border-gray-600 bg-gray-700 text-teal-500 focus:ring-teal-500">
                                            <span>Sum</span>
                                        </label>
                                        <label class="flex items-center space-x-2 text-sm text-gray-300 cursor-pointer">
                                            <input type="checkbox" value="average" class="statistics-operation-checkbox rounded border-gray-600 bg-gray-700 text-teal-500 focus:ring-teal-500">
                                            <span>Average</span>
                                        </label>
                                        <label class="flex items-center space-x-2 text-sm text-gray-300 cursor-pointer">
                                            <input type="checkbox" value="mode" class="statistics-operation-checkbox rounded border-gray-600 bg-gray-700 text-teal-500 focus:ring-teal-500">
                                            <span>Mode</span>
                                        </label>
                                        <label class="flex items-center space-x-2 text-sm text-gray-300 cursor-pointer">
                                            <input type="checkbox" value="min" class="statistics-operation-checkbox rounded border-gray-600 bg-gray-700 text-teal-500 focus:ring-teal-500">
                                            <span>Minimum</span>
                                        </label>
                                        <label class="flex items-center space-x-2 text-sm text-gray-300 cursor-pointer">
                                            <input type="checkbox" value="max" class="statistics-operation-checkbox rounded border-gray-600 bg-gray-700 text-teal-500 focus:ring-teal-500">
                                            <span>Maximum</span>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            <div id="statisticsResults" class="mt-4" style="display: none;">
                                <!-- Statistical results will be displayed here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Data Modal -->
    <div id="addDataModal" class="fixed inset-0 modal-overlay z-50 hidden flex items-center justify-center">
        <div class="glass-panel rounded-lg p-6 max-w-md w-full mx-4">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-white">Add Data</h2>
                <button id="closeAddDataModal" class="text-gray-400 hover:text-white">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">Select File</label>
                    <input type="file" id="fileInput" accept=".geojson,.json,.kml,.kmz" 
                           class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                    <p class="text-xs text-gray-400 mt-1"><em>Supports GeoJSON, KML, and KMZ files (max 50MB)</em></p>
                </div>
                
                <div id="uploadProgress" class="hidden">
                    <div class="bg-gray-700 rounded-full h-2">
                        <div id="progressBar" class="progress-bar h-2 rounded-full" style="width: 0%"></div>
                    </div>
                    <p id="progressText" class="text-xs text-gray-400 mt-1">Uploading...</p>
                </div>
                
                <div class="flex justify-end space-x-3">
                    <button id="cancelUpload" class="px-4 py-2 text-gray-400 hover:text-white">Cancel</button>
                    <button id="uploadFile" class="px-4 py-2 bg-teal-600 hover:bg-teal-700 text-white rounded-md">
                        Upload
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Filter Modal -->
    <div id="filterModal" class="fixed inset-0 modal-overlay z-50 hidden flex items-center justify-center">
        <div class="glass-panel rounded-lg p-6 max-w-md w-full mx-4">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-white">Filter Features</h2>
                <button id="closeFilterModal" class="text-gray-400 hover:text-white">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">Layer</label>
                    <select id="filterLayer" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                        <!-- Options will be populated dynamically -->
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">Field</label>
                    <select id="filterField" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                        <!-- Options will be populated dynamically -->
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">Value</label>
                    <input type="text" id="filterValue" placeholder="Enter value to filter by"
                           class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                </div>
                
                <div class="flex justify-end space-x-3">
                    <button id="clearFilter" class="px-4 py-2 text-orange-400 hover:text-orange-300">Clear Filter</button>
                    <button id="applyFilter" class="px-4 py-2 bg-teal-600 hover:bg-teal-700 text-white rounded-md">
                        Apply Filter
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Print Layout Modal -->
    <div id="printModal" class="fixed inset-0 modal-overlay hidden" style="z-index: 50000 !important;">
        <div class="w-full h-full bg-gray-900 flex flex-col" style="z-index: 50001 !important;">
            <!-- Header -->
            <div class="glass-panel flex justify-between items-center p-4 border-b border-gray-700 print-layout-toolbar">
                <h2 class="text-xl font-bold text-white">Print Layout Editor</h2>
                <button id="closePrintModal" class="text-gray-400 hover:text-white text-2xl">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <!-- Toolbar -->
            <div class="glass-panel p-3 border-b border-gray-700 print-layout-toolbar">
                <div class="flex items-center space-x-6">
                    <!-- Canvas Size Selection -->
                    <div class="flex items-center space-x-2">
                        <label class="text-sm font-medium text-gray-300">Canvas Size:</label>
                        <select id="canvasSize" class="px-3 py-1 bg-gray-700 border border-gray-600 rounded text-white text-sm">
                            <option value="1980x1080" selected>PowerPoint Slide (1980×1080px)</option>
                            <option value="1920x1080">Full HD (1920×1080px)</option>
                            <option value="2480x3508">A4 Portrait (2480×3508px)</option>
                            <option value="3508x2480">A4 Landscape (3508×2480px)</option>
                            <option value="3508x4961">A3 Portrait (3508×4961px)</option>
                            <option value="4961x3508">A3 Landscape (4961×3508px)</option>
                            <option value="custom">Custom Size</option>
                        </select>
                    </div>
                    
                    <!-- Custom Size Inputs (hidden by default) -->
                    <div id="customSizeInputs" class="hidden flex items-center space-x-2">
                        <label class="text-sm text-gray-300">Width:</label>
                        <input type="number" id="customWidth" value="1980" class="w-20 px-2 py-1 bg-gray-700 border border-gray-600 rounded text-white text-sm">
                        <label class="text-sm text-gray-300">Height:</label>
                        <input type="number" id="customHeight" value="1080" class="w-20 px-2 py-1 bg-gray-700 border border-gray-600 rounded text-white text-sm">
                        <label class="text-sm text-gray-300">px</label>
                    </div>
                    
                    <!-- Export Button -->
                    <button id="exportLayoutBtn" class="ml-auto px-4 py-2 bg-teal-600 hover:bg-teal-700 text-white rounded-md flex items-center space-x-2">
                        <i class="fas fa-download"></i>
                        <span>Export Layout</span>
                    </button>
                </div>
            </div>
            
            <!-- Canvas Container -->
            <div class="flex-1 p-6 overflow-auto bg-gray-800 print-layout-canvas">
                <div class="flex justify-center">
                    <div id="printCanvas" class="bg-white shadow-2xl relative print-layout-canvas" 
                         style="width: 990px; height: 540px; min-height: 400px; z-index: 50002 !important;">
                        <!-- Map Frame (draggable and resizable) -->
                        <div id="mapFrame" class="absolute border-2 border-blue-500 cursor-move resize-container"
                             style="left: 50px; top: 80px; width: 800px; height: 400px;">
                            <!-- Map Container -->
                            <div id="printMapContainer" class="w-full h-full bg-gray-200 relative overflow-hidden">
                                <div class="absolute inset-0 flex items-center justify-center text-gray-600">
                                    <div class="text-center">
                                        <i class="fas fa-map text-4xl mb-2"></i>
                                        <p>Map Preview</p>
                                        <p class="text-sm">Drag to pan • Scroll to zoom</p>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Resize Handles -->
                            <div class="resize-handle resize-handle-nw"></div>
                            <div class="resize-handle resize-handle-ne"></div>
                            <div class="resize-handle resize-handle-sw"></div>
                            <div class="resize-handle resize-handle-se"></div>
                            <div class="resize-handle resize-handle-n"></div>
                            <div class="resize-handle resize-handle-s"></div>
                            <div class="resize-handle resize-handle-w"></div>
                            <div class="resize-handle resize-handle-e"></div>
                        </div>
                        
                        <!-- Title Area - Top Left -->
                        <div id="titleArea" class="absolute top-4 left-4 w-96">
                            <input type="text" id="layoutTitle" placeholder="Enter map title..." 
                                   class="w-full text-xl font-bold border-none outline-none bg-transparent text-gray-800"
                                   value="">
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Symbology Modal -->
    <div id="symbologyModal" class="fixed inset-0 modal-overlay z-50 hidden flex items-center justify-center">
        <div class="glass-panel rounded-lg p-6 max-w-lg w-full mx-4">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-white">Layer Symbology</h2>
                <button id="closeSymbologyModal" class="text-gray-400 hover:text-white">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">Style Type</label>
                    <select id="styleType" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                        <option value="single">Single Symbol</option>
                        <option value="categorical">Categorical</option>
                    </select>
                </div>
                
                <div id="singleSymbolOptions">
                    <label class="block text-sm font-medium text-gray-300 mb-2">Color</label>
                    <input type="color" id="singleColor" value="#14b8a6" class="w-16 h-10 bg-transparent border border-gray-600 rounded">
                </div>
                
                <div id="categoricalOptions" class="hidden">
                    <label class="block text-sm font-medium text-gray-300 mb-2">Classify by Field</label>
                    <select id="classifyField" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                        <!-- Options populated dynamically -->
                    </select>
                    <div id="classificationRules" class="mt-4 space-y-2">
                        <!-- Classification rules will be added here -->
                    </div>
                </div>
                
                <div class="flex justify-end space-x-3">
                    <button id="cancelSymbology" class="px-4 py-2 text-gray-400 hover:text-white">Cancel</button>
                    <button id="applySymbology" class="px-4 py-2 bg-teal-600 hover:bg-teal-700 text-white rounded-md">
                        Apply
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Layer Context Menu -->
    <div id="layerContextMenu" class="custom-context-menu">
        <div class="context-menu-item" id="contextZoomToLayer">
            <i class="fas fa-search-plus"></i>
            Zoom to Layer
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="contextRename">
            <i class="fas fa-edit"></i>
            Rename
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="contextProperties">
            <i class="fas fa-palette"></i>
            Properties
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="contextDelete">
            <i class="fas fa-trash"></i>
            Delete
        </div>
    </div>

    <!-- Map Context Menu for Basemap Selection -->
    <div id="mapContextMenu" class="custom-context-menu">
        <div class="context-menu-item context-menu-parent" id="changeBasemapOption">
            <i class="fas fa-map"></i>
            Change Basemap
            <i class="fas fa-chevron-right context-menu-arrow"></i>
            <div class="context-submenu" id="basemapSubmenu">
                <!-- OSM Group -->
                <div class="context-menu-group-header">OSM</div>
                <div class="context-menu-item basemap-option satellite-option" data-basemap="osm-no-labels">
                    <span>
                        <i class="fas fa-map"></i>
                        OSM (no labels)
                    </span>
                    <label class="label-toggle">
                        <input type="checkbox" class="label-checkbox" data-labels="osm-standard">
                        <span class="label-text">+ Show Labels</span>
                    </label>
                </div>
                <div class="context-menu-item basemap-option" data-basemap="osm-hot">
                    <i class="fas fa-hand-holding-heart"></i>
                    OSM Humanitarian
                </div>
                <div class="context-menu-item basemap-option" data-basemap="osm-opnv">
                    <i class="fas fa-subway"></i>
                    OSM ÖPNV (Public Transport)
                </div>
                <div class="context-menu-item basemap-option" data-basemap="osm-dark">
                    <i class="fas fa-moon"></i>
                    OSM Dark
                </div>
                <div class="context-menu-item basemap-option" data-basemap="osm-satellite">
                    <i class="fas fa-satellite"></i>
                    OSM Satellite
                </div>
                
                <div class="context-menu-separator"></div>
                
                <!-- ESRI Group -->
                <div class="context-menu-group-header">ESRI</div>
                <div class="context-menu-item basemap-option satellite-option" data-basemap="esri-world-imagery">
                    <span>
                        <i class="fas fa-satellite-dish"></i>
                        World Imagery (Satellite)
                    </span>
                    <label class="label-toggle">
                        <input type="checkbox" class="label-checkbox" data-labels="esri-imagery-labels">
                        <span class="label-text">+ Show Labels</span>
                    </label>
                </div>
                <div class="context-menu-item basemap-option" data-basemap="esri-streets">
                    <i class="fas fa-road"></i>
                    Street
                </div>
                <div class="context-menu-item basemap-option" data-basemap="esri-topo">
                    <i class="fas fa-mountain"></i>
                    Topo
                </div>
                
                <div class="context-menu-separator"></div>
                
                <!-- Google Group -->
                <div class="context-menu-group-header">Google</div>
                <div class="context-menu-item basemap-option satellite-option" data-basemap="google-satellite">
                    <span>
                        <i class="fab fa-google"></i>
                        Satellite (no labels) [default]
                    </span>
                    <label class="label-toggle">
                        <input type="checkbox" class="label-checkbox" data-labels="google-labels">
                        <span class="label-text">+ Show Labels</span>
                    </label>
                </div>
                <div class="context-menu-item basemap-option" data-basemap="google-hybrid">
                    <i class="fab fa-google"></i>
                    Hybrid
                </div>
                <div class="context-menu-item basemap-option" data-basemap="google-terrain">
                    <i class="fab fa-google"></i>
                    Terrain
                </div>
                
                <div class="context-menu-separator"></div>
                
                <!-- Bing Group -->
                <div class="context-menu-group-header">Bing</div>
                <div class="context-menu-item basemap-option satellite-option" data-basemap="bing-aerial">
                    <span>
                        <i class="fas fa-plane"></i>
                        Bing Aerial (no labels)
                    </span>
                    <label class="label-toggle">
                        <input type="checkbox" class="label-checkbox" data-labels="bing-aerial-labels">
                        <span class="label-text">+ Show Labels</span>
                    </label>
                </div>
                <div class="context-menu-item basemap-option" data-basemap="bing-road">
                    <i class="fas fa-road"></i>
                    Road
                </div>
                
                <div class="context-menu-separator"></div>
                
                <!-- CARTO Group -->
                <div class="context-menu-group-header">CARTO</div>
                <div class="context-menu-item basemap-option satellite-option" data-basemap="carto-positron">
                    <span>
                        <i class="fas fa-sun"></i>
                        Positron (no labels)
                    </span>
                    <label class="label-toggle">
                        <input type="checkbox" class="label-checkbox" data-labels="carto-positron-labels">
                        <span class="label-text">+ Show Labels</span>
                    </label>
                </div>
                <div class="context-menu-item basemap-option satellite-option" data-basemap="carto-dark-matter">
                    <span>
                        <i class="fas fa-moon"></i>
                        Dark Matter (no labels)
                    </span>
                    <label class="label-toggle">
                        <input type="checkbox" class="label-checkbox" data-labels="carto-dark-matter-labels">
                        <span class="label-text">+ Show Labels</span>
                    </label>
                </div>
                <div class="context-menu-item basemap-option satellite-option" data-basemap="carto-voyager">
                    <span>
                        <i class="fas fa-compass"></i>
                        Voyager (no labels)
                    </span>
                    <label class="label-toggle">
                        <input type="checkbox" class="label-checkbox" data-labels="carto-voyager-labels">
                        <span class="label-text">+ Show Labels</span>
                    </label>
                </div>
                
                <div class="context-menu-separator"></div>
                
                <!-- Thunderforest Group -->
                <div class="context-menu-group-header">Thunderforest</div>
                <div class="context-menu-item basemap-option" data-basemap="thunderforest-cycle">
                    <i class="fas fa-bicycle"></i>
                    Open Cycle
                </div>
                <div class="context-menu-item basemap-option" data-basemap="thunderforest-dark">
                    <i class="fas fa-moon"></i>
                    Thunderforest Dark
                </div>
                <div class="context-menu-item basemap-option" data-basemap="thunderforest-diablo">
                    <i class="fas fa-fire"></i>
                    Thunderforest Diablo
                </div>
                <div class="context-menu-item basemap-option" data-basemap="thunderforest-outdoor">
                    <i class="fas fa-mountain"></i>
                    Thunderforest Outdoor
                </div>
                <div class="context-menu-item basemap-option" data-basemap="thunderforest-old">
                    <i class="fas fa-history"></i>
                    Thunderforest Old
                </div>
                <div class="context-menu-item basemap-option" data-basemap="thunderforest-neighborhood">
                    <i class="fas fa-home"></i>
                    Thunderforest Neighborhood
                </div>
                
                <div class="context-menu-separator"></div>
                
                <!-- Maptiler Group -->
                <div class="context-menu-group-header">Maptiler</div>
                <div class="context-menu-item basemap-option" data-basemap="maptiler-aquarelle">
                    <i class="fas fa-paint-brush"></i>
                    Aquarelle
                </div>
                <div class="context-menu-item basemap-option" data-basemap="maptiler-backdrop">
                    <i class="fas fa-image"></i>
                    Backdrop
                </div>
                <div class="context-menu-item basemap-option" data-basemap="maptiler-topography">
                    <i class="fas fa-mountain"></i>
                    Topography
                </div>
                <div class="context-menu-item basemap-option" data-basemap="maptiler-winter">
                    <i class="fas fa-snowflake"></i>
                    Winter
                </div>
                <div class="context-menu-item basemap-option satellite-option" data-basemap="maptiler-openstreet-no-labels">
                    <span>
                        <i class="fas fa-map-marked"></i>
                        OpenStreet (no labels)
                    </span>
                    <label class="label-toggle">
                        <input type="checkbox" class="label-checkbox" data-labels="maptiler-openstreet-labels">
                        <span class="label-text">+ Show Labels</span>
                    </label>
                </div>
                
                <div class="context-menu-separator"></div>
                
                <!-- Waze Group -->
                <div class="context-menu-group-header">Other</div>
                <div class="context-menu-item basemap-option" data-basemap="waze">
                    <i class="fas fa-route"></i>
                    Waze
                </div>
            </div>
        </div>
    </div>
    </div> <!-- End of webgisContainer -->

    <!-- Scripts -->
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Leaflet Draw JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    
    <!-- Leaflet Sidebar JS -->
    <script src="https://unpkg.com/leaflet-sidebar-v2@3.2.3/js/leaflet-sidebar.min.js"></script>
    
    <!-- ESRI Leaflet for Basemaps -->
    <script src="https://unpkg.com/esri-leaflet@3.0.10/dist/esri-leaflet.js"></script>
    
    <!-- toGeoJSON for KML support -->
    <script src="https://unpkg.com/@mapbox/togeojson@0.16.0/togeojson.js"></script>
    
    <!-- Turf.js for precise spatial analysis -->
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    
    <!-- Supabase JavaScript Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <!-- Leaflet-Image for Print Export -->
    <script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
    
    <!-- Main Application Script -->
    <script>
        // Global variables
        let map;
        let sidebar;
        let layers = new Map();
        let layerCounter = 0;
        let currentSymbologyLayer = null;
        let activeFilters = new Map();
        let layerOrder = []; // Array to track layer display order
        
        // Basemap variables
        let currentBasemap = null;
        let basemaps = {};
        
        // Initialize basemap definitions
        function initializeBasemaps() {
            basemaps = {
                // OSM Basemaps
                'osm-no-labels': L.tileLayer('https://tile.openstreetmap.bzh/ca/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Tiles courtesy of <a href="https://www.openstreetmap.cat" target="_blank">Breton OpenStreetMap Team</a>'
                }),
                'osm-standard': L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'OpenStreetMap Labels',
                    maxZoom: 19
                }),
                'osm-hot': L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Tiles style by <a href="https://www.hotosm.org/" target="_blank">Humanitarian OpenStreetMap Team</a> hosted by <a href="https://openstreetmap.fr/" target="_blank">OpenStreetMap France</a>'
                }),
                'osm-opnv': L.tileLayer('https://tileserver.memomaps.de/tilegen/{z}/{x}/{y}.png', {
                    maxZoom: 18,
                    attribution: 'Map <a href="https://memomaps.de/">memomaps.de</a> <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }),
                'osm-dark': L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png', {
                    minZoom: 0,
                    maxZoom: 20,
                    attribution: '&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }),
                'osm-satellite': L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_satellite/{z}/{x}/{y}{r}.jpg', {
                    minZoom: 0,
                    maxZoom: 20,
                    attribution: '&copy; CNES, Distribution Airbus DS, © Airbus DS, © PlanetObserver (Contains Copernicus Data) | &copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }),

                // ESRI Basemaps
                'esri-world-imagery': L.esri.basemapLayer('Imagery'),
                'esri-imagery-labels': L.esri.basemapLayer('ImageryLabels'),
                'esri-streets': L.esri.basemapLayer('Streets'),
                'esri-topo': L.esri.basemapLayer('Topographic'),

                // Google Basemaps
                'google-satellite': L.tileLayer('https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                    maxZoom: 20,
                    subdomains: ['mt0','mt1','mt2','mt3'],
                    attribution: 'Google Satellite'
                }),
                'google-labels': L.tileLayer('https://{s}.google.com/vt/lyrs=h&x={x}&y={y}&z={z}', {
                    maxZoom: 20,
                    subdomains: ['mt0','mt1','mt2','mt3'],
                    attribution: 'Google Labels'
                }),
                'google-hybrid': L.tileLayer('https://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}', {
                    maxZoom: 20,
                    subdomains: ['mt0','mt1','mt2','mt3'],
                    attribution: 'Google Hybrid'
                }),
                'google-terrain': L.tileLayer('https://{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}', {
                    maxZoom: 20,
                    subdomains: ['mt0','mt1','mt2','mt3'],
                    attribution: 'Google Terrain'
                }),

                // Bing Basemaps 
                'bing-aerial': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: '© Esri, © Microsoft',
                    maxZoom: 19
                }),
                'bing-aerial-labels': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
                    attribution: '© Esri, © Microsoft - Labels',
                    maxZoom: 19
                }),
                'bing-road': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
                    attribution: '© Esri, © Microsoft',
                    maxZoom: 19
                }),

                // CARTO Basemaps
                'carto-positron': L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}.png', {
                    attribution: '© CARTO, © OpenStreetMap',
                    maxZoom: 19,
                    subdomains: 'abcd'
                }),
                'carto-positron-labels': L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}.png', {
                    attribution: '© CARTO, © OpenStreetMap',
                    maxZoom: 19,
                    subdomains: 'abcd'
                }),
                'carto-dark-matter': L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}.png', {
                    attribution: '© CARTO, © OpenStreetMap',
                    maxZoom: 19,
                    subdomains: 'abcd'
                }),
                'carto-dark-matter-labels': L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}.png', {
                    attribution: '© CARTO, © OpenStreetMap',
                    maxZoom: 19,
                    subdomains: 'abcd'
                }),
                'carto-voyager': L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}.png', {
                    attribution: '© CARTO, © OpenStreetMap',
                    maxZoom: 19,
                    subdomains: 'abcd'
                }),
                'carto-voyager-labels': L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_labels_under/{z}/{x}/{y}.png', {
                    attribution: '© CARTO, © OpenStreetMap',
                    maxZoom: 19,
                    subdomains: 'abcd'
                }),

                // Waze Basemap (using approximation since Waze doesn't provide public tiles)
                'waze': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Waze Style (OSM)',
                    maxZoom: 19
                }),

                // Thunderforest Basemaps
                'thunderforest-cycle': L.tileLayer('https://{s}.tile.thunderforest.com/cycle/{z}/{x}/{y}{r}.png?apikey=f5e725f7a49444eb8a9941f5a2fc6351', {
                    attribution: '&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 22
                }),
                'thunderforest-dark': L.tileLayer('https://{s}.tile.thunderforest.com/transport-dark/{z}/{x}/{y}{r}.png?apikey=f5e725f7a49444eb8a9941f5a2fc6351', {
                    attribution: '&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 22
                }),
                'thunderforest-diablo': L.tileLayer('https://{s}.tile.thunderforest.com/spinal-map/{z}/{x}/{y}{r}.png?apikey=f5e725f7a49444eb8a9941f5a2fc6351', {
                    attribution: '&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 22
                }),
                'thunderforest-outdoor': L.tileLayer('https://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}{r}.png?apikey=f5e725f7a49444eb8a9941f5a2fc6351', {
                    attribution: '&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 22
                }),
                'thunderforest-old': L.tileLayer('https://{s}.tile.thunderforest.com/pioneer/{z}/{x}/{y}{r}.png?apikey=f5e725f7a49444eb8a9941f5a2fc6351', {
                    attribution: '&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 22
                }),
                'thunderforest-neighborhood': L.tileLayer('https://{s}.tile.thunderforest.com/neighbourhood/{z}/{x}/{y}{r}.png?apikey=f5e725f7a49444eb8a9941f5a2fc6351', {
                    attribution: '&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 22
                }),

                // Maptiler Basemaps
                'maptiler-aquarelle': L.tileLayer('https://api.maptiler.com/maps/aquarelle/{z}/{x}/{y}.png?key=bbKm0mAybeaIXWDXmQka', {
                    attribution: '&copy; <a href="https://www.maptiler.com/" target="_blank">MapTiler</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 20
                }),
                'maptiler-backdrop': L.tileLayer('https://api.maptiler.com/maps/backdrop/{z}/{x}/{y}.png?key=bbKm0mAybeaIXWDXmQka', {
                    attribution: '&copy; <a href="https://www.maptiler.com/" target="_blank">MapTiler</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 20
                }),
                'maptiler-topography': L.tileLayer('https://api.maptiler.com/maps/topo-v2/{z}/{x}/{y}.png?key=bbKm0mAybeaIXWDXmQka', {
                    attribution: '&copy; <a href="https://www.maptiler.com/" target="_blank">MapTiler</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 20
                }),
                'maptiler-winter': L.tileLayer('https://api.maptiler.com/maps/winter/{z}/{x}/{y}.png?key=bbKm0mAybeaIXWDXmQka', {
                    attribution: '&copy; <a href="https://www.maptiler.com/" target="_blank">MapTiler</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 20
                }),
                'maptiler-openstreet-no-labels': L.tileLayer('https://api.maptiler.com/maps/0198323e-3089-7276-a811-4cd52a9474a6/{z}/{x}/{y}.png?key=bbKm0mAybeaIXWDXmQka', {
                    attribution: '&copy; <a href="https://www.maptiler.com/" target="_blank">MapTiler</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 20
                }),
                'maptiler-openstreet-labels': L.tileLayer('https://api.maptiler.com/maps/openstreetmap/{z}/{x}/{y}.png?key=bbKm0mAybeaIXWDXmQka', {
                    attribution: '&copy; <a href="https://www.maptiler.com/" target="_blank">MapTiler</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 20
                })
            };
        }
        
        // Supabase Configuration
        
        // **CUSTOM MODAL SYSTEM - ALERT, CONFIRM, AND PROMPT**
        
        // Generic modal function
        function showCustomModal(type, message, title, defaultValue = '', okText = 'OK', cancelText = 'Cancel') {
            return new Promise((resolve) => {
                const modal = document.getElementById('customModal');
                const messageEl = document.getElementById('customModalMessage');
                const titleEl = document.getElementById('customModalTitle');
                const iconEl = document.getElementById('customModalIcon');
                const inputContainer = document.getElementById('customModalInput');
                const inputField = document.getElementById('customModalInputField');
                const buttonsContainer = document.getElementById('customModalButtons');
                const okBtn = document.getElementById('customModalOkBtn');
                const cancelBtn = document.getElementById('customModalCancelBtn');
                
                // Set the message and title
                messageEl.textContent = message;
                titleEl.textContent = title;
                
                // Configure modal based on type
                iconEl.className = 'confirm-modal-icon';
                inputContainer.style.display = 'none';
                cancelBtn.style.display = 'none';
                
                switch (type) {
                    case 'alert':
                        iconEl.classList.add('info');
                        iconEl.innerHTML = '<i class="fas fa-info-circle"></i>';
                        okBtn.textContent = okText;
                        break;
                        
                    case 'confirm':
                        iconEl.classList.add('question');
                        iconEl.innerHTML = '<i class="fas fa-question-circle"></i>';
                        okBtn.textContent = okText;
                        cancelBtn.textContent = cancelText;
                        cancelBtn.style.display = 'inline-block';
                        break;
                        
                    case 'prompt':
                        iconEl.classList.add('question');
                        iconEl.innerHTML = '<i class="fas fa-edit"></i>';
                        okBtn.textContent = okText;
                        cancelBtn.textContent = cancelText;
                        cancelBtn.style.display = 'inline-block';
                        inputContainer.style.display = 'block';
                        inputField.value = defaultValue || '';
                        inputField.placeholder = 'Enter value...';
                        break;
                        
                    case 'success':
                        iconEl.classList.add('success');
                        iconEl.innerHTML = '<i class="fas fa-check-circle"></i>';
                        okBtn.textContent = okText;
                        break;
                        
                    case 'warning':
                        iconEl.classList.add('warning');
                        iconEl.innerHTML = '<i class="fas fa-exclamation-triangle"></i>';
                        okBtn.textContent = okText;
                        break;
                        
                    case 'error':
                        iconEl.classList.add('error');
                        iconEl.innerHTML = '<i class="fas fa-times-circle"></i>';
                        okBtn.textContent = okText;
                        break;
                }
                
                // Show the modal
                modal.classList.add('show');
                
                // Focus appropriate element
                setTimeout(() => {
                    if (type === 'prompt') {
                        inputField.focus();
                        inputField.select();
                    } else {
                        okBtn.focus();
                    }
                }, 100);
                
                // Handle button clicks and responses
                const handleOk = () => {
                    // Get the input value BEFORE cleanup
                    const inputValue = (type === 'prompt') ? inputField.value : null;
                    
                    cleanup();
                    
                    switch (type) {
                        case 'alert':
                        case 'success':
                        case 'warning':
                        case 'error':
                            resolve(true);
                            break;
                        case 'confirm':
                            resolve(true);
                            break;
                        case 'prompt':
                            resolve(inputValue);
                            break;
                    }
                };
                
                const handleCancel = () => {
                    cleanup();
                    
                    switch (type) {
                        case 'confirm':
                            resolve(false);
                            break;
                        case 'prompt':
                            resolve(null);
                            break;
                        default:
                            resolve(false);
                            break;
                    }
                };
                
                const handleKeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        handleOk();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        if (type === 'alert' || type === 'success' || type === 'warning' || type === 'error') {
                            handleOk();
                        } else {
                            handleCancel();
                        }
                    }
                };
                
                const handleOverlayClick = (e) => {
                    if (e.target === modal) {
                        if (type === 'alert' || type === 'success' || type === 'warning' || type === 'error') {
                            handleOk();
                        } else {
                            handleCancel();
                        }
                    }
                };
                
                const cleanup = () => {
                    modal.classList.remove('show');
                    okBtn.removeEventListener('click', handleOk);
                    cancelBtn.removeEventListener('click', handleCancel);
                    document.removeEventListener('keydown', handleKeydown);
                    modal.removeEventListener('click', handleOverlayClick);
                    
                    // Clear input field
                    inputField.value = '';
                };
                
                // Add event listeners
                okBtn.addEventListener('click', handleOk);
                cancelBtn.addEventListener('click', handleCancel);
                document.addEventListener('keydown', handleKeydown);
                modal.addEventListener('click', handleOverlayClick);
            });
        }
        
        // Public API functions
        function showAlert(message, title = 'Information') {
            return showCustomModal('alert', message, title);
        }
        
        function showConfirm(message, title = 'Confirm Action') {
            return showCustomModal('confirm', message, title);
        }
        
        function showPrompt(message, defaultValue = '', title = 'Input Required') {
            return showCustomModal('prompt', message, title, defaultValue);
        }
        
        function showSuccess(message, title = 'Success') {
            return showCustomModal('success', message, title);
        }
        
        function showWarning(message, title = 'Warning') {
            return showCustomModal('warning', message, title);
        }
        
        function showError(message, title = 'Error') {
            return showCustomModal('error', message, title);
        }
        
        // Make functions globally available
        window.showAlert = showAlert;
        window.showConfirm = showConfirm;
        window.showPrompt = showPrompt;
        window.showSuccess = showSuccess;
        window.showWarning = showWarning;
        window.showError = showError;
        const SUPABASE_URL = 'https://xravncpxynlzzewsqawh.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhyYXZuY3B4eW5senpld3NxYXdoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI4NDk5MTEsImV4cCI6MjA2ODQyNTkxMX0.2IE-dzQDVvq8b9u7C0oqy35FwVVMu96OGHBOYQEMSZw';
        let supabase;
        let currentUser = null;
        
        // Initialize Supabase client
        function initializeSupabase() {
            try {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('Supabase client initialized successfully');
                
                // Show warning about missing user_id column
                console.warn(`
⚠️  IMPORTANT: Your layers table is missing the 'user_id' column.
This means layers won't be properly isolated per user.

To fix this, run this SQL in your Supabase SQL Editor:

ALTER TABLE layers ADD COLUMN user_id UUID REFERENCES auth.users(id);
ALTER TABLE layers ALTER COLUMN user_id SET NOT NULL;

-- Enable Row Level Security
ALTER TABLE layers ENABLE ROW LEVEL SECURITY;

-- Add RLS policies
CREATE POLICY "Users can view own layers" ON layers FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own layers" ON layers FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own layers" ON layers FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own layers" ON layers FOR DELETE USING (auth.uid() = user_id);
                `);
                
                console.log('Make sure you have created the "layers" table in your Supabase database with the following SQL:');
                console.log(`
CREATE TABLE layers (
  id SERIAL PRIMARY KEY,
  layer_id VARCHAR(50) UNIQUE NOT NULL,
  name VARCHAR(255) NOT NULL,
  geojson_data JSONB NOT NULL,
  style JSONB,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add RLS (Row Level Security) policies
ALTER TABLE layers ENABLE ROW LEVEL SECURITY;

-- Users can only see and manage their own layers
CREATE POLICY "Users can view own layers" ON layers FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own layers" ON layers FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update own layers" ON layers FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete own layers" ON layers FOR DELETE USING (auth.uid() = user_id);
                `);
                return true;
            } catch (error) {
                console.error('Error initializing Supabase:', error);
                return false;
            }
        }

        // Authentication Functions
        
        // Check if user is logged in
        async function checkAuthState() {
            try {
                const { data: { session }, error } = await supabase.auth.getSession();
                
                if (error) {
                    console.error('Error checking auth state:', error);
                    return null;
                }
                
                if (session && session.user) {
                    currentUser = session.user;
                    console.log('User is logged in:', currentUser.email);
                    return session.user;
                }
                
                return null;
            } catch (error) {
                console.error('Error checking auth state:', error);
                return null;
            }
        }

        // Sign in user
        async function signInUser(email, password) {
            try {
                const { data, error } = await supabase.auth.signInWithPassword({
                    email: email,
                    password: password
                });

                if (error) {
                    throw error;
                }

                if (data.user) {
                    currentUser = data.user;
                    console.log('User signed in successfully:', currentUser.email);
                    return { success: true, user: data.user };
                }

                return { success: false, error: 'No user data received' };
            } catch (error) {
                console.error('Sign in error:', error);
                return { success: false, error: error.message };
            }
        }

        // Sign out user
        async function signOutUser() {
            try {
                const { error } = await supabase.auth.signOut();
                
                if (error) {
                    throw error;
                }

                currentUser = null;
                console.log('User signed out successfully');
                showLoginPage();
                return { success: true };
            } catch (error) {
                console.error('Sign out error:', error);
                return { success: false, error: error.message };
            }
        }

        // Show/Hide Login Page
        function showLoginPage() {
            document.getElementById('loginContainer').style.display = 'flex';
            document.getElementById('webgisContainer').style.display = 'none';
        }

        function hideLoginPage() {
            document.getElementById('loginContainer').style.display = 'none';
            document.getElementById('webgisContainer').style.display = 'flex';
        }
        
        // Show notification to user
        function showNotification(message, type = 'info', duration = 3000) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            
            // Style the notification
            const baseStyles = {
                position: 'fixed',
                top: '100px',
                right: '20px',
                padding: '12px 20px',
                borderRadius: '8px',
                color: 'white',
                fontWeight: '500',
                fontSize: '14px',
                zIndex: '10001',
                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.3)',
                animation: 'slideInRight 0.3s ease-out',
                maxWidth: '350px',
                wordWrap: 'break-word'
            };
            
            // Type-specific styles
            const typeStyles = {
                success: { backgroundColor: '#059669', border: '1px solid #065f46' },
                error: { backgroundColor: '#dc2626', border: '1px solid #991b1b' },
                info: { backgroundColor: '#0891b2', border: '1px solid #0e7490' }
            };
            
            // Apply styles
            Object.assign(notification.style, baseStyles, typeStyles[type] || typeStyles.info);
            
            // Add to body
            document.body.appendChild(notification);
            
            // Remove after duration
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, duration);
        }
        
        // Selection tool variables
        let drawControl;
        let drawnItems;
        let isSelectionActive = false;
        let selectedFeatures = [];
        let highlightedLayers = [];
        let popupsDisabled = false; // Flag to track if popups are disabled during selection

        // Freehand drawing variables - Two-click mode
        let isDrawing = false;
        let drawingPath = [];
        let currentDrawingLayer = null;
        let currentFillLayer = null;
        let activeSelectionLayerId = null; // Track which layer is active for selection
        let hasStartedDrawing = false; // Track if first click has been made (for two-click mode)

        // Middle mouse button panning variables
        let isMiddleMouseDown = false;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', async function() {
            // Initialize Supabase first
            if (!initializeSupabase()) {
                await showError('Failed to connect to Supabase. Some features may not work properly.', 'Connection Error');
                return;
            }
            
            // Check if user is already logged in
            const user = await checkAuthState();
            
            if (user) {
                // User is logged in, show WebGIS interface
                currentUser = user;
                document.getElementById('userEmail').textContent = user.email;
                hideLoginPage();
                initializeWebGIS();
            } else {
                // User not logged in, show login page
                showLoginPage();
                setupLoginListeners();
            }
        });

        // Initialize WebGIS components
        function initializeWebGIS() {
            initializeMap();
            initializeSidebar();
            initializeEventListeners();
            loadInitialData();
        }

        // Initialize the Leaflet map
        function initializeMap() {
            // Initialize basemap definitions first
            initializeBasemaps();
            
            map = L.map('map', {
                center: [14.5995, 120.9842], // Philippines center
                zoom: 6,
                zoomControl: true,
                dragging: true, // Enable normal left-click dragging
                doubleClickZoom: false, // Disable double-click zoom
                boxZoom: false, // Disable Shift+drag zoom box
                scrollWheelZoom: true // Default scroll wheel zoom behavior
            });

            // Set initial basemap to Google Satellite (no labels) as default
            currentBasemap = basemaps['google-satellite'];
            currentBasemap.addTo(map);

            // Move zoom control to bottom
            map.zoomControl.setPosition('bottomright');
            
            // Initialize selection tools
            initializeSelectionTools();
            
            // Add middle mouse button panning functionality
            initializeMiddleMousePanning();
            
            // Add Ctrl+right-click zoom box functionality
            initializeZoomBox(map);
            
            // Setup map context menu for basemap switching
            setupMapContextMenu();
        }

        // Initialize sidebar
        function initializeSidebar() {
            sidebar = L.control.sidebar('sidebar').addTo(map);
        }

        // Basemap Functions
        let currentLabels = null;
        let previewBasemap = null;
        let previewLabels = null;
        let originalBasemap = null;
        let originalLabels = null;

        function switchBasemap(basemapKey) {
            console.log(`Attempting to switch to basemap: ${basemapKey}`);
            
            // Remove current basemap
            if (currentBasemap) {
                map.removeLayer(currentBasemap);
            }
            
            // Remove current labels
            if (currentLabels) {
                map.removeLayer(currentLabels);
                currentLabels = null;
            }
            
            // Verify basemap exists
            if (!basemaps[basemapKey]) {
                console.error(`Basemap '${basemapKey}' not found in basemaps object`);
                console.log('Available basemaps:', Object.keys(basemaps));
                return;
            }
            
            // Add new basemap
            currentBasemap = basemaps[basemapKey];
            map.addLayer(currentBasemap);
            
            // Send basemap to back so it doesn't cover other layers
            currentBasemap.bringToBack();
            
            // Force map to re-render tiles
            setTimeout(() => {
                map.invalidateSize();
                map.getContainer().focus(); // Ensure map has focus for proper rendering
            }, 100);
            
            console.log(`Successfully switched basemap to: ${basemapKey}`);
        }

        function toggleLabels(show, layerName) {
            console.log(`Toggling labels - show: ${show}, layer: ${layerName}`);
            
            // Remove existing labels
            if (currentLabels) {
                map.removeLayer(currentLabels);
                currentLabels = null;
            }
            
            // Add new labels if requested
            if (show && layerName && basemaps[layerName]) {
                currentLabels = basemaps[layerName];
                map.addLayer(currentLabels);
                console.log(`Added labels: ${layerName}`);
                
                // Force map to re-render
                setTimeout(() => {
                    map.invalidateSize();
                }, 50);
            }
        }

        function previewBasemapOnHover(basemapKey, labelKey = null) {
            console.log(`Previewing basemap: ${basemapKey}, labels: ${labelKey}`);
            
            // Store original state if this is the first preview
            if (!originalBasemap) {
                originalBasemap = currentBasemap;
                originalLabels = currentLabels;
            }
            
            // Remove current preview layers
            if (previewBasemap) {
                map.removeLayer(previewBasemap);
                previewBasemap = null;
            }
            if (previewLabels) {
                map.removeLayer(previewLabels);
                previewLabels = null;
            }
            
            // Remove current basemap and labels temporarily for preview
            if (currentBasemap) {
                map.removeLayer(currentBasemap);
            }
            if (currentLabels) {
                map.removeLayer(currentLabels);
            }
            
            // Add preview basemap
            if (basemaps[basemapKey]) {
                previewBasemap = basemaps[basemapKey];
                map.addLayer(previewBasemap);
                previewBasemap.bringToBack();
                
                // Add preview labels if specified
                if (labelKey && basemaps[labelKey]) {
                    previewLabels = basemaps[labelKey];
                    map.addLayer(previewLabels);
                }
                
                // Force map to re-render preview
                setTimeout(() => {
                    map.invalidateSize();
                }, 50);
            } else {
                console.error(`Preview basemap '${basemapKey}' not found`);
            }
        }

        function revertToOriginalBasemap() {
            // Only revert if we have an original to revert to
            if (!originalBasemap) {
                return;
            }
            
            // Remove preview layers
            if (previewBasemap) {
                map.removeLayer(previewBasemap);
                previewBasemap = null;
            }
            if (previewLabels) {
                map.removeLayer(previewLabels);
                previewLabels = null;
            }
            
            // Restore original basemap
            if (originalBasemap) {
                // Remove current basemap first
                if (currentBasemap && currentBasemap !== originalBasemap) {
                    map.removeLayer(currentBasemap);
                }
                
                map.addLayer(originalBasemap);
                originalBasemap.bringToBack();
                currentBasemap = originalBasemap;
                originalBasemap = null;
            }
            
            // Restore original labels
            if (originalLabels) {
                // Remove current labels first
                if (currentLabels && currentLabels !== originalLabels) {
                    map.removeLayer(currentLabels);
                }
                
                map.addLayer(originalLabels);
                currentLabels = originalLabels;
                originalLabels = null;
            }
            
            // Force map to re-render
            setTimeout(() => {
                map.invalidateSize();
            }, 50);
        }

        function setupMapContextMenu() {
            map.on('contextmenu', function(e) {
                // Check if the click was on a feature or empty map
                if (!isClickOnFeature(e)) {
                    showMapContextMenu(e.containerPoint);
                }
            });

            // Add event listeners for basemap menu items with hover preview
            const basemapOptions = document.querySelectorAll('.basemap-option');
            basemapOptions.forEach(option => {
                // Hover preview functionality
                option.addEventListener('mouseenter', function(e) {
                    const basemapKey = this.getAttribute('data-basemap');
                    if (basemapKey && basemaps[basemapKey]) {
                        // Store original state before preview
                        originalBasemap = currentBasemap;
                        originalLabels = currentLabels;
                        
                        // Check if this satellite option has labels
                        const labelCheckbox = this.querySelector('.label-checkbox');
                        const labelsKey = labelCheckbox ? labelCheckbox.getAttribute('data-labels') : null;
                        const showLabels = labelCheckbox ? labelCheckbox.checked : false;
                        
                        previewBasemapOnHover(basemapKey, showLabels ? labelsKey : null);
                    }
                });
                
                option.addEventListener('mouseleave', function(e) {
                    // Only revert if we're still leaving and not entering another option
                    setTimeout(() => {
                        if (!document.querySelector('.basemap-option:hover')) {
                            revertToOriginalBasemap();
                        }
                    }, 50);
                });
                
                // Click to permanently switch basemap
                option.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const basemapKey = this.getAttribute('data-basemap');
                    
                    // Check if this is a satellite option with labels
                    const labelCheckbox = this.querySelector('.label-checkbox');
                    
                    if (labelCheckbox) {
                        const labelsKey = labelCheckbox.getAttribute('data-labels');
                        const showLabels = labelCheckbox.checked;
                        
                        switchBasemap(basemapKey);
                        if (showLabels) {
                            toggleLabels(true, labelsKey);
                        } else {
                            toggleLabels(false);
                        }
                    } else {
                        switchBasemap(basemapKey);
                        toggleLabels(false); // Clear any existing labels
                    }
                    
                    // Clear preview state
                    originalBasemap = null;
                    originalLabels = null;
                    
                    // Close context menu
                    hideMapContextMenu();
                });
            });
            
            // Handle label checkbox clicks separately to prevent basemap switching
            const labelCheckboxes = document.querySelectorAll('.label-checkbox');
            labelCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent triggering the basemap option click
                    
                    const labelsKey = this.getAttribute('data-labels');
                    const showLabels = this.checked;
                    
                    // Apply labels immediately during preview
                    if (showLabels) {
                        toggleLabels(true, labelsKey);
                    } else {
                        toggleLabels(false);
                    }
                });
            });

            // Hide context menu when clicking elsewhere
            document.addEventListener('click', function(e) {
                const mapContextMenu = e.target ? e.target.closest('#mapContextMenu') : null;
                if (!mapContextMenu) {
                    hideMapContextMenu();
                    revertToOriginalBasemap();
                }
            });

            // Hide context menu on map click
            map.on('click', function() {
                hideMapContextMenu();
                revertToOriginalBasemap();
            });
        }

        function isClickOnFeature(e) {
            // Check if any visible layers contain features at this point
            let hasFeature = false;
            
            layers.forEach((layerInfo, layerId) => {
                if (layerInfo.visible && layerInfo.layer) {
                    // Check if this layer has features at the clicked point
                    layerInfo.layer.eachLayer(function(featureLayer) {
                        if (featureLayer.getBounds && featureLayer.getBounds().contains(e.latlng)) {
                            hasFeature = true;
                        }
                    });
                }
            });
            
            return hasFeature;
        }

        function showMapContextMenu(containerPoint) {
            const contextMenu = document.getElementById('mapContextMenu');
            
            // Position the context menu at cursor location
            contextMenu.style.display = 'block';
            contextMenu.style.left = containerPoint.x + 'px';
            contextMenu.style.top = containerPoint.y + 'px';
            
            // Ensure menu stays within viewport
            const rect = contextMenu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            if (rect.right > viewportWidth) {
                contextMenu.style.left = (containerPoint.x - rect.width) + 'px';
            }
            if (rect.bottom > viewportHeight) {
                contextMenu.style.top = (containerPoint.y - rect.height) + 'px';
            }
        }

        function hideMapContextMenu() {
            const contextMenu = document.getElementById('mapContextMenu');
            contextMenu.style.display = 'none';
        }

        // Initialize event listeners
        function initializeEventListeners() {
            // Disable default browser context menu for the entire WebGIS interface
            document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            });

            // Close context menu when clicking anywhere (but preserve context variables for actions)
            document.addEventListener('click', function(e) {
                // Only hide the context menu if clicking outside of it
                const contextMenu = document.getElementById('layerContextMenu');
                if (contextMenu && !contextMenu.contains(e.target)) {
                    hideLayerContextMenu();
                }
            });

            // Tool button listeners - only Add Data, Filter, and Print buttons remain in header
            // Layers and Legend are accessed via sidebar tabs
            
            // Add Data button will trigger file dialog directly (handled by IIFE at bottom)
            // This is handled by the IIFE function at the bottom of the script

            // Filter and Print buttons - Filter now has comprehensive functionality
            // Filter functionality is now handled by the new filter panel system
            // No button listener needed as the panel is always accessible

            document.getElementById('printBtn').addEventListener('click', () => {
                document.getElementById('printModal').classList.remove('hidden');
            });

            // Modal close listeners (but modals won't be opened from header buttons)
            setupModalListeners();
            
            // File upload listeners for modal (if needed)
            setupFileUploadListeners();
            
            // Symbology listeners
            setupSymbologyListeners();
            
            // Print layout editor listeners
            setupPrintListeners();
            
            // Selection tool listeners
            setupSelectionListeners();

            // New comprehensive filter system
            setupNewFilterListeners();

            // Context menu listeners
            setupLayerContextMenuListeners();

            // Supabase button listeners
            setupSupabaseButtonListeners();

            // Logout button listener
            setupLogoutListener();
        }

        // Setup login page event listeners
        function setupLoginListeners() {
            const loginForm = document.getElementById('loginForm');
            const loginButton = document.getElementById('loginButton');
            const errorMessage = document.getElementById('errorMessage');
            const forgotPasswordLink = document.getElementById('forgotPasswordLink');
            const passwordToggle = document.getElementById('passwordToggle');
            const passwordInput = document.getElementById('password');
            const passwordToggleIcon = document.getElementById('passwordToggleIcon');

            // Password visibility toggle functionality
            passwordToggle.addEventListener('click', function(e) {
                e.preventDefault();
                
                if (passwordInput.type === 'password') {
                    // Show password
                    passwordInput.type = 'text';
                    passwordToggleIcon.classList.remove('fa-eye');
                    passwordToggleIcon.classList.add('fa-eye-slash');
                } else {
                    // Hide password
                    passwordInput.type = 'password';
                    passwordToggleIcon.classList.remove('fa-eye-slash');
                    passwordToggleIcon.classList.add('fa-eye');
                }
            });

            // Handle login form submission
            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const email = document.getElementById('email').value.trim();
                const password = document.getElementById('password').value;

                // Validate inputs
                if (!email || !password) {
                    showError('Please fill in all fields.');
                    return;
                }

                // Show loading state
                setLoginLoading(true);
                hideError();

                // Attempt sign in
                const result = await signInUser(email, password);

                if (result.success) {
                    // Success - redirect to WebGIS
                    currentUser = result.user;
                    document.getElementById('userEmail').textContent = result.user.email;
                    hideLoginPage();
                    initializeWebGIS();
                } else {
                    // Show error
                    setLoginLoading(false);
                    showError(result.error || 'Sign in failed. Please try again.');
                }
            });

            // Handle forgot password link (placeholder)
            forgotPasswordLink.addEventListener('click', async (e) => {
                e.preventDefault();
                await showAlert('Password reset functionality will be implemented soon. Please contact your administrator.', 'Feature Not Available');
            });

            // Helper functions for login UI
            function showError(message) {
                errorMessage.textContent = message;
                errorMessage.style.display = 'block';
            }

            function hideError() {
                errorMessage.style.display = 'none';
            }

            function setLoginLoading(loading) {
                const loginButton = document.getElementById('loginButton');
                
                if (loading) {
                    loginButton.disabled = true;
                    loginButton.innerHTML = '<div class="loading-spinner"></div>Signing in...';
                } else {
                    loginButton.disabled = false;
                    loginButton.innerHTML = 'Sign In to WebGIS';
                }
            }
        }

        // Setup logout functionality
        function setupLogoutListener() {
            document.getElementById('logoutButton').addEventListener('click', async () => {
                const confirmed = await showConfirm('Are you sure you want to logout?', 'Logout Confirmation');
                if (confirmed) {
                    const result = await signOutUser();
                    if (!result.success) {
                        await showError('Error logging out: ' + result.error, 'Logout Error');
                    }
                }
            });
        }

        // Setup Supabase button event listeners (cloud buttons removed)
        function setupSupabaseButtonListeners() {
            // Cloud data functionality has been removed
            console.log('Cloud data buttons removed - setupSupabaseButtonListeners() no longer needed');
        }

        // Setup modal event listeners
        function setupModalListeners() {
            // Add Data Modal
            document.getElementById('closeAddDataModal').addEventListener('click', () => {
                document.getElementById('addDataModal').classList.add('hidden');
            });

            document.getElementById('cancelUpload').addEventListener('click', () => {
                document.getElementById('addDataModal').classList.add('hidden');
            });

            // Filter Modal
            document.getElementById('closeFilterModal').addEventListener('click', () => {
                document.getElementById('filterModal').classList.add('hidden');
            });

            // Print Modal
            document.getElementById('closePrintModal').addEventListener('click', () => {
                document.getElementById('printModal').classList.add('hidden');
                
                // Cleanup print map instance
                if (window.printMap) {
                    try {
                        window.printMap.remove();
                        window.printMap = null;
                    } catch (error) {
                        console.warn('Error cleaning up print map:', error);
                    }
                }
                
                // **SAFETY: Ensure all layers are visible on main map after closing**
                console.log('🖨️ Print layout editor closed - ensuring layer visibility');
                setTimeout(() => {
                    ensureAllLayersVisible();
                }, 100);
            });

            // Symbology Modal
            document.getElementById('closeSymbologyModal').addEventListener('click', () => {
                document.getElementById('symbologyModal').classList.add('hidden');
            });
        }

        // Update print map when main map layers change
        function updatePrintMapLayers() {
            if (window.printMap && !document.getElementById('printModal').classList.contains('hidden')) {
                console.log('🔄 Updating print map layers to match main map...');
                createPrintMapInstance();
            }
        }

        // Setup file upload listeners
        function setupFileUploadListeners() {
            document.getElementById('uploadFile').addEventListener('click', handleFileUpload);
        }

        // Handle file upload
        async function handleFileUpload() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];

            if (!file) {
                await showWarning('Please select a file to upload.', 'No File Selected');
                return;
            }

            // Check file size (50MB limit)
            if (file.size > 50 * 1024 * 1024) {
                await showError('File size exceeds 50MB limit.', 'File Too Large');
                return;
            }

            // Check file type
            const validTypes = ['application/json', 'application/geo+json', 'application/vnd.google-earth.kml+xml'];
            const isValidType = validTypes.includes(file.type) || 
                               file.name.toLowerCase().endsWith('.geojson') || 
                               file.name.toLowerCase().endsWith('.json') || 
                               file.name.toLowerCase().endsWith('.kml') ||
                               file.name.toLowerCase().endsWith('.kmz');

            if (!isValidType) {
                await showError('Please upload a valid GeoJSON, KML, or KMZ file.', 'Invalid File Type');
                return;
            }

            showUploadProgress();

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    let geoData;
                    
                    if (file.name.toLowerCase().endsWith('.kml')) {
                        // Parse KML
                        const parser = new DOMParser();
                        const kmlDoc = parser.parseFromString(e.target.result, 'text/xml');
                        geoData = toGeoJSON.kml(kmlDoc);
                    } else if (file.name.toLowerCase().endsWith('.kmz')) {
                        // Parse KMZ
                        function processModalKMZ(arrayBuffer) {
                            JSZip.loadAsync(arrayBuffer).then(zip => {
                                let kmlFile = null;
                                zip.forEach((relativePath, zipEntry) => {
                                    if (relativePath.toLowerCase().endsWith('.kml')) {
                                        kmlFile = zipEntry;
                                    }
                                });
                                if (!kmlFile) {
                                    showError('No KML file found inside KMZ.', 'Invalid KMZ File');
                                    hideUploadProgress();
                                    return;
                                }
                                kmlFile.async('string').then(kmlText => {
                                    try {
                                        const parser = new DOMParser();
                                        const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
                                        const geoData = toGeoJSON.kml(kmlDoc);
                                        if (!geoData || geoData.type !== 'FeatureCollection' || !Array.isArray(geoData.features)) {
                                            showError('Invalid or empty KML inside KMZ file.', 'Invalid KMZ Content');
                                            hideUploadProgress();
                                            return;
                                        }
                                        addDataToMap(geoData, file.name);
                                        hideUploadProgress();
                                        document.getElementById('addDataModal').classList.add('hidden');
                                        document.getElementById('fileInput').value = '';
                                    } catch (err) {
                                        showError('Unable to read this file. Please upload a valid KMZ.', 'KMZ Read Error');
                                        hideUploadProgress();
                                    }
                                }).catch(() => {
                                    showError('Unable to read this file. Please upload a valid KMZ.', 'KMZ Read Error');
                                    hideUploadProgress();
                                });
                            }).catch(() => {
                                showError('Unable to read this file. Please upload a valid KMZ.', 'KMZ Read Error');
                                hideUploadProgress();
                            });
                        }
                        if (typeof JSZip === 'undefined') {
                            const script = document.createElement('script');
                            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                            script.onload = () => processModalKMZ(e.target.result);
                            document.body.appendChild(script);
                        } else {
                            processModalKMZ(e.target.result);
                        }
                        return;
                    } else {
                        // Parse GeoJSON
                        geoData = JSON.parse(e.target.result);
                    }

                    addDataToMap(geoData, file.name);
                    hideUploadProgress();
                    document.getElementById('addDataModal').classList.add('hidden');
                    fileInput.value = '';

                } catch (error) {
                    console.error('Error parsing file:', error);
                    showError('Error parsing file. Please ensure it\'s a valid GeoJSON, KML, or KMZ file.', 'File Parse Error');
                    hideUploadProgress();
                }
            };

            if (file.name.toLowerCase().endsWith('.kmz')) {
                reader.readAsArrayBuffer(file);
            } else {
                reader.readAsText(file);
            }
        }

        // Show upload progress
        function showUploadProgress() {
            document.getElementById('uploadProgress').classList.remove('hidden');
            
            let progress = 0;
            const interval = setInterval(() => {
                progress += 10;
                document.getElementById('progressBar').style.width = progress + '%';
                
                if (progress >= 100) {
                    clearInterval(interval);
                }
            }, 100);
        }

        // Hide upload progress
        function hideUploadProgress() {
            document.getElementById('uploadProgress').classList.add('hidden');
            document.getElementById('progressBar').style.width = '0%';
        }

        // Add data to map with preloaded style (prevents symbology flash for Aera layer)
        function addDataToMapWithPreloadedStyle(geoData, fileName, preloadedStyle, isPermanent = false) {
            const layerId = 'layer_' + (++layerCounter);
            const layerName = fileName.replace(/\.(geojson|json|kml)$/i, '');

            console.log(`🎨 Adding layer with preloaded style (no flash):`, {
                layerId: layerId,
                layerName: layerName,
                fileName: fileName,
                isPermanent: isPermanent,
                hasPreloadedStyle: !!preloadedStyle
            });

            // Validate required parameters
            if (!geoData || !fileName || !layerId) {
                console.error('Cannot add layer: missing required parameters');
                return null;
            }

            // Check if this permanent layer already exists
            if (isPermanent) {
                const existingPermanentLayer = Array.from(layers.values()).find(l => 
                    l.isPermanent && l.name === layerName
                );
                if (existingPermanentLayer) {
                    console.log(`Permanent layer "${layerName}" already exists, skipping duplicate`);
                    return null;
                }
            }

            // Use preloaded style directly - this prevents the flash of default symbology
            let finalStyle = preloadedStyle;
            
            // Apply style based on symbology type
            let layerStyleFunction;
            
            if (preloadedStyle.categoricalField && preloadedStyle.colorMap) {
                // Categorical symbology - apply color mapping per feature
                console.log('📊 Applying categorical symbology with preloaded colors');
                layerStyleFunction = function(feature) {
                    const fieldValue = feature.properties[preloadedStyle.categoricalField];
                    const color = preloadedStyle.colorMap[fieldValue] || '#14b8a6'; // fallback color
                    return {
                        color: preloadedStyle.strokeColor || '#000000',
                        weight: preloadedStyle.strokeWidth || 0.5,
                        opacity: preloadedStyle.strokeOpacity || 1.0,
                        fillColor: color,
                        fillOpacity: preloadedStyle.fillOpacity || 1.0
                    };
                };
            } else {
                // Single symbol symbology - use consistent style
                console.log('🎯 Applying single symbol symbology with preloaded colors');
                layerStyleFunction = {
                    color: preloadedStyle.strokeColor || preloadedStyle.color || '#000000',
                    weight: preloadedStyle.strokeWidth || preloadedStyle.weight || 0.5,
                    opacity: preloadedStyle.strokeOpacity || preloadedStyle.opacity || 1.0,
                    fillColor: preloadedStyle.fillColor || '#888888',
                    fillOpacity: preloadedStyle.fillOpacity || 0.7
                };
            }

            // Create layer with the correct style applied immediately
            const layer = L.geoJSON(geoData, {
                renderer: L.canvas(), // Force canvas rendering for leaflet-image export compatibility
                style: layerStyleFunction,
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="text-sm">';
                        for (let key in feature.properties) {
                            popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                        popupContent += '</div>';
                        
                        // Use right-click popup binding (respects selection mode)
                        safeBindPopup(layer, popupContent);
                    }
                }
            }).addTo(map);

            // Store layer information with preloaded style
            layers.set(layerId, {
                layer: layer,
                name: layerName,
                data: geoData,
                visible: true,
                style: finalStyle, // Store the complete preloaded style object
                originalData: JSON.parse(JSON.stringify(geoData)),
                opacity: preloadedStyle.fillOpacity || 1.0,
                supabaseLayerId: null,
                isPermanent: isPermanent,
                fromDatabase: false,
                layerId: layerId,
                createdAt: new Date().toISOString()
            });

            // Add to layer order for consistent display
            layerOrder.unshift(layerId);

            console.log(`✅ Layer "${layerName}" created with preloaded symbology - no flash occurred`);

            // Update UI elements
            updateLayersList();
            updateLegend();

            // Fit map bounds for permanent layers like Aera
            if (isPermanent) {
                setTimeout(() => {
                    try {
                        map.fitBounds(layer.getBounds(), { padding: [20, 20] });
                        console.log(`Map bounds fitted to ${layerName} layer`);
                    } catch (error) {
                        console.warn(`Could not fit bounds for ${layerName}:`, error);
                    }
                }, 200);
            }

            return layerId;
        }

        // Add data to map
        function addDataToMap(geoData, fileName, fromDatabase = false, supabaseLayerId = null, isPermanent = false) {
            const layerId = 'layer_' + (++layerCounter);
            const layerName = fileName.replace(/\.(geojson|json|kml)$/i, '');

            console.log(`Adding layer to map:`, {
                layerId: layerId,
                layerName: layerName,
                fileName: fileName,
                fromDatabase: fromDatabase,
                supabaseLayerId: supabaseLayerId,
                isPermanent: isPermanent
            });

            // Validate required parameters
            if (!geoData) {
                console.error('Cannot add layer: geoData is missing');
                return null;
            }
            if (!fileName) {
                console.error('Cannot add layer: fileName is missing');
                return null;
            }
            if (!layerId) {
                console.error('Cannot add layer: layerId generation failed');
                return null;
            }

            // Check if this is a permanent layer (like Aera.geojson) that already exists
            if (isPermanent) {
                const existingPermanentLayer = Array.from(layers.values()).find(l => 
                    l.isPermanent && l.name === layerName
                );
                if (existingPermanentLayer) {
                    console.log(`Permanent layer "${layerName}" already exists, skipping duplicate`);
                    return null;
                }
            }

            const style = {
                color: '#000000',
                weight: 0.5,
                opacity: 1.0,
                fillColor: '#888888',
                fillOpacity: 0.7
            };

            const layer = L.geoJSON(geoData, {
                renderer: L.canvas(), // Force canvas rendering for leaflet-image export compatibility
                style: style,
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="text-sm">';
                        for (let key in feature.properties) {
                            popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                        popupContent += '</div>';
                        
                        // Use right-click popup binding (respects selection mode)
                        safeBindPopup(layer, popupContent);
                    }
                }
            }).addTo(map);

            // Store layer information with Supabase reference if applicable
            layers.set(layerId, {
                layer: layer,
                name: layerName,
                data: geoData, // Store original GeoJSON data
                visible: true,
                style: style,
                originalData: JSON.parse(JSON.stringify(geoData)), // Deep copy for filters
                opacity: 1.0, // Default opacity (100%)
                supabaseLayerId: supabaseLayerId, // Track the Supabase layer ID for database layers
                isPermanent: isPermanent, // Mark permanent layers (like Aera.geojson)
                fromDatabase: fromDatabase, // Track if this came from database
                layerId: layerId, // Store the local layer ID for reference
                createdAt: new Date().toISOString() // Track when layer was created locally
            });

            console.log(`Layer stored in layers map:`, {
                layerId: layerId,
                layerName: layerName,
                mapSize: layers.size,
                stored: layers.has(layerId)
            });

            // Add to layer order (new layers go to the beginning for top display)
            layerOrder.unshift(layerId);

            // Zoom to layer
            map.fitBounds(layer.getBounds());

            // Update UI (but skip legend update during loading from database)
            updateLayersList();
            if (!fromDatabase) {
                // Only update legend immediately for user-uploaded layers
                updateLegend();
            }
            // Note: Legend will be updated after symbology is applied for database layers

            // Save to Supabase ONLY if:
            // 1. Not already from database
            // 2. Supabase is connected
            // 3. Not a permanent/built-in layer
            // 4. Not the Aera layer specifically
            if (!fromDatabase && supabase && !isPermanent && 
                layerName !== 'Aera' && layerName !== 'Aera.geojson') {
                // Add async handling to show user feedback
                console.log(`Starting async save for layer "${layerName}" to Supabase...`);
                saveLayerToSupabase(layerId, layerName, geoData).then(() => {
                    // Update UI after successful save to show cloud icon
                    updateLayersList();
                    console.log(`Layer "${layerName}" save completed and UI updated`);
                }).catch(error => {
                    console.error('Failed to save layer to cloud:', error);
                    showNotification(`Failed to save layer "${layerName}" to cloud. Layer will only be available locally.`, 'error');
                });
            } else if (isPermanent) {
                console.log(`Permanent layer "${layerName}" loaded successfully (not saved to cloud)`);
            }

            // Update filter system with new layer
            setTimeout(() => {
                console.log(`Layer ${layerId} added, updating filter system...`);
                populateFilterLayers();
            }, 50);

            // Return the layer ID for reference
            return layerId;
        }

        // Supabase Functions
        
        // Save layer to Supabase
        async function saveLayerToSupabase(layerId, layerName, geoData) {
            try {
                if (!currentUser) {
                    console.error('User not authenticated, cannot save layer');
                    showNotification('Please log in to save layers to cloud', 'error');
                    return false;
                }

                console.log(`Attempting to save layer "${layerName}" to Supabase...`);

                // First check if a layer with the same name already exists for this user
                // Note: Temporarily skip user_id check if column doesn't exist
                let existingLayers = [];
                let checkError = null;
                
                try {
                    const result = await supabase
                        .from('layers')
                        .select('id, name')
                        .eq('name', layerName)
                        .eq('user_id', currentUser.id); // Only check current user's layers
                    
                    existingLayers = result.data || [];
                    checkError = result.error;
                } catch (error) {
                    console.warn('Could not check for existing layers:', error);
                    existingLayers = [];
                    checkError = null;
                }

                if (checkError) {
                    console.error('Error checking for existing layers:', checkError);
                    showNotification(`Error checking cloud storage: ${checkError.message}`, 'error');
                    return false;
                }

                // If layer exists, update it instead of creating a new one
                if (existingLayers && existingLayers.length > 0) {
                    console.log(`Updating existing layer "${layerName}" in Supabase...`);
                    
                    // Get layer style safely
                    const layerInfo = layers.get(layerId);
                    const layerStyle = layerInfo ? layerInfo.style : null;
                    
                    const { data, error } = await supabase
                        .from('layers')
                        .update({
                            geojson_data: geoData,
                            style: layerStyle,
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', existingLayers[0].id)
                        .eq('user_id', currentUser.id) // Ensure user can only update own layers
                        .select();

                    if (error) {
                        console.error('Error updating layer in Supabase:', error);
                        showNotification(`Failed to update layer "${layerName}" in cloud: ${error.message}`, 'error');
                        return false;
                    } else if (data && data.length > 0) {
                        // Store the Supabase ID in the layer info
                        if (layerInfo) {
                            layerInfo.supabaseLayerId = data[0].id;
                            layerInfo.fromDatabase = true; // Mark as database layer
                            console.log(`Layer "${layerName}" updated with Supabase ID: ${data[0].id}. LayerInfo updated:`, {
                                layerId: layerId,
                                supabaseLayerId: layerInfo.supabaseLayerId,
                                fromDatabase: layerInfo.fromDatabase,
                                updatedData: data[0]
                            });
                        }
                        console.log('Layer updated in Supabase successfully:', layerName, 'with ID:', data[0].id);
                        showNotification(`Layer "${layerName}" updated in AKL cloud`, 'success');
                        return true;
                    }
                } else {
                    // Create new layer
                    console.log(`Creating new layer "${layerName}" in Supabase...`);
                    
                    // Get layer style safely
                    const layerInfo = layers.get(layerId);
                    const layerStyle = layerInfo ? layerInfo.style : null;
                    
                    const { data, error } = await supabase
                        .from('layers')
                        .insert([
                            {
                                layer_id: layerId,
                                name: layerName,
                                geojson_data: geoData,
                                created_at: new Date().toISOString(),
                                style: layerStyle,
                                user_id: currentUser.id // Associate with current user
                            }
                        ])
                        .select();

                    if (error) {
                        console.error('Error saving layer to Supabase:', error);
                        showNotification(`Failed to save layer "${layerName}" to cloud: ${error.message}`, 'error');
                        return false;
                    } else if (data && data.length > 0) {
                        // Store the Supabase ID in the layer info for future reference
                        if (layerInfo) {
                            layerInfo.supabaseLayerId = data[0].id;
                            layerInfo.fromDatabase = true; // Mark as database layer
                            console.log(`Layer "${layerName}" saved with Supabase ID: ${data[0].id}. LayerInfo updated:`, {
                                layerId: layerId,
                                supabaseLayerId: layerInfo.supabaseLayerId,
                                fromDatabase: layerInfo.fromDatabase,
                                savedData: data[0]
                            });
                        }
                        console.log('Layer saved to Supabase successfully:', layerName, 'with ID:', data[0].id);
                        showNotification(`Layer "${layerName}" saved to AKL cloud`, 'success');
                        return true;
                    }
                }
                
                return false; // If we reach here, something went wrong
            } catch (error) {
                console.error('Network error saving to Supabase:', error);
                showNotification(`Network error saving layer "${layerName}" to cloud: ${error.message}`, 'error');
                return false;
            }
        }

        // Load layers from Supabase
        async function loadLayersFromSupabase() {
            try {
                if (!currentUser) {
                    console.error('User not authenticated, cannot load layers');
                    return;
                }

                console.log('Loading saved layers from Supabase for user:', currentUser.email);

                const { data: savedLayers, error } = await supabase
                    .from('layers')
                    .select('*')
                    .eq('user_id', currentUser.id) // Only load current user's layers
                    .order('created_at', { ascending: false });

                if (error) {
                    console.error('Error loading layers from Supabase:', error);
                    showNotification(`Error loading cloud layers: ${error.message}`, 'error');
                    return;
                }

                if (savedLayers && savedLayers.length > 0) {
                    console.log(`Found ${savedLayers.length} saved layers in Supabase`);
                    
                    let loadedCount = 0;
                    for (const savedLayer of savedLayers) {
                        // Handle Aera layer symbology specially
                        if (savedLayer.name === 'Aera' || savedLayer.name === 'Aera.geojson') {
                            console.log(`Found Aera layer symbology in database, applying to existing layer`);
                            
                            // Find the existing Aera layer and apply stored symbology
                            const aeraLayerEntry = Array.from(layers.entries()).find(([layerId, layerInfo]) => 
                                layerInfo.name === 'Aera'
                            );
                            
                            if (aeraLayerEntry && savedLayer.style) {
                                const [aeraLayerId] = aeraLayerEntry;
                                applyStoredSymbology(aeraLayerId, savedLayer.style);
                                console.log('Applied stored symbology to Aera layer');
                            }
                            continue;
                        }

                        // Skip if layer with the same Supabase ID already exists (exact duplicate from database)
                        const existingLayerBySuperbaseId = Array.from(layers.entries()).find(([layerId, layerInfo]) => 
                            layerInfo.supabaseLayerId && layerInfo.supabaseLayerId === savedLayer.id
                        );
                        if (existingLayerBySuperbaseId) {
                            console.log(`Skipping duplicate layer from database (by Supabase ID): ${savedLayer.name}`);
                            // But still apply symbology if it exists
                            if (savedLayer.style) {
                                const [existingLayerId] = existingLayerBySuperbaseId;
                                applyStoredSymbology(existingLayerId, savedLayer.style);
                            }
                            continue;
                        }

                        // Skip if layer with the same name already exists and is from database
                        const existingLayerByName = Array.from(layers.entries()).find(([layerId, layerInfo]) => 
                            layerInfo.name === savedLayer.name && layerInfo.fromDatabase
                        );
                        if (existingLayerByName) {
                            console.log(`Skipping duplicate layer from database (by name): ${savedLayer.name}`);
                            // But still apply symbology if it exists
                            if (savedLayer.style) {
                                const [existingLayerId] = existingLayerByName;
                                applyStoredSymbology(existingLayerId, savedLayer.style);
                            }
                            continue;
                        }

                        try {
                            // Add the saved layer to map with proper metadata
                            const newLayerId = addDataToMap(savedLayer.geojson_data, savedLayer.name, true, savedLayer.id, false);
                            
                            // Apply stored symbology if it exists
                            if (savedLayer.style && newLayerId) {
                                // Wait a bit for the layer to be fully added
                                setTimeout(() => {
                                    applyStoredSymbology(newLayerId, savedLayer.style);
                                }, 100);
                            }
                            
                            loadedCount++;
                        } catch (layerError) {
                            console.error(`Error loading layer "${savedLayer.name}":`, layerError);
                        }
                    }
                    
                    if (loadedCount > 0) {
                        showNotification(`Loaded ${loadedCount} layers from AKL cloud`, 'success');
                    } else {
                        console.log('No new layers to load from Supabase (all already present)');
                    }
                    
                    // Update legend after all symbology has been applied (with a small delay)
                    setTimeout(() => {
                        updateLegend();
                    }, 200);
                } else {
                    console.log('No saved layers found in Supabase for current user');
                }
            } catch (error) {
                console.error('Network error loading from Supabase:', error);
                showNotification(`Network error loading cloud layers: ${error.message}`, 'error');
            }
        }

        // Update layer in Supabase (for style changes, etc.)
        async function updateLayerInSupabase(layerId) {
            try {
                if (!currentUser) {
                    console.error('User not authenticated, cannot update layer');
                    return;
                }

                const layerInfo = layers.get(layerId);
                if (!layerInfo) return;

                let query = supabase.from('layers').update({
                    style: layerInfo.style,
                    geojson_data: layerInfo.data,
                    updated_at: new Date().toISOString()
                }).eq('user_id', currentUser.id); // Ensure user owns the layer

                // Use Supabase layer ID if available, otherwise fall back to local layer ID
                if (layerInfo.supabaseLayerId) {
                    query = query.eq('id', layerInfo.supabaseLayerId);
                } else {
                    query = query.eq('layer_id', layerId);
                }

                const { error } = await query;

                if (error) {
                    console.error('Error updating layer in Supabase:', error);
                } else {
                    console.log('Layer updated in Supabase successfully');
                }
            } catch (error) {
                console.error('Network error updating Supabase:', error);
            }
        }

        // Delete layer from Supabase
        async function deleteLayerFromSupabase(layerId, layerName = 'Unknown') {
            try {
                if (!currentUser) {
                    console.error('User not authenticated, cannot delete layer');
                    return { success: false, error: 'User not authenticated' };
                }

                const layerInfo = layers.get(layerId);
                if (!layerInfo) {
                    console.error(`Layer info not found for layerId: ${layerId}`);
                    return { success: false, error: 'Layer not found in local storage' };
                }

                // Don't delete permanent layers from database
                if (layerInfo.isPermanent) {
                    console.log(`Skipping database deletion for permanent layer: ${layerName}`);
                    return { success: true }; // Return success since permanent layers shouldn't be in DB anyway
                }

                console.log(`Attempting to delete layer from Supabase:`, {
                    localLayerId: layerId,
                    supabaseLayerId: layerInfo.supabaseLayerId,
                    layerName: layerName,
                    userId: currentUser.id,
                    fromDatabase: layerInfo.fromDatabase,
                    isPermanent: layerInfo.isPermanent,
                    hasSupabaseId: !!(layerInfo.supabaseLayerId && layerInfo.supabaseLayerId !== null && layerInfo.supabaseLayerId !== 'null')
                });

                // If the layer doesn't have a supabaseLayerId and wasn't loaded from database, 
                // it's likely a local-only layer that was never saved
                if (!layerInfo.supabaseLayerId && !layerInfo.fromDatabase) {
                    console.log(`Layer "${layerName}" is local-only (no Supabase ID), skipping database deletion`);
                    return { success: true };
                }

                let query = supabase.from('layers').delete().eq('user_id', currentUser.id); // Ensure user can only delete own layers
                let queryDescription = '';
                
                // Use Supabase layer ID if available (more reliable), otherwise try layer name
                if (layerInfo.supabaseLayerId && layerInfo.supabaseLayerId !== null && layerInfo.supabaseLayerId !== 'null') {
                    query = query.eq('id', layerInfo.supabaseLayerId);
                    queryDescription = `Supabase ID: ${layerInfo.supabaseLayerId}, User ID: ${currentUser.id}`;
                } else if (layerInfo.fromDatabase) {
                    // If it came from database but no supabaseLayerId, try to find by name and layer_id
                    query = query.eq('name', layerName).eq('layer_id', layerId);
                    queryDescription = `Name: ${layerName}, Layer ID: ${layerId}, User ID: ${currentUser.id}`;
                } else {
                    // Last resort: try deleting by layer_id only (for newly uploaded layers)
                    query = query.eq('layer_id', layerId);
                    queryDescription = `Layer ID: ${layerId}, User ID: ${currentUser.id}`;
                }

                console.log(`Executing delete query with ${queryDescription}`);
                const { data, error } = await query;

                console.log(`Delete query result:`, {
                    queryDescription: queryDescription,
                    resultData: data,
                    error: error,
                    hasData: !!data,
                    dataLength: data ? data.length : 0
                });

                if (error) {
                    console.error(`Error deleting layer "${layerName}" from Supabase:`, error);
                    return { success: false, error: `Database error: ${error.message}` };
                } else {
                    console.log(`Layer "${layerName}" deleted from Supabase successfully using ${queryDescription}`);
                    return { success: true };
                }
            } catch (error) {
                console.error(`Network error deleting layer "${layerName}" from Supabase:`, error);
                return { success: false, error: `Network error: ${error.message}` };
            }
        }

        // Clear cached data from old/deprecated layers to prevent symbology conflicts
        function clearOldLayerCaches() {
            console.log('🧹 Clearing old layer caches to prevent symbology conflicts...');
            
            try {
                // Clear localStorage entries that might contain old layer references
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.startsWith('layer_') || key.includes('symbology') || key.includes('style'))) {
                        keysToRemove.push(key);
                    }
                }
                keysToRemove.forEach(key => {
                    localStorage.removeItem(key);
                    console.log(`🗑️ Removed cached item: ${key}`);
                });

                // Clear sessionStorage entries that might contain old layer references  
                const sessionKeysToRemove = [];
                for (let i = 0; i < sessionStorage.length; i++) {
                    const key = sessionStorage.key(i);
                    if (key && (key.startsWith('layer_') || key.includes('symbology') || key.includes('style'))) {
                        sessionKeysToRemove.push(key);
                    }
                }
                sessionKeysToRemove.forEach(key => {
                    sessionStorage.removeItem(key);
                    console.log(`🗑️ Removed cached session item: ${key}`);
                });

                // Clear any global variables that might hold old layer references
                if (typeof window.cachedLayerStyles !== 'undefined') {
                    delete window.cachedLayerStyles;
                    console.log('🗑️ Cleared global cachedLayerStyles');
                }

                console.log('✅ Old layer cache cleanup completed');
            } catch (error) {
                console.warn('Warning: Could not fully clear old layer caches:', error);
            }
        }

        // Load initial Aera.geojson data
        function loadInitialData() {
            // Clear any cached references to old layers (specifically layer_1)
            // This prevents loading of stale symbology from memory
            clearOldLayerCaches();
            localStorage.removeItem('layer_1_symbology');
            sessionStorage.removeItem('layer_1_symbology');
            
            // For Aera layer specifically: Load symbology FIRST, then apply it during layer creation
            // This eliminates the brief flash of default teal symbology
            if (supabase && currentUser) {
                console.log('🎨 Preloading Aera symbology to prevent flash...');
                loadAeraWithCorrectSymbology();
            } else {
                // Fallback: Load without symbology preloading
                loadAeraWithDefaultSymbology();
            }
            
            // Load saved layers from Supabase after Aera is properly loaded
            if (supabase) {
                setTimeout(() => {
                    loadLayersFromSupabase();
                    
                    // Populate filter layers after Supabase layers load
                    setTimeout(() => {
                        console.log('Supabase layers loaded, refreshing filter layers');
                        populateFilterLayers();
                    }, 500);
                }, 700); // Increased delay to ensure Aera loads with correct symbology first
            }
        }

        // Load Aera.geojson with preloaded correct symbology (prevents flash)
        async function loadAeraWithCorrectSymbology() {
            try {
                console.log('🔍 Checking for stored Aera symbology before layer creation...');
                
                // First, get the stored symbology for Aera layer
                const { data: aeraSymbology, error: symbologyError } = await supabase
                    .from('layers')
                    .select('style')
                    .eq('user_id', currentUser.id)
                    .eq('name', 'Aera')
                    .single();

                if (symbologyError && symbologyError.code !== 'PGRST116') {
                    console.error('Error fetching Aera symbology:', symbologyError);
                    loadAeraWithDefaultSymbology();
                    return;
                }

                // Now load the GeoJSON file
                const response = await fetch('Aera.geojson');
                const geoData = await response.json();

                if (aeraSymbology && aeraSymbology.style) {
                    console.log('✅ Found stored Aera symbology, applying directly during layer creation');
                    // Create layer with stored symbology immediately - NO FLASH
                    addDataToMapWithPreloadedStyle(geoData, 'Aera.geojson', aeraSymbology.style, true);
                } else {
                    console.log('ℹ️ No stored Aera symbology found, using default');
                    // Use default symbology
                    addDataToMap(geoData, 'Aera.geojson', false, null, true);
                }

                // Populate filter layers after initial data is loaded
                setTimeout(() => {
                    console.log('Initial Aera data loaded, populating filter layers');
                    populateFilterLayers();
                }, 100);

            } catch (error) {
                console.error('Error in loadAeraWithCorrectSymbology:', error);
                // Fallback to default loading
                loadAeraWithDefaultSymbology();
            }
        }

        // Fallback method for loading Aera with default symbology
        function loadAeraWithDefaultSymbology() {
            console.log('📥 Loading Aera.geojson with default symbology...');
            
            fetch('Aera.geojson')
                .then(response => response.json())
                .then(data => {
                    // Mark as permanent layer and from local source
                    addDataToMap(data, 'Aera.geojson', false, null, true);
                    
                    // Populate filter layers after initial data is loaded
                    setTimeout(() => {
                        console.log('Initial data loaded, populating filter layers');
                        populateFilterLayers();
                    }, 100);
                })
                .catch(error => {
                    console.error('Error loading Aera.geojson:', error);
                    // Continue without the initial data
                });
        }

        // REMOVED: checkAndApplyAeraSymbology function 
        // This function has been replaced with proactive symbology loading in loadAeraWithCorrectSymbology()
        // to prevent the flash of default symbology. The new approach loads the correct symbology
        // BEFORE creating the layer, eliminating any visual flicker.
        
        // Note: This function is no longer needed because we now:
        // 1. Preload Aera symbology from Supabase before layer creation
        // 2. Apply the correct style immediately during L.geoJSON() creation
        // 3. Clear any cached references to old layers (layer_1) that no longer exist

        // Update layers list in sidebar
        function updateLayersList() {
            const layersList = document.getElementById('layersList');
            layersList.innerHTML = '';

            // Use layerOrder to maintain consistent ordering
            layerOrder.forEach(layerId => {
                if (!layers.has(layerId)) return; // Skip deleted layers

                const layerInfo = layers.get(layerId);
                const layerDiv = document.createElement('div');
                layerDiv.className = 'layer-item rounded-lg p-3 glass-panel';
                layerDiv.draggable = true;
                layerDiv.setAttribute('data-layer-id', layerId);
                layerDiv.setAttribute('data-layer-name', layerInfo.name);
                
                layerDiv.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <div class="flex items-center space-x-2">
                            <i class="fas fa-grip-vertical layer-drag-handle text-sm"></i>
                            <span class="font-medium ${layerInfo.isPermanent ? 'text-amber-300' : 'text-white'} truncate">
                                ${layerInfo.name}
                                ${layerInfo.isPermanent ? '<i class="fas fa-lock text-xs ml-1" title="Permanent layer - cannot be deleted"></i>' : ''}
                                ${layerInfo.fromDatabase ? '<i class="fas fa-cloud text-xs ml-1 text-blue-400" title="Saved to cloud"></i>' : ''}
                            </span>
                        </div>
                        <div class="flex items-center space-x-3">
                            <button class="symbology-btn text-teal-400 hover:text-teal-300 text-lg transition-colors" data-layer="${layerId}" title="Edit Symbology">
                                <i class="fas fa-palette"></i>
                            </button>
                            <button class="visibility-btn text-lg transition-colors cursor-pointer" data-layer="${layerId}" title="Toggle Visibility">
                                <i class="fas ${layerInfo.visible ? 'fa-eye text-teal-400 hover:text-teal-300' : 'fa-eye-slash text-gray-500 hover:text-gray-400'}"></i>
                            </button>
                        </div>
                    </div>
                    <div class="text-xs text-gray-400 italic">
                        ${Object.keys(layerInfo.data.features || {}).length || layerInfo.data.features?.length || 0} features
                        ${layerInfo.isPermanent ? ' • Built-in layer' : ''}
                        ${layerInfo.fromDatabase && !layerInfo.isPermanent ? ' • Cloud synced' : ''}
                    </div>
                `;

                layersList.appendChild(layerDiv);

                // Setup drag and drop for this layer
                setupLayerDragDrop(layerDiv, layerId);

                // Add existing event listeners
                const visibilityBtn = layerDiv.querySelector('.visibility-btn');
                visibilityBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const currentVisibility = layers.get(layerId).visible;
                    toggleLayerVisibility(layerId, !currentVisibility);
                });

                const symbologyBtn = layerDiv.querySelector('.symbology-btn');
                symbologyBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Symbology button clicked for layer:', layerId);
                    try {
                        openSymbologyEditor(layerId);
                    } catch (error) {
                        console.error('Error opening symbology editor:', error);
                        showError('Error opening symbology editor. Check console for details.', 'Symbology Error');
                    }
                });

                // Add right-click context menu listener to the layer item
                layerDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    showLayerContextMenu(e, layerId, layerInfo.name);
                });
            });
            
            // Update map layer order after UI update
            updateMapLayerOrder();
            
            // Update selection layer dropdown
            updateSelectionLayerDropdown();
            
            // Update print map if open
            updatePrintMapLayers();
        }

        // Setup drag and drop for layer items
        function setupLayerDragDrop(layerDiv, layerId) {
            console.log(`Setting up drag-and-drop for layer: ${layerId}`);

            // Drag start
            layerDiv.addEventListener('dragstart', (e) => {
                console.log(`Drag started for layer: ${layerId}`);
                layerDiv.classList.add('dragging');
                layerDiv.style.opacity = '0.5';
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', layerId);
                
                // Store reference for other event listeners
                layerDiv.setAttribute('data-dragging', 'true');
            });

            // Drag end
            layerDiv.addEventListener('dragend', (e) => {
                console.log(`Drag ended for layer: ${layerId}`);
                layerDiv.classList.remove('dragging');
                layerDiv.style.opacity = '1';
                layerDiv.removeAttribute('data-dragging');
                
                // Remove drag-over class from all layer items
                document.querySelectorAll('.layer-item').forEach(item => {
                    item.classList.remove('drag-over');
                });
            });

            // Drag over - CRITICAL: Must prevent default to allow drop
            layerDiv.addEventListener('dragover', (e) => {
                e.preventDefault(); // This is essential!
                e.stopPropagation();
                
                const draggingElement = document.querySelector('[data-dragging="true"]');
                if (draggingElement && draggingElement !== layerDiv) {
                    e.dataTransfer.dropEffect = 'move';
                    layerDiv.classList.add('drag-over');
                }
            });

            // Drag enter
            layerDiv.addEventListener('dragenter', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                const draggingElement = document.querySelector('[data-dragging="true"]');
                if (draggingElement && draggingElement !== layerDiv) {
                    layerDiv.classList.add('drag-over');
                }
            });

            // Drag leave
            layerDiv.addEventListener('dragleave', (e) => {
                // Only remove drag-over if we're actually leaving this element
                if (!layerDiv.contains(e.relatedTarget)) {
                    layerDiv.classList.remove('drag-over');
                }
            });

            // Drop
            layerDiv.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                console.log(`Drop event on layer: ${layerId}`);
                layerDiv.classList.remove('drag-over');
                
                const draggedLayerId = e.dataTransfer.getData('text/plain');
                const targetLayerId = layerId;
                
                console.log(`Attempting to reorder: ${draggedLayerId} -> ${targetLayerId}`);
                
                if (draggedLayerId && draggedLayerId !== targetLayerId) {
                    reorderLayer(draggedLayerId, targetLayerId);
                }
            });
        }

        // Reorder layers in the layerOrder array
        function reorderLayer(draggedLayerId, targetLayerId) {
            console.log(`Reordering layers:`, {
                draggedLayerId: draggedLayerId,
                targetLayerId: targetLayerId,
                currentOrder: [...layerOrder]
            });

            const draggedIndex = layerOrder.indexOf(draggedLayerId);
            const targetIndex = layerOrder.indexOf(targetLayerId);
            
            if (draggedIndex !== -1 && targetIndex !== -1) {
                // Remove the dragged layer from its current position
                layerOrder.splice(draggedIndex, 1);
                
                // Insert it at the target position
                const newTargetIndex = layerOrder.indexOf(targetLayerId);
                layerOrder.splice(newTargetIndex, 0, draggedLayerId);
                
                console.log(`Layer order updated:`, {
                    oldIndex: draggedIndex,
                    newIndex: layerOrder.indexOf(draggedLayerId),
                    newOrder: [...layerOrder]
                });
                
                // Update the UI and map rendering order
                updateLayersList();
                updateMapLayerOrder();
                
                // Show feedback to user
                const draggedLayerInfo = layers.get(draggedLayerId);
                const draggedLayerName = draggedLayerInfo ? draggedLayerInfo.name : 'Unknown';
                showNotification(`Layer "${draggedLayerName}" reordered successfully`, 'success', 2000);
            }
        }

        // Update map layer rendering order
        function updateMapLayerOrder() {
            console.log('Updating map layer rendering order:', layerOrder);
            
            // CORRECTED LOGIC:
            // - Top layer in panel = highest z-index (rendered on top) 
            // - Bottom layer in panel = lowest z-index (rendered at back)
            // - Process layerOrder directly: first item = top of panel = should be on top of map
            
            // First, bring all layers to back to reset their z-index order
            layerOrder.forEach((layerId) => {
                const layerInfo = layers.get(layerId);
                if (layerInfo && layerInfo.visible && layerInfo.layer) {
                    try {
                        layerInfo.layer.bringToBack();
                    } catch (error) {
                        console.warn(`Could not bring layer ${layerId} to back:`, error);
                    }
                }
            });
            
            // Then, bring layers to front in REVERSE order
            // This ensures the FIRST layer in layerOrder (top of panel) ends up on top of map
            const reversedOrder = [...layerOrder].reverse();
            reversedOrder.forEach((layerId) => {
                const layerInfo = layers.get(layerId);
                if (layerInfo && layerInfo.visible && layerInfo.layer) {
                    try {
                        layerInfo.layer.bringToFront();
                        console.log(`Brought layer "${layerInfo.name}" (${layerId}) to front - Panel position: ${layerOrder.indexOf(layerId) + 1}`);
                    } catch (error) {
                        console.warn(`Could not bring layer ${layerId} to front:`, error);
                    }
                }
            });
            
            console.log('Map layer rendering order updated successfully');
            console.log('Final z-index order (bottom to top):', reversedOrder.map(id => {
                const info = layers.get(id);
                return info ? info.name : id;
            }));
        }

        // Update selection layer dropdown with visible layers
        function updateSelectionLayerDropdown() {
            const activeLayerSelect = document.getElementById('activeLayerSelect');
            const currentValue = activeLayerSelect.value;
            
            // Clear existing options
            activeLayerSelect.innerHTML = '<option value="">Select a layer first</option>';
            
            // Add visible layers to dropdown
            layers.forEach((layerInfo, layerId) => {
                if (layerInfo.visible) {
                    const option = document.createElement('option');
                    option.value = layerId;
                    option.textContent = layerInfo.name;
                    
                    // Keep current selection if still valid
                    if (layerId === currentValue) {
                        option.selected = true;
                    }
                    
                    activeLayerSelect.appendChild(option);
                }
            });
            
            // If current selection is no longer valid, reset
            if (currentValue && !layers.has(currentValue) || (currentValue && !layers.get(currentValue).visible)) {
                activeSelectionLayerId = null;
                activeLayerSelect.value = '';
                
                // Disable activate button
                const activateBtn = document.getElementById('activateSelectTool');
                activateBtn.disabled = true;
                activateBtn.classList.add('opacity-50', 'cursor-not-allowed');
                
                // If selection is active, deactivate it
                if (isSelectionActive) {
                    deactivateSelectionTool();
                }
            }
        }

        // Toggle layer visibility
        function toggleLayerVisibility(layerId, visible) {
            const layerInfo = layers.get(layerId);
            if (layerInfo) {
                if (visible) {
                    map.addLayer(layerInfo.layer);
                } else {
                    map.removeLayer(layerInfo.layer);
                }
                layerInfo.visible = visible;
                
                // Update map layer order after visibility change
                updateMapLayerOrder();
                
                updateLegend();
                updateSelectionLayerDropdown(); // Update selection dropdown when layer visibility changes
                populateFilterLayers(); // Update filter dropdown when layer visibility changes
                updateLayersList(); // Update layer list to refresh icons
            }
        }

        // Layer Context Menu Functions
        let currentContextLayerId = null;
        let currentContextLayerName = null;

        // Show layer context menu
        function showLayerContextMenu(event, layerId, layerName) {
            console.log(`Showing context menu for layer:`, {
                layerId: layerId,
                layerName: layerName,
                layerExists: layers.has(layerId)
            });

            // Validate parameters
            if (!layerId) {
                console.error('Cannot show context menu: layerId is null or undefined');
                return;
            }
            if (!layerName) {
                console.error('Cannot show context menu: layerName is null or undefined');
                return;
            }

            // Verify layer exists in the layers map
            if (!layers.has(layerId)) {
                console.error(`Cannot show context menu: Layer ${layerId} not found in layers map`);
                console.log('Available layers:', Array.from(layers.keys()));
                return;
            }

            const contextMenu = document.getElementById('layerContextMenu');
            const deleteItem = document.getElementById('contextDelete');
            const renameItem = document.getElementById('contextRename');
            
            // Reset and set the context variables for the new layer
            currentContextLayerId = layerId;
            currentContextLayerName = layerName;
            
            console.log(`Context menu variables set:`, {
                currentContextLayerId: currentContextLayerId,
                currentContextLayerName: currentContextLayerName
            });
            
            const layerInfo = layers.get(layerId);
            // Check if this is a permanent layer and disable delete/rename if so
            const isPermanentLayer = layerInfo && layerInfo.isPermanent;
            if (isPermanentLayer) {
                deleteItem.classList.add('disabled');
                renameItem.classList.add('disabled');
            } else {
                deleteItem.classList.remove('disabled');
                renameItem.classList.remove('disabled');
            }
            
            // Position the context menu at cursor location
            contextMenu.style.display = 'block';
            contextMenu.style.left = event.clientX + 'px';
            contextMenu.style.top = event.clientY + 'px';
            
            // Ensure menu stays within viewport
            const rect = contextMenu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            if (rect.right > viewportWidth) {
                contextMenu.style.left = (event.clientX - rect.width) + 'px';
            }
            if (rect.bottom > viewportHeight) {
                contextMenu.style.top = (event.clientY - rect.height) + 'px';
            }
            
            // Prevent event propagation
            event.stopPropagation();
        }

        // Hide layer context menu
        function hideLayerContextMenu() {
            const contextMenu = document.getElementById('layerContextMenu');
            contextMenu.style.display = 'none';
            
            // Don't reset the context variables immediately - they might be needed for menu actions
            // They will be reset when a new context menu is shown
        }

        // Reset context menu variables (called after actions are completed)
        function resetContextMenuVariables() {
            currentContextLayerId = null;
            currentContextLayerName = null;
        }

        // Setup context menu event listeners
        function setupLayerContextMenuListeners() {
            const contextMenu = document.getElementById('layerContextMenu');
            
            // Prevent menu from closing when clicking inside it
            contextMenu.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            // Zoom to Layer
            document.getElementById('contextZoomToLayer').addEventListener('click', function() {
                if (currentContextLayerId) {
                    zoomToLayer(currentContextLayerId);
                    hideLayerContextMenu();
                }
            });
            
            // Rename Layer
            document.getElementById('contextRename').addEventListener('click', function() {
                if (currentContextLayerId && currentContextLayerName) {
                    hideLayerContextMenu();
                    renameLayer(currentContextLayerId, currentContextLayerName);
                }
            });
            
            // Properties (open symbology editor)
            document.getElementById('contextProperties').addEventListener('click', function() {
                if (currentContextLayerId) {
                    try {
                        openSymbologyEditor(currentContextLayerId);
                        hideLayerContextMenu();
                    } catch (error) {
                        console.error('Error opening symbology editor:', error);
                        showError('Error opening symbology editor. Check console for details.', 'Symbology Error');
                    }
                }
            });
            
            // Delete Layer
            document.getElementById('contextDelete').addEventListener('click', async function() {
                console.log(`Delete layer clicked:`, {
                    currentContextLayerId: currentContextLayerId,
                    currentContextLayerName: currentContextLayerName,
                    disabled: this.classList.contains('disabled')
                });

                // Get layer information from the stored context variables
                const layerIdToDelete = currentContextLayerId;
                const layerNameToDelete = currentContextLayerName;

                // Validate we have the required information
                if (!layerIdToDelete) {
                    console.error('Cannot delete layer: No layer ID available from context menu');
                    showNotification('Cannot delete layer: No layer selected.', 'error');
                    hideLayerContextMenu();
                    return;
                }

                if (!layerNameToDelete) {
                    console.error('Cannot delete layer: No layer name available from context menu');
                    showNotification('Cannot delete layer: No layer name available.', 'error');
                    hideLayerContextMenu();
                    return;
                }

                if (!this.classList.contains('disabled')) {
                    // Validate layer exists before attempting deletion
                    if (!layers.has(layerIdToDelete)) {
                        console.error(`Cannot delete layer: Layer ${layerIdToDelete} not found in layers map`);
                        showNotification(`Layer not found in system. Cannot delete.`, 'error');
                        resetContextMenuVariables();
                        return;
                    }

                    // Hide menu first, then delete
                    hideLayerContextMenu();
                    
                    try {
                        await deleteLayer(layerIdToDelete, layerNameToDelete);
                    } finally {
                        // Always reset variables after deletion attempt
                        resetContextMenuVariables();
                    }
                } else if (this.classList.contains('disabled')) {
                    const layerInfo = layers.get(layerIdToDelete);
                    if (layerInfo && layerInfo.isPermanent) {
                        showNotification(`"${layerNameToDelete}" is a permanent layer and cannot be deleted.`, 'info');
                    } else {
                        showNotification('This layer cannot be deleted.', 'info');
                    }
                    resetContextMenuVariables();
                } else {
                    console.error('Delete layer failed: No valid layer ID or name available');
                    showNotification('Cannot delete layer: Invalid layer reference.', 'error');
                    resetContextMenuVariables();
                }
            });
        }

        // Zoom to layer function
        function zoomToLayer(layerId) {
            const layerInfo = layers.get(layerId);
            if (layerInfo && layerInfo.visible && layerInfo.layer) {
                try {
                    const bounds = layerInfo.layer.getBounds();
                    if (bounds && bounds.isValid()) {
                        map.fitBounds(bounds);
                    } else {
                        showWarning('Unable to determine layer extent.', 'Zoom Error');
                    }
                } catch (error) {
                    console.error('Error zooming to layer:', error);
                    showError('Error zooming to layer.', 'Zoom Error');
                }
            } else {
                showError('Layer is not visible or not found.', 'Selection Error');
            }
        }

        // Delete layer function
        async function deleteLayer(layerId, layerName) {
            console.log(`Starting deleteLayer function:`, {
                layerId: layerId,
                layerName: layerName,
                layersMapSize: layers.size,
                layerExists: layers.has(layerId)
            });

            // Comprehensive validation
            if (!layerId) {
                const errorMsg = `Cannot delete layer: layerId is null or undefined`;
                console.error(errorMsg);
                showNotification(errorMsg, 'error');
                return;
            }

            if (!layerName) {
                const errorMsg = `Cannot delete layer: layerName is null or undefined for layer ID ${layerId}`;
                console.error(errorMsg);
                showNotification(errorMsg, 'error');
                return;
            }

            // Verify layer exists in layers map
            if (!layers.has(layerId)) {
                const errorMsg = `Layer "${layerName}" (ID: ${layerId}) not found in layers collection`;
                console.error(errorMsg);
                console.log('Available layers:', Array.from(layers.keys()));
                showNotification(errorMsg, 'error');
                return;
            }

            // Get layer info and validate it exists
            const layerInfo = layers.get(layerId);
            if (!layerInfo) {
                const errorMsg = `Layer info for "${layerName}" (ID: ${layerId}) is null or undefined`;
                console.error(errorMsg);
                showNotification(errorMsg, 'error');
                return;
            }

            // Prevent deletion of permanent layers
            if (layerInfo.isPermanent) {
                const msg = `"${layerName}" is a permanent layer and cannot be deleted.`;
                console.log(msg);
                showNotification(msg, 'info');
                return;
            }

            // Confirm deletion
            const confirmed = await showConfirm(`Are you sure you want to delete the layer "${layerName}"?`, 'Delete Layer');
            if (confirmed) {
                console.log(`Starting deletion process for layer:`, {
                    layerId: layerId,
                    layerName: layerName,
                    supabaseLayerId: layerInfo.supabaseLayerId,
                    isPermanent: layerInfo.isPermanent,
                    fromDatabase: layerInfo.fromDatabase
                });
                
                try {
                    // Delete from Supabase first (if it's a database layer or has been saved)
                    if (supabase && !layerInfo.isPermanent) {
                        // Check if this layer should be deleted from database
                        const shouldDeleteFromDB = layerInfo.fromDatabase || 
                                                   (layerInfo.supabaseLayerId && 
                                                    layerInfo.supabaseLayerId !== null && 
                                                    layerInfo.supabaseLayerId !== 'null');
                        
                        if (shouldDeleteFromDB) {
                            console.log(`Deleting layer "${layerName}" from Supabase...`);
                            const deleteResult = await deleteLayerFromSupabase(layerId, layerName);
                            
                            if (!deleteResult.success) {
                                console.error(`Database deletion failed:`, deleteResult.error);
                                const fallbackConfirmed = await showConfirm(`Failed to delete layer from database: ${deleteResult.error}\n\nDo you want to delete it locally anyway?`, 'Database Deletion Failed');
                                if (fallbackConfirmed) {
                                    console.log('User chose to delete locally despite database error');
                                } else {
                                    return; // User cancelled, don't delete locally
                                }
                            } else {
                                console.log(`Layer "${layerName}" successfully deleted from Supabase`);
                            }
                        } else {
                            console.log(`Layer "${layerName}" is local-only, no database deletion needed`);
                        }
                    } else if (layerInfo.isPermanent) {
                        console.log(`Layer "${layerName}" is permanent, skipping database deletion`);
                    }

                    // Remove layer from map
                    if (layerInfo.layer) {
                        map.removeLayer(layerInfo.layer);
                        console.log(`Layer "${layerName}" removed from map`);
                    } else {
                        console.warn(`Layer "${layerName}" has no map layer to remove`);
                    }
                    
                    // Remove from layers collection
                    layers.delete(layerId);
                    console.log(`Layer "${layerName}" removed from layers collection`);
                    
                    // Remove from layer order
                    const orderIndex = layerOrder.indexOf(layerId);
                    if (orderIndex !== -1) {
                        layerOrder.splice(orderIndex, 1);
                        console.log(`Layer "${layerName}" removed from layer order at index ${orderIndex}`);
                    } else {
                        console.warn(`Layer "${layerName}" not found in layer order array`);
                    }
                    
                    // Remove any active filters for this layer
                    if (activeFilters.has(layerId)) {
                        activeFilters.delete(layerId);
                        console.log(`Filters removed for layer "${layerName}"`);
                    }
                    
                    // If this layer was selected for selection tool, deactivate it
                    if (activeSelectionLayerId === layerId) {
                        activeSelectionLayerId = null;
                        if (isSelectionActive) {
                            deactivateSelectionTool();
                        }
                        console.log(`Selection tool deactivated for deleted layer "${layerName}"`);
                    }
                    
                    // Update UI
                    updateLayersList();
                    updateLegend();
                    updateSelectionLayerDropdown();
                    populateFilterLayers();
                    
                    console.log(`Layer "${layerName}" (${layerId}) deleted successfully`);
                    
                    // Show success notification
                    showNotification(`Layer "${layerName}" deleted successfully`, 'success');
                    
                } catch (error) {
                    console.error('Error during layer deletion:', error);
                    showNotification(`Error deleting layer "${layerName}": ${error.message}`, 'error');
                }
            }
        }

        // Rename layer function
        async function renameLayer(layerId, currentName) {
            console.log(`Starting renameLayer function:`, {
                layerId: layerId,
                currentName: currentName,
                layerExists: layers.has(layerId)
            });

            // Validate parameters
            if (!layerId) {
                console.error('Cannot rename layer: layerId is null or undefined');
                showNotification('Cannot rename layer: No layer ID provided.', 'error');
                return;
            }

            if (!currentName) {
                console.error('Cannot rename layer: currentName is null or undefined');
                showNotification('Cannot rename layer: No current name provided.', 'error');
                return;
            }

            // Verify layer exists in layers map
            if (!layers.has(layerId)) {
                const errorMsg = `Layer "${currentName}" (ID: ${layerId}) not found in layers collection`;
                console.error(errorMsg);
                showNotification(errorMsg, 'error');
                return;
            }

            // Get layer info and validate it exists
            const layerInfo = layers.get(layerId);
            if (!layerInfo) {
                const errorMsg = `Layer info for "${currentName}" (ID: ${layerId}) is null or undefined`;
                console.error(errorMsg);
                showNotification(errorMsg, 'error');
                return;
            }

            // Prevent renaming of permanent layers
            if (layerInfo.isPermanent) {
                const msg = `"${currentName}" is a permanent layer and cannot be renamed.`;
                console.log(msg);
                showNotification(msg, 'info');
                return;
            }

            // Prompt user for new name
            const newName = await showPrompt(`Enter new name for layer "${currentName}":`, currentName, 'Rename Layer');
            
            if (newName === null) {
                // User cancelled
                return;
            }
            
            if (newName.trim() === '') {
                showNotification('Layer name cannot be empty.', 'error');
                return;
            }
            
            if (newName.trim() === currentName) {
                // No change needed
                return;
            }

            const trimmedNewName = newName.trim();

            // Check if another layer already has this name
            const existingLayerWithName = Array.from(layers.values()).find(layer => 
                layer.name === trimmedNewName && layer !== layerInfo
            );
            
            if (existingLayerWithName) {
                showNotification(`A layer named "${trimmedNewName}" already exists.`, 'error');
                return;
            }

            try {
                console.log(`Renaming layer from "${currentName}" to "${trimmedNewName}"`);

                // Update the layer name locally
                layerInfo.name = trimmedNewName;
                
                // Update Supabase if layer is from database or has been saved
                if (supabase && (layerInfo.fromDatabase || layerInfo.supabaseLayerId)) {
                    console.log(`Updating layer name in Supabase...`);
                    const updateResult = await updateLayerNameInSupabase(layerId, trimmedNewName);
                    if (!updateResult.success) {
                        console.error('Failed to update layer name in Supabase:', updateResult.error);
                        showNotification(`Layer renamed locally, but failed to update in cloud: ${updateResult.error}`, 'error');
                    }
                }

                // Update the UI
                updateLayersList();
                updateSelectionLayerDropdown();
                updateLegend();

                // Show success notification
                showNotification(`Layer renamed to "${trimmedNewName}" successfully`, 'success', 2000);
                
                console.log(`Layer renamed successfully:`, {
                    layerId: layerId,
                    oldName: currentName,
                    newName: trimmedNewName
                });

            } catch (error) {
                console.error('Error renaming layer:', error);
                showNotification(`Error renaming layer: ${error.message}`, 'error');
                
                // Revert local name change if error occurred
                layerInfo.name = currentName;
            }
        }

        // Update layer name in Supabase
        async function updateLayerNameInSupabase(layerId, newName) {
            try {
                if (!currentUser) {
                    console.error('User not authenticated, cannot update layer name');
                    return { success: false, error: 'User not authenticated' };
                }

                const layerInfo = layers.get(layerId);
                if (!layerInfo) {
                    return { success: false, error: 'Layer not found in local storage' };
                }

                console.log(`Attempting to update layer name in Supabase:`, {
                    localLayerId: layerId,
                    supabaseLayerId: layerInfo.supabaseLayerId,
                    newName: newName,
                    userId: currentUser.id
                });

                let query = supabase.from('layers').update({
                    name: newName,
                    updated_at: new Date().toISOString()
                }).eq('user_id', currentUser.id); // Ensure user owns the layer

                // Use Supabase layer ID if available, otherwise fall back to local layer ID
                if (layerInfo.supabaseLayerId && layerInfo.supabaseLayerId !== null && layerInfo.supabaseLayerId !== 'null') {
                    query = query.eq('id', layerInfo.supabaseLayerId);
                } else {
                    query = query.eq('layer_id', layerId);
                }

                const { data, error } = await query;

                if (error) {
                    console.error('Error updating layer name in Supabase:', error);
                    return { success: false, error: `Database error: ${error.message}` };
                } else {
                    console.log('Layer name updated in Supabase successfully');
                    return { success: true };
                }
            } catch (error) {
                console.error('Network error updating layer name in Supabase:', error);
                return { success: false, error: `Network error: ${error.message}` };
            }
        }

        // Save symbology settings to Supabase
        async function saveSymbologyToSupabase(layerId, symbologyData) {
            if (!supabase || !currentUser) {
                console.log('Supabase not available or user not logged in, skipping symbology save');
                return;
            }

            try {
                const layerInfo = layers.get(layerId);
                if (!layerInfo) {
                    console.warn('Layer info not found for symbology save:', layerId);
                    return;
                }

                console.log(`Saving symbology to Supabase for layer: ${layerId}`, symbologyData);

                // For Aera.geojson, we need to handle it specially since it's a built-in layer
                if (layerId === 'aera-layer' || layerInfo.name === 'Aera') {
                    // Check if user already has an Aera layer record
                    const { data: existingAera, error: checkError } = await supabase
                        .from('layers')
                        .select('id, style')
                        .eq('user_id', currentUser.id)
                        .eq('name', 'Aera')
                        .single();

                    if (checkError && checkError.code !== 'PGRST116') { // PGRST116 is "not found"
                        console.error('Error checking for existing Aera layer:', checkError);
                        return;
                    }

                    if (existingAera) {
                        // Update existing Aera layer style
                        const { error: updateError } = await supabase
                            .from('layers')
                            .update({
                                style: symbologyData,
                                updated_at: new Date().toISOString()
                            })
                            .eq('id', existingAera.id);

                        if (updateError) {
                            console.error('Error updating Aera layer symbology:', updateError);
                        } else {
                            console.log('Aera layer symbology updated successfully');
                        }
                    } else {
                        // Create new Aera layer record for this user
                        const { error: insertError } = await supabase
                            .from('layers')
                            .insert({
                                layer_id: 'aera-' + currentUser.id,
                                name: 'Aera',
                                geojson_data: layerInfo.data,
                                style: symbologyData,
                                user_id: currentUser.id,
                                created_at: new Date().toISOString(),
                                updated_at: new Date().toISOString()
                            });

                        if (insertError) {
                            console.error('Error creating Aera layer record:', insertError);
                        } else {
                            console.log('Aera layer record created with symbology');
                            layerInfo.fromDatabase = true;
                            layerInfo.supabaseLayerId = 'aera-' + currentUser.id;
                        }
                    }
                } else {
                    // Handle regular user-uploaded layers
                    let query = supabase.from('layers').update({
                        style: symbologyData,
                        updated_at: new Date().toISOString()
                    }).eq('user_id', currentUser.id);

                    // Use Supabase layer ID if available, otherwise fall back to local layer ID
                    if (layerInfo.supabaseLayerId && layerInfo.supabaseLayerId !== null && layerInfo.supabaseLayerId !== 'null') {
                        query = query.eq('id', layerInfo.supabaseLayerId);
                    } else {
                        query = query.eq('layer_id', layerId);
                    }

                    const { error } = await query;

                    if (error) {
                        console.error('Error saving symbology to Supabase:', error);
                    } else {
                        console.log('Symbology saved to Supabase successfully');
                    }
                }
            } catch (error) {
                console.error('Network error saving symbology to Supabase:', error);
            }
        }

        // Apply stored symbology from Supabase data
        function applyStoredSymbology(layerId, symbologyData) {
            console.log('Applying stored symbology for layer:', layerId, symbologyData);
            
            if (!symbologyData) {
                console.log('No symbology data to apply');
                return;
            }

            const layerInfo = layers.get(layerId);
            if (!layerInfo) {
                console.warn('Layer info not found for symbology application:', layerId);
                return;
            }

            try {
                if (symbologyData.symbology_type === 'single') {
                    // Apply single symbol symbology
                    const style = {
                        color: symbologyData.stroke_color || '#ffffff',
                        fillColor: symbologyData.fill_color || '#888888',
                        weight: symbologyData.stroke_weight || 2,
                        opacity: symbologyData.stroke_opacity || 1.0,
                        fillOpacity: symbologyData.fill_opacity || 0.7
                    };

                    layerInfo.layer.setStyle(style);
                    layerInfo.style = style;
                    
                    console.log('Single symbol symbology applied from stored data');
                } else if (symbologyData.symbology_type === 'categorical' && symbologyData.classification_field && symbologyData.categories) {
                    // Apply categorical symbology
                    const field = symbologyData.classification_field;
                    const strokeColor = symbologyData.stroke_color || '#ffffff';
                    const strokeWeight = symbologyData.stroke_weight || 2;
                    
                    // Create color map from stored categories
                    const colorMap = {};
                    symbologyData.categories.forEach(category => {
                        colorMap[category.value] = category.color;
                    });

                    layerInfo.layer.setStyle(function(feature) {
                        const value = feature.properties[field];
                        const fillColor = colorMap[value] || '#999999';
                        return {
                            color: strokeColor,
                            fillColor: fillColor,
                            weight: strokeWeight,
                            opacity: symbologyData.stroke_opacity || 1.0,
                            fillOpacity: symbologyData.fill_opacity || 0.7
                        };
                    });

                    // Store the classification info
                    layerInfo.classification = {
                        field: field,
                        colorMap: colorMap,
                        strokeColor: strokeColor,
                        strokeWidth: strokeWeight
                    };
                    
                    console.log('Categorical symbology applied from stored data');
                } else {
                    console.log('Unknown or incomplete symbology data, applying default style');
                    applyDefaultSymbology(layerId);
                }
                
                // Update legend after symbology has been applied
                updateLegend();
                
            } catch (error) {
                console.error('Error applying stored symbology:', error);
                applyDefaultSymbology(layerId);
            }
        }

        // Apply default symbology to a layer
        function applyDefaultSymbology(layerId) {
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;

            const defaultStyle = {
                color: '#ffffff',
                weight: 2,
                opacity: 1.0,
                fillColor: '#888888',
                fillOpacity: 0.7
            };

            // No special defaults - use neutral styling for all layers

            layerInfo.layer.setStyle(defaultStyle);
            layerInfo.style = defaultStyle;
            
            // Update legend after applying default symbology
            updateLegend();
        }

        // Update legend
        function updateLegend() {
            const legendContent = document.getElementById('legendContent');
            legendContent.innerHTML = '';

            // Use layerOrder to display legend items in the same order as the Layer Panel and map rendering
            layerOrder.forEach(layerId => {
                const layerInfo = layers.get(layerId);
                if (layerInfo && layerInfo.visible) {
                    const legendContainer = document.createElement('div');
                    legendContainer.className = 'legend-layer-container mb-3';
                    
                    // Layer name header
                    const layerHeader = document.createElement('div');
                    layerHeader.className = 'text-sm font-medium text-white mb-1';
                    layerHeader.textContent = layerInfo.name;
                    legendContainer.appendChild(layerHeader);
                    
                    // Check if layer has categorical classification
                    if (layerInfo.classification && layerInfo.classification.field && layerInfo.classification.colorMap) {
                        // Categorical symbology - show multiple color swatches with categories
                        const categoriesContainer = document.createElement('div');
                        categoriesContainer.className = 'legend-categories space-y-1';
                        
                        Object.entries(layerInfo.classification.colorMap).forEach(([value, fillColor]) => {
                            const categoryItem = document.createElement('div');
                            categoryItem.className = 'legend-item flex items-center space-x-2';
                            
                            // Get stroke color and width from classification or default
                            const strokeColor = layerInfo.classification.strokeColor || layerInfo.style?.color || '#ffffff';
                            const strokeWidth = layerInfo.classification.strokeWidth || layerInfo.style?.weight || 2;
                            
                            categoryItem.innerHTML = `
                                <div class="legend-color w-4 h-4 rounded border-2" 
                                     style="background-color: ${fillColor}; border-color: ${strokeColor}; border-width: ${Math.min(strokeWidth, 2)}px;"></div>
                                <span class="text-xs text-gray-300">${value}</span>
                            `;
                            
                            categoriesContainer.appendChild(categoryItem);
                        });
                        
                        legendContainer.appendChild(categoriesContainer);
                    } else {
                        // Single symbol - show one color swatch
                        const legendItem = document.createElement('div');
                        legendItem.className = 'legend-item flex items-center space-x-2';
                        
                        // Get fill and stroke colors from current layer style
                        const fillColor = layerInfo.style?.fillColor || '#888888';
                        const strokeColor = layerInfo.style?.color || '#ffffff';
                        const strokeWidth = layerInfo.style?.weight || 2;
                        
                        // Use style as-is without special handling
                        let displayFillColor = fillColor;
                        let displayStrokeColor = strokeColor;
                        
                        legendItem.innerHTML = `
                            <div class="legend-color w-4 h-4 rounded border-2" 
                                 style="background-color: ${displayFillColor}; border-color: ${displayStrokeColor}; border-width: ${Math.min(strokeWidth, 2)}px;"></div>
                            <span class="text-xs text-gray-300">Single Symbol</span>
                        `;
                        
                        legendContainer.appendChild(legendItem);
                    }
                    
                    legendContent.appendChild(legendContainer);
                }
            });
        }

        // Setup filter listeners
        // === NEW COMPREHENSIVE FILTER SYSTEM ===
        
        // Filter state management
        let currentFilterState = {
            selectedLayer: null,
            selectedField: null,
            selectedOperator: null,
            filterValue: null,
            activeFilter: null
        };

        // Setup filter panel listeners
        function setupNewFilterListeners() {
            console.log('Setting up filter listeners...');
            
            // Check if DOM elements exist
            const filterLayerSelect = document.getElementById('filterLayerSelect');
            const filterFieldSelect = document.getElementById('filterFieldSelect');
            
            if (!filterLayerSelect) {
                console.error('filterLayerSelect element not found!');
                return;
            }
            if (!filterFieldSelect) {
                console.error('filterFieldSelect element not found!');
                return;
            }
            
            console.log('Filter DOM elements found, adding listeners...');
            
            // Layer selection
            filterLayerSelect.addEventListener('change', handleFilterLayerChange);
            
            // Field selection
            filterFieldSelect.addEventListener('change', handleFilterFieldChange);
            
            // Operator selection
            document.getElementById('filterOperatorSelect').addEventListener('change', handleFilterOperatorChange);
            
            // Value controls
            document.getElementById('filterSingleValueSelect').addEventListener('change', handleFilterValueChange);
            document.getElementById('filterTextInput').addEventListener('input', handleFilterValueChange);
            
            // Action buttons
            document.getElementById('applyFilterBtn').addEventListener('click', applyNewFilter);
            document.getElementById('clearFilterBtn').addEventListener('click', clearNewFilter);
            
            // Filter Selected button
            document.getElementById('filterSelectedBtn').addEventListener('click', createLayerFromSelection);
            
            console.log('Filter listeners added successfully');
            
            // Initial population of filter layers (in case layers are already loaded)
            setTimeout(() => {
                console.log('Attempting initial population of filter layers...');
                populateFilterLayers();
                // Ensure Aera specifically gets added
                ensureAeraInFilterDropdown();
            }, 500);
        }

        // Enhanced function to ensure Aera layer appears in filter
        function ensureAeraInFilterDropdown() {
            const layerSelect = document.getElementById('filterLayerSelect');
            if (!layerSelect) return;

            console.log('🎯 Ensuring Aera layer appears in filter dropdown...');
            
            // Check if Aera option already exists
            const existingAeraOption = Array.from(layerSelect.options).find(option => 
                option.textContent.toLowerCase().includes('aera') || option.value.includes('aera')
            );
            
            if (existingAeraOption) {
                console.log('✅ Aera layer already in dropdown');
                return;
            }

            // Look for Aera layer in layers Map
            let aeraLayerId = null;
            let aeraLayerInfo = null;
            
            layers.forEach((layerInfo, layerId) => {
                if (layerInfo.name && (layerInfo.name.toLowerCase().includes('aera') || layerInfo.name === 'Aera')) {
                    aeraLayerId = layerId;
                    aeraLayerInfo = layerInfo;
                    console.log(`✅ Found Aera layer in layers map: ${layerId} - ${layerInfo.name}`);
                }
            });

            // If found, add it to the dropdown
            if (aeraLayerId && aeraLayerInfo) {
                // Check if it has data and features
                let hasValidData = false;
                if (aeraLayerInfo.data && aeraLayerInfo.data.features && aeraLayerInfo.data.features.length > 0) {
                    const firstFeature = aeraLayerInfo.data.features[0];
                    if (firstFeature.properties && Object.keys(firstFeature.properties).length > 0) {
                        hasValidData = true;
                    }
                }

                if (hasValidData) {
                    const option = document.createElement('option');
                    option.value = aeraLayerId;
                    option.textContent = aeraLayerInfo.name;
                    layerSelect.appendChild(option);
                    console.log(`✅ Added Aera layer to filter dropdown: ${aeraLayerInfo.name}`);
                } else {
                    console.log('⚠️ Aera layer found but has no valid feature data');
                }
            } else {
                console.log('⚠️ Aera layer not found in layers Map');
                // Try to load it directly from file as fallback
                tryLoadAeraDirectly();
            }
        }

        // Fallback function to load Aera data directly for filtering
        function tryLoadAeraDirectly() {
            console.log('🔄 Trying to load Aera.geojson directly for filter...');
            
            fetch('Aera.geojson')
                .then(response => response.json())
                .then(data => {
                    console.log('✅ Loaded Aera.geojson directly, adding to filter dropdown');
                    
                    const layerSelect = document.getElementById('filterLayerSelect');
                    if (layerSelect && data.features && data.features.length > 0) {
                        const option = document.createElement('option');
                        option.value = 'aera-direct';
                        option.textContent = 'Aera (Direct Load)';
                        layerSelect.appendChild(option);
                        
                        // Store this data temporarily for filter use
                        window.aeraDirectData = data;
                        console.log('✅ Aera data stored for direct filter access');
                    }
                })
                .catch(error => {
                    console.error('❌ Failed to load Aera.geojson directly:', error);
                });
        }

        // Populate filter layer dropdown (Step 1)
        function populateFilterLayers() {
            console.log('Populating filter layers...');
            const layerSelect = document.getElementById('filterLayerSelect');
            
            if (!layerSelect) {
                console.error('Filter layer select element not found');
                return;
            }
            
            layerSelect.innerHTML = '<option value="">Choose a layer to filter</option>';

            let layerCount = 0;
            console.log(`Total layers available: ${layers.size}`);
            
            layers.forEach((layerInfo, layerId) => {
                console.log(`Checking layer ${layerId}:`, {
                    name: layerInfo.name,
                    visible: layerInfo.visible,
                    hasData: !!(layerInfo.data),
                    hasOriginalData: !!(layerInfo.originalData),
                    hasFeatures: !!(layerInfo.data && layerInfo.data.features),
                    featureCount: layerInfo.data && layerInfo.data.features ? layerInfo.data.features.length : 0,
                    hasLayer: !!(layerInfo.layer)
                });
                
                if (layerInfo.visible && layerInfo.data) {
                    // Enhanced feature detection
                    let features = [];
                    
                    if (layerInfo.data.type === 'FeatureCollection') {
                        features = layerInfo.data.features || [];
                    } else if (layerInfo.data.type === 'Feature') {
                        features = [layerInfo.data];
                    } else if (Array.isArray(layerInfo.data)) {
                        features = layerInfo.data;
                    }
                    
                    console.log(`Layer ${layerId} has ${features.length} features`);
                    
                    if (features.length > 0) {
                        // Check if layer has attribute data
                        const firstFeature = features[0];
                        if (firstFeature && firstFeature.properties && Object.keys(firstFeature.properties).length > 0) {
                            const option = document.createElement('option');
                            option.value = layerId;
                            option.textContent = layerInfo.name;
                            layerSelect.appendChild(option);
                            layerCount++;
                            console.log(`Added layer to filter dropdown: ${layerInfo.name} (${Object.keys(firstFeature.properties).length} fields)`);
                        } else {
                            console.log(`Layer ${layerId} has no properties, skipping`);
                        }
                    } else {
                        console.log(`Layer ${layerId} has no features, skipping`);
                    }
                } else {
                    console.log(`Layer ${layerId} failed visibility/data checks:`, {
                        visible: layerInfo.visible,
                        hasData: !!(layerInfo.data)
                    });
                }
            });
            
            console.log(`Populated ${layerCount} layers in filter dropdown`);
            
            if (layerCount === 0) {
                const noLayersOption = document.createElement('option');
                noLayersOption.value = "";
                noLayersOption.textContent = "No filterable layers available";
                layerSelect.appendChild(noLayersOption);
            }
        }

        // Handle layer selection change (Step 1 → Step 2)
        function handleFilterLayerChange() {
            const layerId = document.getElementById('filterLayerSelect').value;
            console.log(`Filter layer changed to: ${layerId}`);
            
            currentFilterState.selectedLayer = layerId;
            
            // Reset subsequent steps
            resetFilterSteps(['field', 'operator', 'value', 'actions']);
            
            if (layerId && layers.has(layerId)) {
                console.log(`Layer ${layerId} exists in layers map, populating fields...`);
                const layerInfo = layers.get(layerId);
                console.log('Layer info for field population:', {
                    name: layerInfo.name,
                    hasData: !!(layerInfo.data),
                    hasOriginalData: !!(layerInfo.originalData),
                    visible: layerInfo.visible
                });
                
                // Show field section first
                document.getElementById('filterFieldSection').style.display = 'block';
                
                // FIXED: Check if this is Aera layer and use direct loading
                if (layerInfo.name && layerInfo.name.toLowerCase().includes('aera')) {
                    console.log('🎯 Detected Aera layer - using direct Aera.geojson loading');
                    window.populateAeraFieldsDirect();
                } else {
                    // For non-Aera layers, use the original method
                    populateFilterFields(layerId);
                }
            } else {
                console.log(`Layer ${layerId} does not exist or is invalid`);
                console.log('Available layers:', Array.from(layers.keys()));
                document.getElementById('filterFieldSection').style.display = 'none';
            }
        }

        // Populate field dropdown (Step 2)
        function populateFilterFields(layerId) {
            const fieldSelect = document.getElementById('filterFieldSelect');
            
            console.log(`🔍 DEBUG: Populating fields for layer: ${layerId}`);
            console.log('🔍 DEBUG: Filter field select element:', fieldSelect);
            
            // Show loading state
            fieldSelect.innerHTML = '<option value="">Loading fields...</option>';
            console.log('🔍 DEBUG: Set loading state, dropdown innerHTML:', fieldSelect.innerHTML);

            let layerInfo;
            let geoJsonData;

            // Handle special case of direct Aera loading
            if (layerId === 'aera-direct' && window.aeraDirectData) {
                console.log('🔍 DEBUG: Using directly loaded Aera data for field population');
                geoJsonData = window.aeraDirectData;
            } else {
                layerInfo = layers.get(layerId);
                console.log(`🔍 DEBUG: Layer info found:`, layerInfo);
                
                if (!layerInfo) {
                    console.error(`❌ Layer ${layerId} not found in layers map`);
                    fieldSelect.innerHTML = '<option value="">Layer not found</option>';
                    console.log('🔍 DEBUG: After error, dropdown innerHTML:', fieldSelect.innerHTML);
                    return;
                }

                // Enhanced data access - check both data and originalData properties
                geoJsonData = layerInfo.data || layerInfo.originalData;
                console.log('🔍 DEBUG: GeoJSON data:', geoJsonData ? 'Found' : 'Not found');
                
                // If still no data, try to extract from the Leaflet layer itself
                if (!geoJsonData && layerInfo.layer) {
                    console.log(`🔍 DEBUG: Attempting to extract data from Leaflet layer`);
                    // Try to get data from the layer's toGeoJSON method
                    try {
                        geoJsonData = layerInfo.layer.toGeoJSON();
                        console.log(`🔍 DEBUG: Successfully extracted data from layer:`, geoJsonData);
                        
                        // Update layer info with extracted data for future use
                        layerInfo.data = geoJsonData;
                    } catch (error) {
                        console.error(`🔍 DEBUG: Failed to extract data from layer:`, error);
                    }
                }
            }

            if (!geoJsonData) {
                console.error(`❌ Layer ${layerId} has no accessible data. Attempting alternative methods...`);
                
                // Last resort: check if this is a known layer like Aera and refetch it
                if (layerInfo && (layerInfo.name === 'Aera' || layerInfo.name === 'Aera.geojson')) {
                    console.log('🔍 DEBUG: Attempting to reload Aera.geojson data...');
                    fetch('Aera.geojson')
                        .then(response => response.json())
                        .then(data => {
                            layerInfo.data = data;
                            layerInfo.originalData = JSON.parse(JSON.stringify(data));
                            populateFilterFields(layerId); // Recursive call with updated data
                        })
                        .catch(error => {
                            console.error('❌ Failed to reload Aera data:', error);
                            fieldSelect.innerHTML = '<option value="">No layer data available</option>';
                        });
                    return;
                }
                
                fieldSelect.innerHTML = '<option value="">No layer data available</option>';
                console.log('🔍 DEBUG: After no data error, dropdown innerHTML:', fieldSelect.innerHTML);
                return;
            }

            // Handle both FeatureCollection and single Feature
            let features = [];
            if (geoJsonData.type === 'FeatureCollection') {
                features = geoJsonData.features || [];
            } else if (geoJsonData.type === 'Feature') {
                features = [geoJsonData];
            } else if (Array.isArray(geoJsonData)) {
                features = geoJsonData;
            }

            console.log(`🔍 DEBUG: Features found: ${features.length}`);

            if (features.length === 0) {
                console.error(`❌ Layer ${layerId} has no features`);
                fieldSelect.innerHTML = '<option value="">No features in layer</option>';
                console.log('🔍 DEBUG: After no features error, dropdown innerHTML:', fieldSelect.innerHTML);
                return;
            }

            // Get the first feature to examine its properties
            const firstFeature = features[0];
            console.log(`🔍 DEBUG: First feature:`, firstFeature);
            
            if (!firstFeature || !firstFeature.properties) {
                console.error(`❌ First feature has no properties`);
                fieldSelect.innerHTML = '<option value="">No attributes found</option>';
                console.log('🔍 DEBUG: After no properties error, dropdown innerHTML:', fieldSelect.innerHTML);
                return;
            }

            const properties = firstFeature.properties;
            const fieldNames = Object.keys(properties);
            console.log(`🔍 DEBUG: Available fields:`, fieldNames);

            // Clear loading state and add default option - THIS IS CRITICAL
            fieldSelect.innerHTML = '<option value="">Choose a field to filter by</option>';
            console.log('🔍 DEBUG: After clearing and setting default, dropdown innerHTML:', fieldSelect.innerHTML);

            if (fieldNames.length === 0) {
                fieldSelect.innerHTML = '<option value="">No fields available</option>';
                console.log('🔍 DEBUG: After no fieldNames error, dropdown innerHTML:', fieldSelect.innerHTML);
                return;
            }

            // Filter out common system/geometry fields that aren't useful for filtering
            const systemFields = ['OBJECTID', 'objectid', 'FID', 'fid', 'Shape__Area', 'Shape__Length', 'Shape_Area', 'Shape_Length'];
            const filteredFields = fieldNames.filter(field => !systemFields.includes(field));
            
            // Sort fields alphabetically for better UX and categorize by data type
            const fieldsToShow = filteredFields.length > 0 ? filteredFields : fieldNames;
            console.log(`🔍 DEBUG: Fields to show (after system field filtering):`, fieldsToShow);
            
            // Analyze field types from sample values
            const fieldInfo = [];
            fieldsToShow.forEach(fieldName => {
                const sampleValue = properties[fieldName];
                let dataType = 'text';
                
                if (typeof sampleValue === 'number') {
                    dataType = 'number';
                } else if (typeof sampleValue === 'boolean') {
                    dataType = 'boolean';
                } else if (sampleValue && !isNaN(Date.parse(sampleValue))) {
                    dataType = 'date';
                }
                
                fieldInfo.push({
                    name: fieldName,
                    type: dataType,
                    sample: sampleValue
                });
            });
            
            // Sort by name
            fieldInfo.sort((a, b) => a.name.localeCompare(b.name));
            console.log(`🔍 DEBUG: Field info prepared:`, fieldInfo);
            
            // Add fields to dropdown - THIS IS THE CRITICAL PART
            let optionsAdded = 0;
            fieldInfo.forEach(field => {
                const option = document.createElement('option');
                option.value = field.name;
                // Show field name with a hint about data type
                option.textContent = `${field.name} (${field.type})`;
                fieldSelect.appendChild(option);
                optionsAdded++;
                console.log(`🔍 DEBUG: Added option: ${field.name} (${field.type})`);
            });

            console.log(`✅ DEBUG: Populated ${fieldsToShow.length} fields into dropdown, options added: ${optionsAdded}`);
            console.log('🔍 DEBUG: Final dropdown innerHTML:', fieldSelect.innerHTML);
            console.log('🔍 DEBUG: Final dropdown options count:', fieldSelect.options.length);
            
            // Force a DOM update - sometimes needed for complex applications
            setTimeout(() => {
                console.log('🔍 DEBUG: After timeout - dropdown options count:', fieldSelect.options.length);
                console.log('🔍 DEBUG: After timeout - dropdown innerHTML length:', fieldSelect.innerHTML.length);
            }, 10);
        }

        // Handle field selection change (Step 2 → Step 3)
        function handleFilterFieldChange() {
            const fieldName = document.getElementById('filterFieldSelect').value;
            currentFilterState.selectedField = fieldName;
            
            // Reset subsequent steps
            resetFilterSteps(['operator', 'value', 'actions']);
            
            if (fieldName) {
                document.getElementById('filterOperatorSection').style.display = 'block';
            } else {
                document.getElementById('filterOperatorSection').style.display = 'none';
            }
        }

        // Handle operator selection change (Step 3 → Step 4)
        function handleFilterOperatorChange() {
            const operator = document.getElementById('filterOperatorSelect').value;
            currentFilterState.selectedOperator = operator;
            
            // Reset value step
            resetFilterSteps(['value', 'actions']);
            
            if (operator) {
                setupFilterValueInput(operator);
                document.getElementById('filterActionsSection').style.display = 'block';
            } else {
                document.getElementById('filterValueSection').style.display = 'none';
                document.getElementById('filterActionsSection').style.display = 'none';
            }
        }

        // Setup appropriate input control based on operator (Step 4)
        function setupFilterValueInput(operator) {
            const valueSection = document.getElementById('filterValueSection');
            const singleSelect = document.getElementById('filterSingleValueSelect');
            const multiContainer = document.getElementById('filterMultiValueContainer');
            const textInput = document.getElementById('filterTextInput');
            
            // Hide all inputs first
            singleSelect.style.display = 'none';
            multiContainer.style.display = 'none';
            textInput.style.display = 'none';
            
            // Logic-only operators don't need value input
            if (['is_empty', 'is_not_empty', 'is_null', 'is_not_null'].includes(operator)) {
                valueSection.style.display = 'none';
                return;
            }
            
            valueSection.style.display = 'block';
            
            // Determine input type based on operator
            if (['equal', 'not_equal'].includes(operator)) {
                // Single value dropdown
                singleSelect.style.display = 'block';
                populateFilterValues('single');
            } else if (['include', 'does_not_include'].includes(operator)) {
                // Multi-value checkboxes
                multiContainer.style.display = 'block';
                populateFilterValues('multi');
            } else {
                // Text input for contains, starts_with, etc.
                textInput.style.display = 'block';
                textInput.value = '';
            }
        }

        // Populate filter values from field data
        function populateFilterValues(type) {
            const layerId = currentFilterState.selectedLayer;
            const fieldName = currentFilterState.selectedField;
            
            if (!layerId || !fieldName) return;
            
            let geoJsonData;
            
            // Handle direct Aera loading
            if (layerId === 'aera-direct' && window.aeraDirectData) {
                geoJsonData = window.aeraDirectData;
            } else {
                const layerInfo = layers.get(layerId);
                if (!layerInfo) return;
                geoJsonData = layerInfo.data;
            }
            
            if (!geoJsonData || !geoJsonData.features) return;
            
            // Get unique values from the field
            const uniqueValues = new Set();
            geoJsonData.features.forEach(feature => {
                const value = feature.properties[fieldName];
                if (value !== null && value !== undefined && value !== '') {
                    uniqueValues.add(value.toString());
                }
            });
            
            const sortedValues = Array.from(uniqueValues).sort();
            
            if (type === 'single') {
                // Populate single select dropdown
                const singleSelect = document.getElementById('filterSingleValueSelect');
                singleSelect.innerHTML = '<option value="">Choose a value</option>';
                
                sortedValues.forEach(value => {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = value;
                    singleSelect.appendChild(option);
                });
            } else if (type === 'multi') {
                // Populate multi-select checkboxes
                const multiList = document.getElementById('filterMultiValueList');
                multiList.innerHTML = '';
                
                sortedValues.forEach(value => {
                    const label = document.createElement('label');http://127.0.0.1:3000/index.html#select-panel
                    label.className = 'flex items-center space-x-2 text-sm text-gray-300 cursor-pointer mb-2';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = value;
                    checkbox.className = 'rounded border-gray-600 bg-gray-700 text-blue-500 focus:ring-blue-500';
                    checkbox.addEventListener('change', handleFilterValueChange);
                    
                    const span = document.createElement('span');
                    span.textContent = value;
                    
                    label.appendChild(checkbox);
                    label.appendChild(span);
                    multiList.appendChild(label);
                });
            }
        }

        // Handle filter value change
        function handleFilterValueChange() {
            const operator = currentFilterState.selectedOperator;
            let value = null;
            
            if (['equal', 'not_equal'].includes(operator)) {
                value = document.getElementById('filterSingleValueSelect').value;
            } else if (['include', 'does_not_include'].includes(operator)) {
                const checkboxes = document.querySelectorAll('#filterMultiValueList input[type="checkbox"]:checked');
                value = Array.from(checkboxes).map(cb => cb.value);
            } else if (['contains', 'does_not_contain', 'starts_with', 'does_not_start_with'].includes(operator)) {
                value = document.getElementById('filterTextInput').value.trim();
            }
            
            currentFilterState.filterValue = value;
        }

        // Apply the new filter
        function applyNewFilter() {
            const { selectedLayer, selectedField, selectedOperator, filterValue } = currentFilterState;
            
            if (!selectedLayer || !selectedField || !selectedOperator) {
                showWarning('Please complete all filter steps before applying.', 'Filter Incomplete');
                return;
            }
            
            // Validate value for operators that require it
            const operatorsNeedingValue = ['equal', 'not_equal', 'include', 'does_not_include', 'contains', 'does_not_contain', 'starts_with', 'does_not_start_with'];
            if (operatorsNeedingValue.includes(selectedOperator)) {
                if (!filterValue || (Array.isArray(filterValue) && filterValue.length === 0)) {
                    showWarning('Please select or enter a filter value.', 'Filter Value Required');
                    return;
                }
            }

            let originalData;
            let layerInfo;
            let layerStyle = null;
            
            // Handle direct Aera loading
            if (selectedLayer === 'aera-direct' && window.aeraDirectData) {
                originalData = window.aeraDirectData;
                console.log('Using directly loaded Aera data for filtering');
                
                // Find the actual Aera layer in the layers map to get its style
                layers.forEach((info, layerId) => {
                    if (info.name === 'Aera' || info.name === 'Aera.geojson') {
                        layerInfo = info;  // Use this for layer updates
                        layerStyle = info.style;  // Get the original Aera style
                        console.log('Found Aera layer style:', layerStyle);
                    }
                });
                
                if (!layerInfo) {
                    showError('Original Aera layer not found. Cannot apply filter.', 'Filter Error');
                    return;
                }
            } else {
                layerInfo = layers.get(selectedLayer);
                if (!layerInfo) {
                    showError('Selected layer not found. Please refresh and try again.', 'Filter Error');
                    return;
                }
                originalData = layerInfo.originalData || layerInfo.data;
                layerStyle = layerInfo.style;  // Use the layer's own style
            }
            
            if (!originalData || !originalData.features) {
                showError('Layer data not available for filtering.', 'Filter Error');
                return;
            }
            
            // Apply filter logic
            const filteredFeatures = originalData.features.filter(feature => {
                return evaluateFilterCondition(feature, selectedField, selectedOperator, filterValue);
            });
            
            console.log(`🔍 Filtered ${originalData.features.length} features down to ${filteredFeatures.length}`);
            
            if (filteredFeatures.length === 0) {
                showAlert('No features match the filter criteria.', 'Filter Results');
                return;
            }
            
            // Create filtered GeoJSON
            const filteredData = {
                type: 'FeatureCollection',
                features: filteredFeatures
            };
            
            // Remove existing layer and add filtered layer
            map.removeLayer(layerInfo.layer);
            
            // Ensure we have a valid style - preserve the original layer's styling approach
            let styleToUse = layerStyle || layerInfo.style;
            
            // If still no style, try to extract from the original layer itself
            if (!styleToUse && layerInfo.layer && layerInfo.layer.options) {
                styleToUse = layerInfo.layer.options.style;
            }
            
            // Final fallback to prevent any default blue styling
            if (!styleToUse) {
                console.warn('No style found for filtered layer, using Aera default style');
                styleToUse = {
                    color: '#ffffff',
                    weight: 2,
                    opacity: 1.0,
                    fillColor: '#14b8a6',
                    fillOpacity: 1.0
                };
            }
            
            const filteredLayer = L.geoJSON(filteredData, {
                renderer: L.canvas(), // Force canvas rendering for leaflet-image export compatibility
                style: styleToUse, // Use the preserved original style with proper fallbacks
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="modern-popup-container">';
                        popupContent += '<div class="modern-popup-header"><i class="fas fa-info-circle mr-2"></i>Feature Properties</div>';
                        popupContent += '<div class="modern-popup-body">';
                        
                        for (let key in feature.properties) {
                            popupContent += `<div class="property-row">`;
                            popupContent += `<div class="property-key">${key}</div>`;
                            popupContent += `<div class="property-value">${feature.properties[key] || 'N/A'}</div>`;
                            popupContent += `</div>`;
                        }
                        
                        popupContent += '</div></div>';
                        
                        layer.bindPopup(popupContent, {
                            className: 'modern-feature-popup',
                            maxWidth: 350,
                            maxHeight: 400
                        });
                    }
                }
            }).addTo(map);
            
            // Update layer info
            layerInfo.layer = filteredLayer;
            layerInfo.data = filteredData;
            
            // Store active filter
            currentFilterState.activeFilter = {
                layerId: selectedLayer,
                layerName: layerInfo.name,
                field: selectedField,
                operator: selectedOperator,
                value: filterValue
            };
            
            // Show filter status
            showFilterStatus();
            
            // Zoom to filtered features
            if (filteredLayer.getBounds().isValid()) {
                map.fitBounds(filteredLayer.getBounds());
            }
            
            console.log(`Filter applied: ${filteredFeatures.length} features match criteria`);
        }

        // Evaluate filter condition for a feature
        function evaluateFilterCondition(feature, field, operator, value) {
            const fieldValue = feature.properties[field];
            const fieldStr = fieldValue ? fieldValue.toString().toLowerCase() : '';
            
            switch (operator) {
                case 'equal':
                    return fieldValue?.toString() === value;
                case 'not_equal':
                    return fieldValue?.toString() !== value;
                case 'include':
                    return Array.isArray(value) && value.some(v => fieldValue?.toString() === v);
                case 'does_not_include':
                    return Array.isArray(value) && !value.some(v => fieldValue?.toString() === v);
                case 'contains':
                    return fieldStr.includes(value.toLowerCase());
                case 'does_not_contain':
                    return !fieldStr.includes(value.toLowerCase());
                case 'starts_with':
                    return fieldStr.startsWith(value.toLowerCase());
                case 'does_not_start_with':
                    return !fieldStr.startsWith(value.toLowerCase());
                case 'is_empty':
                    return !fieldValue || fieldValue.toString().trim() === '';
                case 'is_not_empty':
                    return fieldValue && fieldValue.toString().trim() !== '';
                case 'is_null':
                    return fieldValue === null || fieldValue === undefined;
                case 'is_not_null':
                    return fieldValue !== null && fieldValue !== undefined;
                default:
                    return true;
            }
        }

        // Show filter status
        function showFilterStatus() {
            const statusSection = document.getElementById('filterStatusSection');
            const statusText = document.getElementById('filterStatusText');
            
            if (currentFilterState.activeFilter) {
                const { layerName, field, operator, value } = currentFilterState.activeFilter;
                let description = `Layer: ${layerName} | Field: ${field} | ${getOperatorText(operator)}`;
                
                if (Array.isArray(value)) {
                    description += ` | Values: ${value.join(', ')}`;
                } else if (value) {
                    description += ` | Value: ${value}`;
                }
                
                statusText.textContent = description;
                statusSection.style.display = 'block';
            } else {
                statusSection.style.display = 'none';
            }
        }

        // Get human-readable operator text
        function getOperatorText(operator) {
            const operatorMap = {
                'equal': 'Equal to',
                'not_equal': 'Not equal to',
                'include': 'Include any of',
                'does_not_include': 'Does not include any of',
                'contains': 'Contains',
                'does_not_contain': 'Does not contain',
                'starts_with': 'Starts with',
                'does_not_start_with': 'Does not start with',
                'is_empty': 'Is empty',
                'is_not_empty': 'Is not empty',
                'is_null': 'Is null',
                'is_not_null': 'Is not null'
            };
            return operatorMap[operator] || operator;
        }

        // Clear the current filter
        function clearNewFilter() {
            if (!currentFilterState.activeFilter) {
                showAlert('No active filter to clear.', 'Filter Status');
                return;
            }
            
            const layerId = currentFilterState.activeFilter.layerId;
            let layerInfo;
            
            // Handle aera-direct case
            if (layerId === 'aera-direct') {
                // Find the actual Aera layer in the layers map
                layers.forEach((info, id) => {
                    if (info.name === 'Aera' || info.name === 'Aera.geojson') {
                        layerInfo = info;
                    }
                });
            } else {
                layerInfo = layers.get(layerId);
            }
            
            if (!layerInfo) return;
            
            // Remove current layer
            map.removeLayer(layerInfo.layer);
            
            // Restore original data
            const originalLayer = L.geoJSON(layerInfo.originalData, {
                renderer: L.canvas(), // Force canvas rendering for leaflet-image export compatibility
                style: layerInfo.style,
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="modern-popup-container">';
                        popupContent += '<div class="modern-popup-header"><i class="fas fa-info-circle mr-2"></i>Feature Properties</div>';
                        popupContent += '<div class="modern-popup-body">';
                        
                        for (let key in feature.properties) {
                            popupContent += `<div class="property-row">`;
                            popupContent += `<div class="property-key">${key}</div>`;
                            popupContent += `<div class="property-value">${feature.properties[key] || 'N/A'}</div>`;
                            popupContent += `</div>`;
                        }
                        
                        popupContent += '</div></div>';
                        
                        layer.bindPopup(popupContent, {
                            className: 'modern-feature-popup',
                            maxWidth: 350,
                            maxHeight: 400
                        });
                    }
                }
            }).addTo(map);
            
            // Update layer info
            layerInfo.layer = originalLayer;
            layerInfo.data = layerInfo.originalData;
            
            // Clear filter state
            currentFilterState.activeFilter = null;
            
            // Reset UI
            resetFilterSteps(['layer', 'field', 'operator', 'value', 'actions', 'status']);
            
            // Zoom to full layer
            if (originalLayer.getBounds().isValid()) {
                map.fitBounds(originalLayer.getBounds());
            }
            
            console.log('Filter cleared, original layer restored');
        }

        // Reset filter steps UI
        function resetFilterSteps(steps) {
            if (steps.includes('layer')) {
                document.getElementById('filterLayerSelect').selectedIndex = 0;
                currentFilterState.selectedLayer = null;
            }
            if (steps.includes('field')) {
                document.getElementById('filterFieldSelect').innerHTML = '<option value="">Choose a field to filter by</option>';
                document.getElementById('filterFieldSection').style.display = 'none';
                currentFilterState.selectedField = null;
            }
            if (steps.includes('operator')) {
                document.getElementById('filterOperatorSelect').selectedIndex = 0;
                document.getElementById('filterOperatorSection').style.display = 'none';
                currentFilterState.selectedOperator = null;
            }
            if (steps.includes('value')) {
                document.getElementById('filterValueSection').style.display = 'none';
                document.getElementById('filterSingleValueSelect').innerHTML = '<option value="">Loading values...</option>';
                document.getElementById('filterMultiValueList').innerHTML = '';
                document.getElementById('filterTextInput').value = '';
                currentFilterState.filterValue = null;
            }
            if (steps.includes('actions')) {
                document.getElementById('filterActionsSection').style.display = 'none';
            }
            if (steps.includes('status')) {
                document.getElementById('filterStatusSection').style.display = 'none';
            }
        }

        // === FILTER SELECTED FEATURES FUNCTIONALITY ===
        
        // Update Filter Selected button state based on current selection
        function updateFilterSelectedButton() {
            const button = document.getElementById('filterSelectedBtn');
            const countSpan = document.getElementById('selectedFeaturesCount');
            
            if (!button || !countSpan) {
                console.error("❌ Missing required elements for Filter Selected button");
                return;
            }
            
            const selectedCount = getSelectedFeaturesCount();
            
            if (selectedCount > 0) {
                button.disabled = false;
                button.title = `Create layer from ${selectedCount} selected feature${selectedCount > 1 ? 's' : ''}`;
                countSpan.textContent = `${selectedCount} feature${selectedCount > 1 ? 's' : ''} selected`;
                countSpan.className = 'text-xs text-green-400 mt-1 text-center';
            } else {
                button.disabled = true;
                button.title = 'No features selected. Use the Selection Tool first.';
                countSpan.textContent = 'No features selected';
                countSpan.className = 'text-xs text-gray-400 mt-1 text-center';
            }
        }
        
        // Get count of currently selected features
        function getSelectedFeaturesCount() {
            // Use the global selectedFeatures array from selection tool
            return selectedFeatures ? selectedFeatures.length : 0;
        }
        
        // Get currently selected features as GeoJSON
        function getSelectedFeaturesAsGeoJSON() {
            // Use the global selectedFeatures array from selection tool
            if (!selectedFeatures || selectedFeatures.length === 0) {
                return null;
            }
            
            // Convert to proper GeoJSON FeatureCollection
            const geoJsonFeatures = selectedFeatures.map(selectionItem => {
                // selectionItem has structure: {layerId, layerName, feature, properties}
                const feature = selectionItem.feature;
                
                // If feature has toGeoJSON method (Leaflet layer), use it
                if (feature && typeof feature.toGeoJSON === 'function') {
                    return feature.toGeoJSON();
                }
                
                // If feature has feature property (wrapped), use it
                if (feature && feature.feature && feature.feature.type === 'Feature') {
                    return feature.feature;
                }
                
                // Fallback: create GeoJSON from properties
                if (selectionItem.properties) {
                    return {
                        type: 'Feature',
                        geometry: feature.toGeoJSON ? feature.toGeoJSON().geometry : null,
                        properties: selectionItem.properties
                    };
                }
                
                return null;
            }).filter(f => f && f.type === 'Feature'); // Only include valid features
            
            return {
                type: 'FeatureCollection',
                features: geoJsonFeatures
            };
        }
        
        // Create a new persistent layer from selected features
        async function createLayerFromSelection() {
            console.log('🎯 Creating layer from selected features...');
            
            const selectedGeoJSON = getSelectedFeaturesAsGeoJSON();
            
            if (!selectedGeoJSON || selectedGeoJSON.features.length === 0) {
                showWarning('No features selected. Please use the Selection Tool to select features first.', 'Selection Required');
                return;
            }
            
            console.log(`📊 Creating layer from ${selectedGeoJSON.features.length} selected features`);
            
            // Generate unique layer ID and name
            const timestamp = new Date().toISOString().slice(0, 19).replace('T', ' ');
            const layerId = `filtered-selection-${Date.now()}`;
            const layerName = `Filtered Selection ${timestamp}`;
            
            // Create default style for the new layer
            const defaultStyle = {
                fillColor: '#ff7800',
                weight: 2,
                opacity: 1,
                color: '#ff7800',
                dashArray: '3',
                fillOpacity: 0.7
            };
            
            try {
                // Create the layer on the map first
                const newLayer = L.geoJSON(selectedGeoJSON, {
                    renderer: L.canvas(), // Force canvas rendering for leaflet-image export compatibility
                    style: defaultStyle,
                    onEachFeature: (feature, layer) => {
                        // Add popup with feature properties
                        if (feature.properties) {
                            let popupContent = '<div class="feature-popup">';
                            popupContent += `<h4 class="popup-title">${layerName}</h4>`;
                            for (let key in feature.properties) {
                                if (feature.properties.hasOwnProperty(key)) {
                                    popupContent += `<p><strong>${key}:</strong> ${feature.properties[key]}</p>`;
                                }
                            }
                            popupContent += '</div>';
                            
                            safeBindPopup(layer, popupContent);
                        }
                    }
                }).addTo(map);
                
                // Add to layers map BEFORE saving to Supabase (so style is available)
                layers.set(layerId, {
                    layer: newLayer,
                    name: layerName,
                    visible: true,
                    data: selectedGeoJSON,
                    originalData: selectedGeoJSON,
                    style: defaultStyle,
                    isPermanent: false,
                    isUserGenerated: true,
                    createdAt: new Date().toISOString()
                });
                
                // Now save to Supabase (layer info is available)
                console.log('💾 Saving filtered layer to Supabase...');
                const success = await saveLayerToSupabase(layerId, layerName, selectedGeoJSON);
                
                if (!success) {
                    // If Supabase save fails, we can still keep the local layer
                    console.warn('⚠️ Supabase save failed, but layer created locally');
                }
                
                // Add to layer order (at the top for visibility)
                layerOrder.unshift(layerId);
                
                // Update UI
                updateLayersList();
                updateLegend();
                
                // Zoom to new layer
                if (newLayer.getBounds().isValid()) {
                    map.fitBounds(newLayer.getBounds());
                }
                
                // Show success message
                showSuccess(`Filtered layer "${layerName}" created and saved!\n\nFeatures: ${selectedGeoJSON.features.length}\nLayer ID: ${layerId}`, 'Layer Created');
                
                // Optionally prompt for rename
                setTimeout(async () => {
                    if (await showConfirm('Would you like to rename this layer now?', 'Rename Layer')) {
                        renameLayer(layerId, layerName);
                    }
                }, 1000);
                
                console.log(`✅ Successfully created filtered layer: ${layerName}`);
                
            } catch (error) {
                console.error('❌ Failed to create filtered layer:', error);
                showError(`Failed to create filtered layer: ${error.message}`, 'Layer Creation Failed');
            }
        }
        
        // Auto-update Filter Selected button when selection changes
        // This should be called whenever selection state changes
        function onSelectionChanged() {
            updateFilterSelectedButton();
        }
        
        // Initialize Filter Selected button state
        setTimeout(() => {
            updateFilterSelectedButton();
            
            // Set up periodic check for selection changes (fallback)
            setInterval(updateFilterSelectedButton, 2000);
        }, 1000);
        
        // Make selection monitoring functions available globally
        window.updateFilterSelectedButton = updateFilterSelectedButton;
        window.onSelectionChanged = onSelectionChanged;
        
        // Add debugging functions for testing
        window.debugFilterSelectedButton = function() {
            console.log("🧪 MANUAL DEBUG TEST");
            console.log("selectedFeatures:", selectedFeatures);
            console.log("selectedFeatures.length:", selectedFeatures ? selectedFeatures.length : 'undefined');
            console.log("Button element:", document.getElementById('filterSelectedBtn'));
            console.log("Count span element:", document.getElementById('selectedFeaturesCount'));
            updateFilterSelectedButton();
        };
        
        window.testButtonEnable = function() {
            console.log("🧪 MANUAL BUTTON ENABLE TEST");
            const button = document.getElementById('filterSelectedBtn');
            if (button) {
                button.disabled = false;
                console.log("Button manually enabled");
            } else {
                console.log("Button not found");
            }
        };

        // === END NEW FILTER SYSTEM ===
        
        // Testing utilities for filter system
        function testAeraFilterAccess() {
            console.log('🧪 Testing Aera filter access...');
            
            // Test 1: Check if Aera layer is in layers Map
            console.log('📊 Checking layers Map for Aera:');
            let aeraFound = false;
            layers.forEach((layerInfo, layerId) => {
                if (layerInfo.name && layerInfo.name.toLowerCase().includes('aera')) {
                    console.log(`✅ Found Aera layer: ${layerId} - ${layerInfo.name}`);
                    console.log('  - Has data:', !!(layerInfo.data));
                    console.log('  - Has originalData:', !!(layerInfo.originalData));
                    console.log('  - Feature count:', layerInfo.data?.features?.length || 0);
                    console.log('  - First feature properties:', layerInfo.data?.features?.[0]?.properties ? Object.keys(layerInfo.data.features[0].properties) : 'None');
                    aeraFound = true;
                }
            });
            
            if (!aeraFound) {
                console.log('❌ No Aera layer found in layers Map');
            }
            
            // Test 2: Check direct Aera data
            console.log('🔍 Checking for direct Aera data:');
            if (window.aeraDirectData) {
                console.log('✅ Direct Aera data available');
                console.log('  - Feature count:', window.aeraDirectData.features?.length || 0);
                console.log('  - First feature properties:', window.aeraDirectData.features?.[0]?.properties ? Object.keys(window.aeraDirectData.features[0].properties) : 'None');
            } else {
                console.log('❌ No direct Aera data found');
            }
            
            // Test 3: Try to load Aera directly
            console.log('🔄 Testing direct Aera loading:');
            fetch('Aera.geojson')
                .then(response => response.json())
                .then(data => {
                    console.log('✅ Aera.geojson loaded successfully');
                    console.log('  - Feature count:', data.features?.length || 0);
                    if (data.features && data.features.length > 0) {
                        console.log('  - Sample properties:', Object.keys(data.features[0].properties || {}));
                        console.log('  - First 5 property names:', Object.keys(data.features[0].properties || {}).slice(0, 5));
                    }
                })
                .catch(error => {
                    console.error('❌ Failed to load Aera.geojson:', error);
                });
        }
        
        function refreshFilterDropdown() {
            console.log('🔄 Manually refreshing filter dropdown...');
            populateFilterLayers();
            setTimeout(() => {
                ensureAeraInFilterDropdown();
            }, 100);
        }
        
        // Test function to manually populate filter fields - FIXED FOR CORRECT AERA LAYER
        function testFilterFieldPopulation() {
            console.log('🧪 Testing filter field population...');
            
            // ALWAYS use Aera.geojson directly - bypass layer system completely
            console.log('🔄 Loading Aera.geojson directly for testing...');
            
            const fieldSelect = document.getElementById('filterFieldSelect');
            if (!fieldSelect) {
                console.error('❌ filterFieldSelect element not found');
                return;
            }
            
            // Load Aera.geojson directly
            fetch('Aera.geojson')
                .then(response => response.json())
                .then(geoJsonData => {
                    console.log('✅ Aera.geojson loaded for testing');
                    console.log('📊 Feature count:', geoJsonData.features?.length);
                    
                    if (geoJsonData.features && geoJsonData.features.length > 0) {
                        const properties = geoJsonData.features[0].properties;
                        const fieldNames = Object.keys(properties);
                        console.log('📋 Available fields:', fieldNames);
                        
                        // Clear and populate dropdown directly
                        fieldSelect.innerHTML = '<option value="">Choose a field to filter by</option>';
                        
                        fieldNames.forEach(fieldName => {
                            const option = document.createElement('option');
                            option.value = fieldName;
                            option.textContent = fieldName;
                            fieldSelect.appendChild(option);
                            console.log(`✅ Added test option: ${fieldName}`);
                        });
                        
                        console.log(`🎯 Test completed: ${fieldNames.length} fields added to dropdown`);
                        console.log('� Final dropdown options count:', fieldSelect.options.length);
                    }
                })
                .catch(error => {
                    console.error('❌ Test failed to load Aera.geojson:', error);
                });
        }
        
        // Make test functions available globally
        window.testFilterFieldPopulation = testFilterFieldPopulation;
        window.testAeraFilterAccess = testAeraFilterAccess;
        window.refreshFilterDropdown = refreshFilterDropdown;
        
        // NEW: Direct Aera field population function that bypasses layer system
        window.populateAeraFieldsDirect = function() {
            console.log('🎯 DIRECT Aera field population - bypassing layer system completely');
            
            const fieldSelect = document.getElementById('filterFieldSelect');
            if (!fieldSelect) {
                console.error('❌ filterFieldSelect element not found');
                return;
            }
            
            fieldSelect.innerHTML = '<option value="">Loading Aera fields...</option>';
            
            fetch('Aera.geojson')
                .then(response => response.json())
                .then(geoJsonData => {
                    console.log('✅ Aera.geojson loaded directly');
                    
                    if (!geoJsonData.features || geoJsonData.features.length === 0) {
                        throw new Error('No features found');
                    }
                    
                    const properties = geoJsonData.features[0].properties;
                    const fieldNames = Object.keys(properties);
                    
                    console.log('📋 Fields found:', fieldNames);
                    
                    // Clear dropdown and add default
                    fieldSelect.innerHTML = '<option value="">Choose a field to filter by</option>';
                    
                    // Add each field
                    fieldNames.forEach(fieldName => {
                        const option = document.createElement('option');
                        option.value = fieldName;
                        option.textContent = fieldName;
                        fieldSelect.appendChild(option);
                    });
                    
                    console.log(`✅ SUCCESS: ${fieldNames.length} fields added to dropdown`);
                    console.log('🔍 Dropdown now has', fieldSelect.options.length, 'options');
                    
                    // Store data for filtering
                    window.aeraFilterData = geoJsonData;
                    
                    // Show the field section
                    document.getElementById('filterFieldSection').style.display = 'block';
                })
                .catch(error => {
                    console.error('❌ Failed to load Aera fields:', error);
                    fieldSelect.innerHTML = '<option value="">Failed to load</option>';
                });
        };
        
        // Debug function to test filter system
        function debugFilterSystem() {
            console.log('=== FILTER SYSTEM DEBUG ===');
            console.log('Total layers:', layers.size);
            console.log('Layers map:', layers);
            
            const filterLayerSelect = document.getElementById('filterLayerSelect');
            const filterFieldSelect = document.getElementById('filterFieldSelect');
            
            console.log('Filter layer select element:', filterLayerSelect);
            console.log('Filter layer select options:', filterLayerSelect ? filterLayerSelect.options.length : 'N/A');
            console.log('Filter field select element:', filterFieldSelect);
            
            console.log('Current filter state:', currentFilterState);
            console.log('=== END DEBUG ===');
        }
        
        // Make debug function available globally (for console testing)
        window.debugFilterSystem = debugFilterSystem;
        
        // **NEW: Debug function to check all layer renderers**
        window.debugLayerRenderers = function() {
            console.log('🔍 === LAYER RENDERER DEBUG ===');
            console.log(`Total layers in map: ${layers.size}`);
            
            let canvasCount = 0;
            let svgCount = 0;
            let unknownCount = 0;
            
            layers.forEach((layerInfo, layerId) => {
                const layer = layerInfo.layer;
                
                // Check renderer configuration
                const hasRendererOption = !!layer.options.renderer;
                const rendererType = layer.options.renderer ? layer.options.renderer.constructor.name : 'None';
                const isCanvasOption = layer.options.renderer instanceof L.Canvas;
                
                // Check actual renderer instance
                const actualRenderer = layer._renderer ? layer._renderer.constructor.name : 'None';
                const isActualCanvas = layer._renderer instanceof L.Canvas;
                
                // Count renderer types
                if (isCanvasOption || isActualCanvas) {
                    canvasCount++;
                } else if (layer._renderer instanceof L.SVG) {
                    svgCount++;
                } else {
                    unknownCount++;
                }
                
                console.log(`📋 Layer: "${layerInfo.name}" (${layerId})`);
                console.log(`  - Renderer option: ${rendererType} (Canvas: ${isCanvasOption})`);
                console.log(`  - Actual renderer: ${actualRenderer} (Canvas: ${isActualCanvas})`);
                console.log(`  - Visible: ${layerInfo.visible}`);
                console.log(`  - On map: ${map.hasLayer(layer)}`);
                
                // Special check for Aera layer
                if (layerInfo.name === 'Aera') {
                    console.log(`  🎯 AERA SPECIAL: This is the main Aera layer`);
                    
                    // Test if layer is canvas-ready for export
                    const isExportReady = (isCanvasOption || isActualCanvas) && layerInfo.visible && map.hasLayer(layer);
                    console.log(`  🚀 Export ready: ${isExportReady}`);
                }
                
                console.log('---');
            });
            
            console.log(`📊 Renderer Summary:`);
            console.log(`  - Canvas: ${canvasCount}`);
            console.log(`  - SVG: ${svgCount}`);
            console.log(`  - Unknown: ${unknownCount}`);
            console.log('=== END RENDERER DEBUG ===');
            
            return { canvasCount, svgCount, unknownCount };
        };
        
        // **NEW: Quick function to test if Aera is canvas-rendered**
        window.testAeraCanvas = function() {
            console.log('🎯 Testing Aera layer canvas rendering...');
            
            let aeraLayer = null;
            layers.forEach((layerInfo, layerId) => {
                if (layerInfo.name === 'Aera') {
                    aeraLayer = layerInfo.layer;
                    console.log('✅ Found Aera layer');
                    console.log('Layer added to map:', aeraLayer.options, 'Is using canvas?', aeraLayer.options.renderer instanceof L.Canvas);
                    
                    // Additional checks
                    console.log('Actual renderer:', aeraLayer._renderer ? aeraLayer._renderer.constructor.name : 'None');
                    console.log('Is actual renderer Canvas?', aeraLayer._renderer instanceof L.Canvas);
                }
            });
            
            if (!aeraLayer) {
                console.error('❌ Aera layer not found!');
                return false;
            }
            
            return aeraLayer.options.renderer instanceof L.Canvas;
        };
        
        // Test filter system function 
        window.testFilterSystem = function() {
            console.log('Testing filter system...');
            debugFilterSystem();
            
            // Force populate filter layers
            populateFilterLayers();
            
            // Test layer selection  
            const filterLayerSelect = document.getElementById('filterLayerSelect');
            if (filterLayerSelect && filterLayerSelect.options.length > 1) {
                console.log('SUCCESS: Filter layers are available');
                
                // Test field population by simulating layer selection
                const firstLayerOption = filterLayerSelect.options[1]; // Skip "Choose a layer"
                if (firstLayerOption) {
                    console.log('Testing field population for layer:', firstLayerOption.text);
                    filterLayerSelect.value = firstLayerOption.value;
                    handleFilterLayerChange();
                    
                    setTimeout(() => {
                        const filterFieldSelect = document.getElementById('filterFieldSelect');
                        if (filterFieldSelect && filterFieldSelect.options.length > 1) {
                            console.log('SUCCESS: Filter fields populated successfully!');
                            console.log(`Found ${filterFieldSelect.options.length - 1} fields:`, 
                                Array.from(filterFieldSelect.options).slice(1).map(opt => opt.text));
                        } else {
                            console.log('ISSUE: Filter fields not populated');
                        }
                    }, 100);
                }
            } else {
                console.log('ISSUE: No filter layers available');
            }
        };
        
        // Auto-test after layers load
        setTimeout(() => {
            console.log('Running automatic filter system test...');
            window.testFilterSystem();
        }, 2000);

        // Legacy filter functions (keeping for compatibility but they won't be used)
        function setupFilterListeners() {
            document.getElementById('filterLayer').addEventListener('change', populateFilterFields);
            document.getElementById('applyFilter').addEventListener('click', applyFilter);
            document.getElementById('clearFilter').addEventListener('click', clearFilter);
        }

        // Populate filter modal
        function populateFilterModal() {
            const layerSelect = document.getElementById('filterLayer');
            layerSelect.innerHTML = '<option value="">Select a layer</option>';

            layers.forEach((layerInfo, layerId) => {
                if (layerInfo.visible) {
                    const option = document.createElement('option');
                    option.value = layerId;
                    option.textContent = layerInfo.name;
                    layerSelect.appendChild(option);
                }
            });
        }

        // Populate filter fields
        function populateFilterFields() {
            const layerId = document.getElementById('filterLayer').value;
            const fieldSelect = document.getElementById('filterField');
            fieldSelect.innerHTML = '<option value="">Select a field</option>';

            if (layerId && layers.has(layerId)) {
                const layerInfo = layers.get(layerId);
                const features = layerInfo.data.features;

                if (features && features.length > 0) {
                    const properties = features[0].properties || {};
                    Object.keys(properties).forEach(key => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = key;
                        fieldSelect.appendChild(option);
                    });
                }
            }
        }

        // Apply filter
        function applyFilter() {
            const layerId = document.getElementById('filterLayer').value;
            const field = document.getElementById('filterField').value;
            const value = document.getElementById('filterValue').value.trim();

            if (!layerId || !field || !value) {
                showWarning('Please fill in all filter criteria.', 'Filter Incomplete');
                return;
            }

            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;

            // Filter features
            const filteredFeatures = layerInfo.originalData.features.filter(feature => {
                const propValue = feature.properties[field];
                return propValue && propValue.toString().toLowerCase().includes(value.toLowerCase());
            });

            if (filteredFeatures.length === 0) {
                showAlert('No features match the filter criteria.', 'Filter Results');
                return;
            }

            // Create filtered GeoJSON
            const filteredData = {
                type: 'FeatureCollection',
                features: filteredFeatures
            };

            // Remove existing layer and add filtered layer
            map.removeLayer(layerInfo.layer);
            
            const filteredLayer = L.geoJSON(filteredData, {
                renderer: L.canvas(), // Force canvas rendering for leaflet-image export compatibility
                style: layerInfo.style,
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="text-sm">';
                        for (let key in feature.properties) {
                            popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                        popupContent += '</div>';
                        
                        // Use right-click popup binding (respects selection mode)
                        safeBindPopup(layer, popupContent);
                    }
                }
            }).addTo(map);

            // Update layer info
            layerInfo.layer = filteredLayer;
            layerInfo.data = filteredData;

            // Store filter info
            activeFilters.set(layerId, { field, value });

            // Zoom to filtered features
            map.fitBounds(filteredLayer.getBounds());

            // Close modal
            document.getElementById('filterModal').classList.add('hidden');
        }

        // Clear filter
        function clearFilter() {
            const layerId = document.getElementById('filterLayer').value;
            
            if (!layerId || !layers.has(layerId)) return;

            const layerInfo = layers.get(layerId);
            
            // Remove current layer
            map.removeLayer(layerInfo.layer);
            
            // Restore original data
            const originalLayer = L.geoJSON(layerInfo.originalData, {
                renderer: L.canvas(), // Force canvas rendering for leaflet-image export compatibility
                style: layerInfo.style,
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="text-sm">';
                        for (let key in feature.properties) {
                            popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                        popupContent += '</div>';
                        
                        // Use right-click popup binding (respects selection mode)
                        safeBindPopup(layer, popupContent);
                    }
                }
            }).addTo(map);

            // Update layer info
            layerInfo.layer = originalLayer;
            layerInfo.data = layerInfo.originalData;

            // Remove filter info
            activeFilters.delete(layerId);

            // Zoom to full layer
            map.fitBounds(originalLayer.getBounds());

            // Close modal
            document.getElementById('filterModal').classList.add('hidden');
        }

        // Setup print listeners
        // Setup print layout editor
        function setupPrintListeners() {
            // Canvas size change handler
            document.getElementById('canvasSize').addEventListener('change', handleCanvasSizeChange);
            document.getElementById('customWidth').addEventListener('input', handleCustomSizeChange);
            document.getElementById('customHeight').addEventListener('input', handleCustomSizeChange);
            
            // Export button
            document.getElementById('exportLayoutBtn').addEventListener('click', exportLayoutAsImage);
            
            // Initialize layout editor when modal opens
            document.getElementById('printBtn').addEventListener('click', initializePrintLayout);
        }

        // Initialize print layout editor
        function initializePrintLayout() {
            console.log('🖨️ Initializing print layout editor...');
            
            // Set initial canvas size
            handleCanvasSizeChange();
            
            // Initialize map frame interactions
            initializeMapFrameInteractions();
            
            // Create print map instance with delay to ensure proper setup
            setTimeout(() => {
                createPrintMapInstance();
            }, 100);
        }

        // Handle canvas size changes
        function handleCanvasSizeChange() {
            const canvasSizeSelect = document.getElementById('canvasSize');
            const customInputs = document.getElementById('customSizeInputs');
            const canvas = document.getElementById('printCanvas');
            const mapFrame = document.getElementById('mapFrame');
            
            let width, height;
            
            if (canvasSizeSelect.value === 'custom') {
                customInputs.classList.remove('hidden');
                width = parseInt(document.getElementById('customWidth').value) || 1980;
                height = parseInt(document.getElementById('customHeight').value) || 1080;
            } else {
                customInputs.classList.add('hidden');
                [width, height] = canvasSizeSelect.value.split('x').map(Number);
            }
            
            // Scale down for display (max 1200px wide)
            const maxDisplayWidth = 1200;
            const scale = Math.min(1, maxDisplayWidth / width);
            const displayWidth = width * scale;
            const displayHeight = height * scale;
            
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            canvas.setAttribute('data-actual-width', width);
            canvas.setAttribute('data-actual-height', height);
            canvas.setAttribute('data-scale', scale);
            
            // **NEW: Auto-fit map frame to canvas dimensions**
            if (mapFrame) {
                // Set map frame to exactly match canvas size (scaled for display)
                mapFrame.style.width = displayWidth + 'px';
                mapFrame.style.height = displayHeight + 'px';
                mapFrame.style.position = 'absolute';
                mapFrame.style.top = '0px';
                mapFrame.style.left = '0px';
                mapFrame.style.resize = 'none';
                mapFrame.style.pointerEvents = 'auto'; // Allow map interaction but disable dragging/resizing
                
                // Update print map size if it exists
                if (window.printMap) {
                    setTimeout(() => {
                        window.printMap.invalidateSize();
                    }, 100);
                }
                
                console.log(`🗺️ Map frame auto-fitted to canvas: ${displayWidth}×${displayHeight}px`);
            }
            
            console.log(`📐 Canvas size set to: ${width}×${height}px (display: ${displayWidth}×${displayHeight}px, scale: ${scale})`);
        }

        // Handle custom size input changes
        function handleCustomSizeChange() {
            if (document.getElementById('canvasSize').value === 'custom') {
                handleCanvasSizeChange();
            }
        }

        // Initialize map frame interactions (DISABLED - Frame is now locked to canvas size)
        function initializeMapFrameInteractions() {
            const mapFrame = document.getElementById('mapFrame');
            
            console.log('🔒 Map frame dragging and resizing disabled - frame auto-fits canvas size');
            
            // Remove any existing resize handles
            const existingHandles = mapFrame.querySelectorAll('.resize-handle');
            existingHandles.forEach(handle => handle.remove());
            
            // Ensure map frame is properly positioned and styled
            mapFrame.style.position = 'absolute';
            mapFrame.style.top = '0px';
            mapFrame.style.left = '0px';
            mapFrame.style.cursor = 'default';
            mapFrame.style.userSelect = 'none';
            
            // Allow map interactions but prevent frame manipulation
            mapFrame.addEventListener('mousedown', function(e) {
                // Only allow interaction with the print map container itself
                const printMapContainer = document.getElementById('printMapContainer');
                if (e.target === printMapContainer || printMapContainer.contains(e.target)) {
                    // Allow normal map interaction (panning, zooming, etc.)
                    return;
                }
                
                // Prevent any frame manipulation
                e.preventDefault();
                e.stopPropagation();
            });
            
            // Remove any drag/resize cursor styles
            mapFrame.style.resize = 'none';
            mapFrame.classList.remove('resizing', 'dragging', 'active');
            
            console.log('🗺️ Map frame locked to canvas - only map interaction allowed');
        }

        // Initialize map frame resize functionality (DISABLED - Frame auto-fits canvas)
        function initializeMapFrameResize() {
            console.log('🔒 Map frame resizing disabled - frame automatically matches canvas size');
            
            // Remove any existing resize handles to prevent manual resizing
            const mapFrame = document.getElementById('mapFrame');
            if (mapFrame) {
                const existingHandles = mapFrame.querySelectorAll('.resize-handle');
                existingHandles.forEach(handle => {
                    handle.remove();
                    console.log('🗑️ Removed resize handle:', handle.className);
                });
                
                // Ensure no resize functionality is applied
                mapFrame.style.resize = 'none';
                mapFrame.classList.remove('resizing', 'dragging');
                
                console.log('✅ All resize handles removed and resize functionality disabled');
            }
        }

        // Create print map instance
        function createPrintMapInstance() {
            const mapContainer = document.getElementById('printMapContainer');
            
            // Clear existing content
            mapContainer.innerHTML = '';
            
            // Create new Leaflet map instance
            window.printMap = L.map(mapContainer, {
                center: map.getCenter(),
                zoom: map.getZoom(),
                zoomControl: false,
                attributionControl: false,
                scrollWheelZoom: true, // Default scroll wheel zoom behavior
                dragging: true,
                doubleClickZoom: true
            });
            
            // Add the same base layer as main map
            L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Esri, Maxar, Earthstar Geographics',
                tileSize: 256,
                updateWhenIdle: true,
                updateWhenZooming: false,
                keepBuffer: 2
            }).addTo(window.printMap);
            
            console.log('🗺️ Creating print map with layers:', layers.size);
            
            // Add all visible layers from main map with exact same styling and order
            // Process layers in the correct order (reverse layerOrder for proper z-index)
            const layersToAdd = [];
            
            layerOrder.forEach((layerId) => {
                const layerInfo = layers.get(layerId);
                if (layerInfo && layerInfo.visible && layerInfo.data) {
                    layersToAdd.push({ layerId, layerInfo });
                }
            });
            
            // Add layers to print map
            layersToAdd.forEach(({ layerId, layerInfo }) => {
                try {
                    console.log(`📍 Adding layer to print map: "${layerInfo.name}" (ID: ${layerId})`);
                    console.log(`🎨 Layer classification:`, layerInfo.classification);
                    console.log(`🎨 Layer style:`, layerInfo.style);
                    
                    let styleFunction;
                    
                    // **NEW: Handle categorical symbology with proper dynamic styling**
                    if (layerInfo.classification && layerInfo.classification.field) {
                        // Use categorical styling - replicate the exact logic from main map
                        const { field, colorMap, strokeColor, strokeWidth } = layerInfo.classification;
                        
                        console.log(`🎨 Applying categorical styling for field "${field}" with color map:`, colorMap);
                        
                        styleFunction = function(feature) {
                            const value = feature.properties[field];
                            const fillColor = colorMap[value] || '#999999';
                            return {
                                color: strokeColor || '#ffffff',
                                fillColor: fillColor,
                                weight: strokeWidth || 2,
                                opacity: 1.0,
                                fillOpacity: 0.7
                            };
                        };
                        
                        console.log(`✅ Using categorical style function for "${layerInfo.name}"`);
                        
                    } else if (layerInfo.style && typeof layerInfo.style === 'object') {
                        // Use static styling for simple layers
                        styleFunction = function(feature) {
                            return layerInfo.style;
                        };
                        
                        console.log(`✅ Using static style for "${layerInfo.name}":`, layerInfo.style);
                        
                    } else {
                        // Fallback default styling
                        styleFunction = function(feature) {
                            return {
                                color: '#3388ff',
                                weight: 2,
                                opacity: 0.8,
                                fillColor: '#3388ff',
                                fillOpacity: 0.4
                            };
                        };
                        
                        console.log(`⚠️ Using fallback default style for "${layerInfo.name}"`);
                    }
                    
                    // Create the print layer with the appropriate style function
                    const printLayer = L.geoJSON(layerInfo.data, {
                        renderer: L.canvas(), // Force canvas rendering for leaflet-image export compatibility
                        style: styleFunction,
                        onEachFeature: function(feature, layer) {
                            // No popups in print map to avoid rendering issues
                        }
                    }).addTo(window.printMap);
                    
                    console.log(`✅ Successfully added "${layerInfo.name}" to print map with live styling`);
                    
                } catch (error) {
                    console.error(`❌ Failed to add layer "${layerInfo.name}" to print map:`, error);
                }
            });
            
            console.log(`🗺️ Print map instance created with ${layersToAdd.length} visible layers`);
            
            // Wait for map to fully render before allowing interactions
            setTimeout(() => {
                if (window.printMap) {
                    window.printMap.invalidateSize();
                    // Add Ctrl+right-click zoom box functionality to print map
                    initializeZoomBox(window.printMap);
                }
            }, 500);
        }

        // Export layout as image using leaflet-image
        async function exportLayoutAsImage() {
            console.log('📤 Starting layout export using leaflet-image...');
            
            const exportBtn = document.getElementById('exportLayoutBtn');
            const title = document.getElementById('layoutTitle').value || 'aera-map-export';
            
            // Show loading state
            exportBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span>Exporting...</span>';
            exportBtn.disabled = true;
            
            try {
                // Check if leaflet-image library is available
                if (typeof leafletImage === 'undefined') {
                    throw new Error('leaflet-image library is not loaded. Please include the leaflet-image script tag.');
                }
                
                // Determine which map to export
                let mapToExport = map; // Default to main map
                
                // **CRITICAL FIX: Backup original layer state before any export modifications**
                console.log('💾 Backing up original layer state...');
                const originalLayerBackup = new Map();
                
                // Create backup of all layer references BEFORE any modifications
                layers.forEach((layerInfo, layerId) => {
                    originalLayerBackup.set(layerId, {
                        originalLayer: layerInfo.layer,
                        originalVisible: layerInfo.visible,
                        onMainMap: map.hasLayer(layerInfo.layer)
                    });
                });
                
                console.log(`💾 Backed up ${originalLayerBackup.size} layers`);
                
                // Cleanup function to restore original state
                const restoreOriginalLayers = () => {
                    console.log('🔄 Restoring original layer state after export...');
                    
                    originalLayerBackup.forEach((backup, layerId) => {
                        const layerInfo = layers.get(layerId);
                        if (layerInfo && backup) {
                            // Restore original layer reference if it was changed
                            if (layerInfo.layer !== backup.originalLayer) {
                                console.log(`🔄 Restoring original layer for "${layerInfo.name}"`);
                                
                                // Remove any replacement layer from main map
                                if (map.hasLayer(layerInfo.layer) && layerInfo.layer !== backup.originalLayer) {
                                    map.removeLayer(layerInfo.layer);
                                }
                                
                                // Restore original layer reference
                                layerInfo.layer = backup.originalLayer;
                                
                                // Restore to main map if it was originally there and visible
                                if (backup.onMainMap && backup.originalVisible && !map.hasLayer(backup.originalLayer)) {
                                    map.addLayer(backup.originalLayer);
                                    console.log(`✅ Restored "${layerInfo.name}" to main map`);
                                }
                            }
                        }
                    });
                    
                    // Force main map refresh
                    map.invalidateSize();
                    console.log('✅ Original layer state fully restored');
                };
                
                // If print layout is open and print map exists, use that instead
                if (window.printMap && !document.getElementById('printModal').classList.contains('hidden')) {
                    console.log('🖨️ Using print layout map for export');
                    mapToExport = window.printMap;
                    
                    // Ensure print map is ready and properly sized
                    mapToExport.invalidateSize();
                    await new Promise(resolve => setTimeout(resolve, 500));
                } else {
                    console.log('🗺️ Using main map for export');
                }
                
                // **ENHANCED: Comprehensive layer validation and canvas rendering verification**
                console.log('🔍 Analyzing layers for export compatibility...');
                
                let totalLayers = 0;
                let vectorLayers = 0;
                let canvasLayers = 0;
                let svgLayers = 0;
                const layerDetails = [];
                
                // **NEW: Pre-export layer inspection and canvas verification**
                console.log('🔍 PRE-EXPORT LAYER INSPECTION:');
                let geoJsonLayers = [];
                
                mapToExport.eachLayer(layer => {
                    totalLayers++;
                    
                    // Enhanced GeoJSON layer detection
                    const isGeoJSON = layer instanceof L.GeoJSON;
                    const isVectorLayer = layer.feature || (layer._layers && !layer._url) || isGeoJSON;
                    
                    if (isVectorLayer || isGeoJSON) {
                        vectorLayers++;
                        
                        // Track GeoJSON layers specifically
                        if (isGeoJSON) {
                            geoJsonLayers.push(layer);
                        }
                        
                        // Check renderer type
                        const isCanvas = layer.options && layer.options.renderer instanceof L.Canvas;
                        const hasCanvasRenderer = layer._renderer && layer._renderer instanceof L.Canvas;
                        
                        if (isCanvas || hasCanvasRenderer) {
                            canvasLayers++;
                            console.log("Layer ready for export:", layer.options, "Canvas?", isCanvas || hasCanvasRenderer);
                        } else {
                            svgLayers++;
                            console.warn("⚠️ SVG layer detected (may not export properly):", layer);
                            
                            // **CRITICAL FIX: Convert SVG layers to canvas before export**
                            if (isGeoJSON && layer._renderer instanceof L.SVG) {
                                console.log('🔄 Converting SVG layer to canvas for export...');
                                try {
                                    // Force canvas renderer
                                    layer.options.renderer = L.canvas();
                                    // Remove from map and re-add with canvas renderer
                                    const layerData = layer.toGeoJSON();
                                    const layerStyle = layer.options.style;
                                    mapToExport.removeLayer(layer);
                                    
                                    const canvasLayer = L.geoJSON(layerData, {
                                        renderer: L.canvas(),
                                        style: layerStyle,
                                        onEachFeature: layer.options.onEachFeature
                                    }).addTo(mapToExport);
                                    
                                    console.log('✅ Successfully converted SVG layer to canvas');
                                    canvasLayers++;
                                    svgLayers--;
                                } catch (conversionError) {
                                    console.error('❌ Failed to convert SVG layer to canvas:', conversionError);
                                }
                            }
                        }
                        
                        // Collect layer details for debugging
                        layerDetails.push({
                            type: isCanvas || hasCanvasRenderer ? 'Canvas' : 'SVG',
                            isGeoJSON: isGeoJSON,
                            hasRenderer: !!layer._renderer,
                            rendererType: layer._renderer ? layer._renderer.constructor.name : 'None',
                            options: layer.options || {}
                        });
                    }
                });
                
                console.log(`📊 Layer Analysis Results:`);
                console.log(`  - Total layers: ${totalLayers}`);
                console.log(`  - Vector layers: ${vectorLayers}`);
                console.log(`  - GeoJSON layers: ${geoJsonLayers.length}`);
                console.log(`  - Canvas-rendered: ${canvasLayers}`);
                console.log(`  - SVG-rendered: ${svgLayers}`);
                console.log(`  - Layer details:`, layerDetails);
                
                if (svgLayers > 0) {
                    console.warn(`⚠️ Found ${svgLayers} SVG-rendered layers that may not appear in export!`);
                }
                
                // **ENHANCED: Force complete map rendering and wait for layer stabilization**
                console.log('🔄 Preparing map for export - ensuring all layers are properly rendered...');
                
                // Force map invalidation to trigger complete redraw
                mapToExport.invalidateSize();
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // **NEW: Enhanced layer rendering preparation**
                console.log('🎨 Forcing comprehensive layer rendering updates...');
                
                // Process each GeoJSON layer specifically
                for (const geoJsonLayer of geoJsonLayers) {
                    console.log('🔧 Processing GeoJSON layer for export readiness...');
                    
                    // Force layer redraw
                    if (geoJsonLayer.redraw && typeof geoJsonLayer.redraw === 'function') {
                        geoJsonLayer.redraw();
                    }
                    
                    // Force renderer update and ensure canvas readiness
                    if (geoJsonLayer._renderer) {
                        const renderer = geoJsonLayer._renderer;
                        
                        if (renderer._update) renderer._update();
                        if (renderer._redraw) renderer._redraw();
                        
                        // Ensure canvas renderer is ready and has context
                        if (renderer instanceof L.Canvas) {
                            if (renderer._container && renderer._ctx) {
                                console.log('✅ Canvas renderer ready and context available');
                                
                                // Force a complete canvas redraw
                                if (renderer._drawing && typeof renderer._drawing.clear === 'function') {
                                    renderer._drawing.clear();
                                }
                                
                                // Trigger redraw of all layer elements
                                geoJsonLayer.eachLayer(sublayer => {
                                    if (sublayer._path) {
                                        renderer._updatePath(sublayer);
                                    }
                                });
                            } else {
                                console.warn('⚠️ Canvas renderer missing container or context');
                            }
                        }
                    }
                    
                    // Ensure layer is properly attached and visible
                    if (!mapToExport.hasLayer(geoJsonLayer)) {
                        console.warn('⚠️ GeoJSON layer not on map, re-adding...');
                        mapToExport.addLayer(geoJsonLayer);
                    }
                }
                
                // Force redraw of ALL vector layers as fallback
                mapToExport.eachLayer(layer => {
                    if (layer.feature || (layer._layers && !layer._url)) {
                        // Force layer redraw
                        if (layer.redraw && typeof layer.redraw === 'function') {
                            layer.redraw();
                        }
                        
                        // Force renderer update
                        if (layer._renderer) {
                            if (layer._renderer._update) {
                                layer._renderer._update();
                            }
                            if (layer._renderer._redraw) {
                                layer._renderer._redraw();
                            }
                            // Ensure the renderer's canvas is ready
                            if (layer._renderer._container && layer._renderer._ctx) {
                                console.log('✅ Canvas renderer ready for layer');
                            }
                        }
                    }
                });
                
                // **ENHANCED: Extended wait time for complex layer rendering with multiple stages**
                console.log('⏳ Multi-stage rendering wait for all layers...');
                
                // Stage 1: Initial render completion
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Stage 2: Canvas stabilization 
                console.log('⏳ Canvas stabilization phase...');
                await new Promise(resolve => setTimeout(resolve, 400));
                
                // Stage 3: Final render verification
                console.log('⏳ Final render verification...');
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Final validation - check that all layers are still present and rendered
                let finalVectorCount = 0;
                let finalGeoJSONCount = 0;
                mapToExport.eachLayer(layer => {
                    if (layer.feature || (layer._layers && !layer._url)) {
                        finalVectorCount++;
                    }
                    if (layer instanceof L.GeoJSON) {
                        finalGeoJSONCount++;
                    }
                });
                
                console.log(`✅ Final pre-export validation:`);
                console.log(`  - Vector layers ready: ${finalVectorCount}`);
                console.log(`  - GeoJSON layers ready: ${finalGeoJSONCount}`);
                console.log(`  - Expected GeoJSON layers: ${geoJsonLayers.length}`);
                
                // **SPECIAL DEBUG: Check Aera layer specifically**
                console.log('🔍 AERA LAYER DEBUG - Checking Aera layer renderer configuration:');
                let aeraLayerFound = false;
                layers.forEach((layerInfo, layerId) => {
                    if (layerInfo.name === 'Aera') {
                        aeraLayerFound = true;
                        const aeraLayer = layerInfo.layer;
                        
                        console.log(`🎯 Found Aera layer (ID: ${layerId}):`, {
                            layerName: layerInfo.name,
                            hasRenderer: !!aeraLayer.options.renderer,
                            rendererType: aeraLayer.options.renderer ? aeraLayer.options.renderer.constructor.name : 'None',
                            isCanvas: aeraLayer.options.renderer instanceof L.Canvas,
                            actualRenderer: aeraLayer._renderer ? aeraLayer._renderer.constructor.name : 'None',
                            isActualCanvas: aeraLayer._renderer instanceof L.Canvas,
                            layerOptions: aeraLayer.options,
                            visible: layerInfo.visible,
                            onMap: mapToExport.hasLayer(aeraLayer)
                        });
                        
                        // **CRITICAL: Ensure Aera layer is properly prepared for export**
                        if (!mapToExport.hasLayer(aeraLayer)) {
                            console.warn('⚠️ Aera layer not on export map! Re-adding...');
                            mapToExport.addLayer(aeraLayer);
                        }
                        
                        // Force Aera layer canvas rendering if needed
                        if (!aeraLayer._renderer instanceof L.Canvas) {
                            console.log('🔄 Forcing Aera layer to use canvas renderer...');
                            try {
                                aeraLayer.options.renderer = L.canvas();
                                if (aeraLayer._renderer && aeraLayer._renderer instanceof L.SVG) {
                                    // Need to recreate layer with canvas renderer FOR EXPORT ONLY
                                    // **CRITICAL FIX: Do NOT modify original layer reference**
                                    const aeraData = aeraLayer.toGeoJSON();
                                    const aeraStyle = aeraLayer.options.style;
                                    mapToExport.removeLayer(aeraLayer);
                                    
                                    const canvasAeraLayer = L.geoJSON(aeraData, {
                                        renderer: L.canvas(),
                                        style: aeraStyle
                                    }).addTo(mapToExport);
                                    
                                    // **FIXED: DO NOT replace original layer reference**
                                    // layerInfo.layer = canvasAeraLayer; // REMOVED - this was causing the bug
                                    console.log('✅ Aera layer converted to canvas for export (original layer preserved)');
                                }
                            } catch (aeraConvertError) {
                                console.error('❌ Failed to convert Aera to canvas:', aeraConvertError);
                            }
                        }
                        
                        // Force check if Aera is on map
                        mapToExport.eachLayer(mapLayer => {
                            if (mapLayer === aeraLayer || (layerInfo.layer && mapLayer === layerInfo.layer)) {
                                console.log('✅ Aera layer IS present on map for export');
                            }
                        });
                    }
                });
                
                if (!aeraLayerFound) {
                    console.warn('⚠️ No Aera layer found in layers collection!');
                    
                    // **FALLBACK: Try to find Aera layer directly on map**
                    console.log('🔍 Searching for Aera layer directly on map...');
                    mapToExport.eachLayer(mapLayer => {
                        if (mapLayer instanceof L.GeoJSON) {
                            // Check if this could be the Aera layer by examining its properties
                            try {
                                const layerData = mapLayer.toGeoJSON();
                                if (layerData.features && layerData.features.length > 100) {
                                    console.log('🎯 Found potential Aera layer on map (large feature set)');
                                    console.log('Layer renderer:', mapLayer._renderer ? mapLayer._renderer.constructor.name : 'None');
                                }
                            } catch (error) {
                                // Ignore error
                            }
                        }
                    });
                }
                
                // **ENHANCED: Cross-reference layers collection with actual map layers**
                console.log('🔍 CROSS-REFERENCE: Checking layers collection vs map layers...');
                let layersOnMap = 0;
                let layersInCollection = 0;
                
                // **CRITICAL FIX: Clear export map and rebuild with all visible layers**
                console.log('🔄 REBUILDING export map to ensure all layers are present...');
                
                // First, remove all GeoJSON layers from export map
                const layersToRemove = [];
                mapToExport.eachLayer(layer => {
                    if (layer instanceof L.GeoJSON) {
                        layersToRemove.push(layer);
                    }
                });
                
                layersToRemove.forEach(layer => {
                    mapToExport.removeLayer(layer);
                    console.log('🗑️ Removed existing layer from export map');
                });
                
                // **Now re-add ALL visible layers from collection in correct order**
                console.log('➕ Re-adding all visible layers to export map...');
                let layersAdded = 0;
                
                // Count layers in collection that should be visible
                for (const [layerId, layerInfo] of layers.entries()) {
                    if (layerInfo.visible) {
                        layersInCollection++;
                        console.log(`📋 Adding visible layer "${layerInfo.name}" to export map...`);
                        
                        try {
                            // **CRITICAL FIX: Always create fresh canvas layers for export**
                            const layer = layerInfo.layer;
                            
                            if (layer instanceof L.GeoJSON) {
                                console.log(`  🔄 Creating fresh canvas version of "${layerInfo.name}" for export...`);
                                
                                // Get the layer's data and styling
                                const layerData = layer.toGeoJSON();
                                const layerStyle = layer.options.style || layer.options;
                                const onEachFeature = layer.options.onEachFeature;
                                
                                // **ALWAYS create a new canvas-rendered layer for export**
                                const canvasLayer = L.geoJSON(layerData, {
                                    renderer: L.canvas(),
                                    style: layerStyle,
                                    onEachFeature: onEachFeature,
                                    // Copy other important options
                                    weight: layer.options.weight,
                                    opacity: layer.options.opacity,
                                    color: layer.options.color,
                                    fillColor: layer.options.fillColor,
                                    fillOpacity: layer.options.fillOpacity,
                                    dashArray: layer.options.dashArray
                                });
                                
                                // **CRITICAL: Add the canvas layer to export map and wait for it to be ready**
                                mapToExport.addLayer(canvasLayer);
                                
                                // **FORCE IMMEDIATE RENDER AND WAIT**
                                await new Promise(resolve => {
                                    // Give the layer time to attach renderer and render
                                    setTimeout(() => {
                                        // Force redraw after attachment
                                        if (canvasLayer.redraw) {
                                            canvasLayer.redraw();
                                        }
                                        resolve();
                                    }, 100);
                                });
                                
                                console.log(`  ✅ Added fresh canvas version of "${layerInfo.name}"`);
                            } else {
                                // Non-GeoJSON layer, add as-is
                                mapToExport.addLayer(layer);
                                console.log(`  ✅ Added non-GeoJSON layer "${layerInfo.name}"`);
                            }
                            
                            layersAdded++;
                        } catch (error) {
                            console.error(`❌ Failed to add layer "${layerInfo.name}" to export map:`, error);
                        }
                    }
                }
                
                // Count actual GeoJSON layers on map after rebuild
                mapToExport.eachLayer(layer => {
                    if (layer instanceof L.GeoJSON) {
                        layersOnMap++;
                    }
                });
                
                console.log(`📊 Layer rebuild summary:`);
                console.log(`  - Visible layers in collection: ${layersInCollection}`);
                console.log(`  - Layers successfully added to export map: ${layersAdded}`);
                console.log(`  - GeoJSON layers now on export map: ${layersOnMap}`);
                
                if (layersInCollection !== layersOnMap) {
                    console.warn(`⚠️ MISMATCH: Collection has ${layersInCollection} visible layers but export map has ${layersOnMap} GeoJSON layers!`);
                } else {
                    console.log('✅ SUCCESS: All visible layers are now on the export map');
                }
                
                // **FINAL VALIDATION: Confirm all layers are canvas-rendered**
                console.log('✅ Final validation: Confirming all layers are canvas-rendered...');
                let finalSVGCount = 0;
                let finalCanvasCount = 0;
                
                mapToExport.eachLayer(layer => {
                    if (layer instanceof L.GeoJSON) {
                        // Check both options.renderer and actual _renderer
                        const hasCanvasOption = layer.options && layer.options.renderer instanceof L.Canvas;
                        const hasCanvasRenderer = layer._renderer && layer._renderer instanceof L.Canvas;
                        const hasSVGRenderer = layer._renderer && layer._renderer instanceof L.SVG;
                        
                        if (hasCanvasOption || hasCanvasRenderer) {
                            finalCanvasCount++;
                            console.log(`✅ Canvas layer confirmed: ${hasCanvasOption ? 'options' : 'renderer'} canvas`);
                        } else if (hasSVGRenderer) {
                            finalSVGCount++;
                            console.warn(`⚠️ STILL SVG: Layer still using SVG renderer!`, layer);
                        } else {
                            // Layer might be using default canvas renderer without explicit assignment
                            finalCanvasCount++;
                            console.log(`✅ Layer using default canvas renderer`);
                        }
                    }
                });
                
                console.log(`📊 Export readiness: ${finalCanvasCount} canvas, ${finalSVGCount} SVG ${finalSVGCount > 0 ? '⚠️' : '✅'}`);
                
                // **FORCE COMPLETE MAP STABILIZATION**
                console.log('🔄 Final map stabilization after rebuild...');
                mapToExport.invalidateSize();
                
                // **CRITICAL: Allow time for all layers to get their renderers attached**
                await new Promise(resolve => setTimeout(resolve, 1500)); // Extended wait for renderer attachment
                
                // **VERIFY RENDERER ATTACHMENT**
                console.log('🔍 POST-REBUILD: Verifying renderer attachment...');
                let layersWithRenderers = 0;
                let layersWithCanvasRenderers = 0;
                
                mapToExport.eachLayer(layer => {
                    if (layer instanceof L.GeoJSON) {
                        const hasRenderer = !!layer._renderer;
                        const hasCanvasRenderer = hasRenderer && layer._renderer instanceof L.Canvas;
                        
                        console.log(`📋 Layer renderer check: renderer=${hasRenderer}, canvas=${hasCanvasRenderer}`);
                        
                        if (hasRenderer) layersWithRenderers++;
                        if (hasCanvasRenderer) layersWithCanvasRenderers++;
                        
                        // Force final redraw
                        if (hasRenderer && layer.redraw) {
                            layer.redraw();
                        }
                    }
                });
                
                console.log(`📊 Renderer status: ${layersWithRenderers} with renderers, ${layersWithCanvasRenderers} with canvas renderers`);
                
                // Use leaflet-image to capture the map with all layers
                console.log('📸 Capturing complete map with leaflet-image...');
                
                // **SIMPLIFIED AND RELIABLE: Use leaflet-image directly as primary method**
                console.log('� Using leaflet-image for reliable all-layer export...');
                
                // **FINAL LAYER VERIFICATION: Ensure all visible layers are on the export map**
                console.log('🔍 Final pre-export layer verification...');
                
                let layersAddedToMap = 0;
                layers.forEach((layerInfo, layerId) => {
                    if (layerInfo.visible) {
                        if (!mapToExport.hasLayer(layerInfo.layer)) {
                            console.warn(`⚠️ Visible layer "${layerInfo.name}" missing from export map! Re-adding...`);
                            try {
                                mapToExport.addLayer(layerInfo.layer);
                                layersAddedToMap++;
                                console.log(`✅ Re-added layer "${layerInfo.name}" to export map`);
                            } catch (error) {
                                console.error(`❌ Failed to re-add layer "${layerInfo.name}":`, error);
                            }
                        }
                    }
                });
                
                if (layersAddedToMap > 0) {
                    console.log(`🔄 Re-added ${layersAddedToMap} missing layers, waiting for stabilization...`);
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                try {
                    // **ENHANCED: Force canvas rendering for all vector layers**
                console.log('🎨 Ensuring all layers use canvas rendering for export compatibility...');
                let canvasConversions = 0;
                
                layers.forEach((layerInfo, layerId) => {
                    if (layerInfo.visible && layerInfo.layer instanceof L.GeoJSON) {
                        // **CRITICAL: Check if layer is using SVG renderer - CONVERT ALL TO CANVAS**
                        const currentRenderer = layerInfo.layer._renderer;
                        const isCurrentlySVG = currentRenderer instanceof L.SVG;
                        
                        console.log(`  - Layer "${layerInfo.name}": ${isCurrentlySVG ? 'SVG (converting)' : 'Canvas (OK)'}`);
                        
                        // **CONVERT ALL SVG LAYERS TO CANVAS - NO EXCEPTIONS**
                        if (isCurrentlySVG) {
                            console.log(`� Converting SVG layer "${layerInfo.name}" to canvas...`);
                            try {
                                // Get layer data and style
                                const layerData = layerInfo.layer.toGeoJSON();
                                const layerStyle = layerInfo.layer.options.style;
                                const onEachFeature = layerInfo.layer.options.onEachFeature;
                                
                                // Remove SVG version
                                mapToExport.removeLayer(layerInfo.layer);
                                
                                // Create canvas version with same style
                                const canvasLayer = L.geoJSON(layerData, {
                                    renderer: L.canvas(),
                                    style: layerStyle,
                                    onEachFeature: onEachFeature
                                }).addTo(mapToExport);
                                
                                // **FIXED: DO NOT replace original layer reference**
                                // layerInfo.layer = canvasLayer; // REMOVED - this was causing the bug
                                canvasConversions++;
                                
                                console.log(`✅ Successfully converted "${layerInfo.name}" to canvas (original preserved)`);
                            } catch (conversionError) {
                                console.error(`❌ Failed to convert "${layerInfo.name}" to canvas:`, conversionError);
                            }
                        }
                    }
                });
                
                // **ADDITIONAL SAFETY CHECK: Scan map directly for any remaining SVG layers**
                console.log('🔍 Final scan: Checking for any remaining SVG layers on map...');
                let additionalConversions = 0;
                
                mapToExport.eachLayer(layer => {
                    if (layer instanceof L.GeoJSON && layer._renderer instanceof L.SVG) {
                        // Check if this layer is already in our layer collection
                        let layerInCollection = false;
                        layers.forEach((layerInfo, layerId) => {
                            if (layerInfo.layer === layer) {
                                layerInCollection = true;
                            }
                        });
                        
                        if (!layerInCollection) {
                            console.log('  ⚠️ Found SVG layer not in collection - converting...');
                            try {
                                const layerData = layer.toGeoJSON();
                                const layerStyle = layer.options.style;
                                const onEachFeature = layer.options.onEachFeature;
                                
                                mapToExport.removeLayer(layer);
                                
                                const canvasLayer = L.geoJSON(layerData, {
                                    renderer: L.canvas(),
                                    style: layerStyle,
                                    onEachFeature: onEachFeature
                                }).addTo(mapToExport);
                                
                                additionalConversions++;
                                console.log('  ✅ Additional layer converted to canvas');
                            } catch (error) {
                                console.error('  ❌ Failed to convert additional layer:', error);
                            }
                        }
                    }
                });
                
                const totalConversions = canvasConversions + additionalConversions;
                console.log(`🎯 Total SVG→Canvas conversions: ${totalConversions}`);
                
                if (totalConversions > 0) {
                    console.log(`⏳ Waiting for all ${totalConversions} canvas layers to fully render...`);
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Extended wait for canvas rendering
                }
                
                // **FINAL VALIDATION: Ensure ALL layers are canvas-rendered**
                console.log('✅ Final validation: Confirming all layers are canvas-rendered...');
                let finalSVGCount = 0;
                let finalCanvasCount = 0;
                
                mapToExport.eachLayer(layer => {
                    if (layer instanceof L.GeoJSON) {
                        // Check both options.renderer and actual _renderer
                        const hasCanvasOption = layer.options && layer.options.renderer instanceof L.Canvas;
                        const hasCanvasRenderer = layer._renderer && layer._renderer instanceof L.Canvas;
                        const hasSVGRenderer = layer._renderer && layer._renderer instanceof L.SVG;
                        
                        if (hasCanvasOption || hasCanvasRenderer) {
                            finalCanvasCount++;
                            console.log(`✅ Canvas layer confirmed: ${hasCanvasOption ? 'options' : 'renderer'} canvas`);
                        } else if (hasSVGRenderer) {
                            finalSVGCount++;
                            console.warn(`⚠️ STILL SVG: Layer still using SVG renderer!`, layer);
                        } else {
                            // Layer might be using default canvas renderer without explicit assignment
                            finalCanvasCount++;
                            console.log(`✅ Layer using default canvas renderer`);
                        }
                    }
                });
                
                console.log(`📊 Export readiness: ${finalCanvasCount} canvas, ${finalSVGCount} SVG ${finalSVGCount > 0 ? '⚠️' : '✅'}`);
                
                // **FORCE COMPLETE MAP INVALIDATION AND STABILIZATION**
                console.log('� Final map stabilization...');
                mapToExport.invalidateSize();
                await new Promise(resolve => setTimeout(resolve, 800));
                
                } catch (preparationError) {
                    console.error('❌ Layer preparation failed:', preparationError);
                    
                    // **CRITICAL: Restore original layer state on error**
                    restoreOriginalLayers();
                    
                    showError('Failed to prepare layers for export. Please try again.', 'Export Error');
                    exportBtn.innerHTML = '<i class="fas fa-download"></i> <span>Export Layout</span>';
                    exportBtn.disabled = false;
                    return;
                }
                
                // **CRITICAL DEBUG: Check what leaflet-image actually sees**
                console.log('🔍 PRE-CAPTURE DEBUG: Checking what leaflet-image will see...');
                
                // Force all layers to be visible and check their DOM elements
                let visibleLayerElements = 0;
                let canvasElements = 0;
                let svgElements = 0;
                
                mapToExport.eachLayer(layer => {
                    if (layer instanceof L.GeoJSON) {
                        console.log(`🔍 Layer inspection:`, {
                            hasRenderer: !!layer._renderer,
                            rendererType: layer._renderer ? layer._renderer.constructor.name : 'None',
                            hasContainer: !!(layer._renderer && layer._renderer._container),
                            containerVisible: layer._renderer && layer._renderer._container ? 
                                getComputedStyle(layer._renderer._container).display !== 'none' : false,
                            opacity: layer.options.opacity || 1,
                            zIndex: layer.options.zIndex || 0
                        });
                        
                        // Check DOM elements
                        if (layer._renderer && layer._renderer._container) {
                            const container = layer._renderer._container;
                            const rect = container.getBoundingClientRect();
                            console.log(`📏 Layer DOM:`, {
                                tagName: container.tagName,
                                visible: rect.width > 0 && rect.height > 0,
                                bounds: rect,
                                style: container.style.cssText,
                                computedStyle: {
                                    display: getComputedStyle(container).display,
                                    visibility: getComputedStyle(container).visibility,
                                    opacity: getComputedStyle(container).opacity
                                }
                            });
                            
                            if (container.tagName === 'CANVAS') {
                                canvasElements++;
                            } else if (container.tagName === 'SVG') {
                                svgElements++;
                            }
                            
                            visibleLayerElements++;
                        }
                    }
                });
                
                console.log(`📊 DOM Elements found: ${visibleLayerElements} total (${canvasElements} canvas, ${svgElements} svg)`);
                
                // **FORCE LAYER VISIBILITY**
                console.log('💪 Forcing layer visibility and z-index...');
                mapToExport.eachLayer(layer => {
                    if (layer instanceof L.GeoJSON && layer._renderer && layer._renderer._container) {
                        const container = layer._renderer._container;
                        
                        // Force visibility
                        container.style.display = 'block';
                        container.style.visibility = 'visible';
                        container.style.opacity = '1';
                        container.style.pointerEvents = 'auto';
                        
                        // Force high z-index
                        container.style.zIndex = '1000';
                        
                        // For canvas elements, ensure they have content
                        if (container.tagName === 'CANVAS') {
                            const ctx = container.getContext('2d');
                            if (ctx) {
                                const imageData = ctx.getImageData(0, 0, container.width, container.height);
                                let hasContent = false;
                                for (let i = 3; i < imageData.data.length; i += 4) {
                                    if (imageData.data[i] > 0) {
                                        hasContent = true;
                                        break;
                                    }
                                }
                                console.log(`🎨 Canvas content check: ${hasContent ? 'HAS CONTENT' : 'EMPTY'} (${container.width}x${container.height})`);
                            }
                        }
                    }
                });
                
                // **FORCE MAP REFRESH AND REDRAW**
                console.log('🔄 Final forced map refresh...');
                mapToExport.invalidateSize();
                
                // Force redraw all layers
                mapToExport.eachLayer(layer => {
                    if (layer instanceof L.GeoJSON && layer.redraw) {
                        layer.redraw();
                    }
                });
                
                // Extended wait to ensure everything is rendered
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // **PRIMARY EXPORT METHOD: Use leaflet-image directly**
                console.log('📸 Attempting leaflet-image capture...');
                leafletImage(mapToExport, function(err, canvas) {
                    if (err) {
                        console.error('❌ leaflet-image export failed:', err);
                        
                        // **CRITICAL: Restore original layer state on error**
                        restoreOriginalLayers();
                        
                        // **ENHANCED: Provide detailed error information**
                        console.log('🔍 Debugging export failure:');
                        console.log('  - Map instance:', mapToExport);
                        console.log('  - Map container:', mapToExport.getContainer());
                        console.log('  - Map size:', mapToExport.getSize());
                        console.log('  - Map bounds:', mapToExport.getBounds());
                        console.log('  - Map layers count:', mapToExport.eachLayer ? Object.keys(mapToExport._layers || {}).length : 'unknown');
                        console.log('  - Error details:', err);
                        
                        showError('Export failed. This might be due to layer rendering issues. Please try again or refresh the page.', 'Export Error');
                        exportBtn.innerHTML = '<i class="fas fa-download"></i> <span>Export Layout</span>';
                        exportBtn.disabled = false;
                        return;
                    }
                        
                        try {
                            // **ENHANCED: Verify canvas has content and provide detailed analysis**
                            if (!canvas || canvas.width === 0 || canvas.height === 0) {
                                throw new Error('Generated canvas is empty or invalid');
                            }
                            
                            console.log(`✅ Successfully captured map: ${canvas.width}x${canvas.height}px`);
                            
                            // **ENHANCED: Canvas content analysis**
                            const ctx = canvas.getContext('2d');
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const pixels = imageData.data;
                            let nonTransparentPixels = 0;
                            let totalPixels = canvas.width * canvas.height;
                            let coloredPixels = 0;
                            let uniqueColors = new Set();
                            
                            // Detailed pixel analysis
                            for (let i = 0; i < pixels.length; i += 4) {
                                const r = pixels[i];
                                const g = pixels[i + 1];
                                const b = pixels[i + 2];
                                const a = pixels[i + 3];
                                
                                if (a > 0) {
                                    nonTransparentPixels++;
                                    coloredPixels++;
                                    
                                    // Track unique colors to detect vector content
                                    const color = `${r},${g},${b}`;
                                    uniqueColors.add(color);
                                }
                            }
                            
                            const contentPercentage = ((nonTransparentPixels / totalPixels) * 100).toFixed(2);
                            console.log(`📊 DETAILED CANVAS ANALYSIS:`);
                            console.log(`  - Canvas dimensions: ${canvas.width}x${canvas.height}`);
                            console.log(`  - Total pixels: ${totalPixels.toLocaleString()}`);
                            console.log(`  - Non-transparent pixels: ${nonTransparentPixels.toLocaleString()}`);
                            console.log(`  - Content coverage: ${contentPercentage}%`);
                            console.log(`  - Unique colors detected: ${uniqueColors.size}`);
                            console.log(`  - Data URL size: ${Math.round(canvas.toDataURL().length / 1024)} KB`);
                            
                            // **CRITICAL: Check if we actually captured layers**
                            if (contentPercentage < 1) {
                                console.error('❌ EXPORT FAILED: Canvas appears empty or mostly transparent!');
                                console.log('🔍 Empty canvas diagnostics:');
                                console.log('  - Map bounds:', mapToExport.getBounds());
                                console.log('  - Map zoom:', mapToExport.getZoom());
                                console.log('  - Map center:', mapToExport.getCenter());
                                console.log('  - Map container:', mapToExport.getContainer());
                                
                                // Check layers on map one more time
                                let layersOnMap = 0;
                                let renderersFound = 0;
                                mapToExport.eachLayer(layer => {
                                    layersOnMap++;
                                    if (layer._renderer) renderersFound++;
                                    
                                    if (layer instanceof L.GeoJSON) {
                                        console.log('  - GeoJSON layer status:', {
                                            hasRenderer: !!layer._renderer,
                                            rendererType: layer._renderer ? layer._renderer.constructor.name : 'None',
                                            hasContainer: !!(layer._renderer && layer._renderer._container),
                                            containerTagName: layer._renderer && layer._renderer._container ? 
                                                layer._renderer._container.tagName : 'None'
                                        });
                                    }
                                });
                                
                                console.log(`  - Total layers on map: ${layersOnMap}`);
                                console.log(`  - Layers with renderers: ${renderersFound}`);
                                
                                // **CRITICAL: Restore original layer state on error**
                                restoreOriginalLayers();
                                
                                showError('Export failed: No content was captured. The vector layers may not be rendering properly.', 'Export Failed');
                                exportBtn.innerHTML = '<i class="fas fa-download"></i> <span>Export Layout</span>';
                                exportBtn.disabled = false;
                                return;
                            }
                            
                            if (contentPercentage < 5) {
                                console.warn(`⚠️ WARNING: Very low content coverage (${contentPercentage}%). Vector layers may be missing.`);
                            }
                            
                            // Create and download the image
                            canvas.toBlob(function(blob) {
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `aera-web-map-export-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                                URL.revokeObjectURL(url);
                                
                                console.log(`✅ EXPORT COMPLETED:`);
                                console.log(`  - File size: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);
                                console.log(`  - Content coverage: ${contentPercentage}%`);
                                console.log(`  - Unique colors: ${uniqueColors.size}`);
                                
                                // Show appropriate message based on content
                                if (contentPercentage > 10 && uniqueColors.size > 50) {
                                    showSuccess('Map exported successfully with all layers!', 'Export Complete');
                                } else if (contentPercentage > 5) {
                                    showSuccess('Map exported - please verify all layers are visible.', 'Export Complete');
                                } else {
                                    showWarning('Map exported but may be missing some layers. Please check the result.', 'Export Complete');
                                }
                                
                                // **CRITICAL: Restore original layer state after successful export**
                                restoreOriginalLayers();
                                
                                exportBtn.innerHTML = '<i class="fas fa-download"></i> <span>Export Layout</span>';
                                exportBtn.disabled = false;
                            }, 'image/png', 1.0);
                            
                        } catch (canvasError) {
                            console.error('❌ Canvas processing failed:', canvasError);
                            
                            // **CRITICAL: Restore original layer state on error**
                            restoreOriginalLayers();
                            
                            showError(`Export failed: ${canvasError.message}. Please try again or refresh the page.`, 'Export Error');
                            exportBtn.innerHTML = '<i class="fas fa-download"></i> <span>Export Layout</span>';
                            exportBtn.disabled = false;
                        }
                    });
                
            } catch (error) {
                console.error('❌ Export failed:', error);
                
                // **CRITICAL: Restore original layer state on error**
                restoreOriginalLayers();
                
                showError(`Export failed: ${error.message}. Please try again or refresh the page.`, 'Export Error');
                exportBtn.innerHTML = '<i class="fas fa-download"></i> <span>Export Layout</span>';
                exportBtn.disabled = false;
            }
        }
        
        // **SAFETY FUNCTION: Ensure all layers marked as visible are actually visible on the main map**
        function ensureAllLayersVisible() {
            console.log('🔍 Safety check: Ensuring all visible layers are on main map...');
            
            let layersRestored = 0;
            let layersAlreadyVisible = 0;
            
            layers.forEach((layerInfo, layerId) => {
                if (layerInfo.visible && layerInfo.layer) {
                    // Check if layer is supposed to be visible but not on map
                    if (!map.hasLayer(layerInfo.layer)) {
                        console.log(`🔄 Restoring missing visible layer: "${layerInfo.name}"`);
                        try {
                            map.addLayer(layerInfo.layer);
                            layersRestored++;
                        } catch (error) {
                            console.error(`❌ Failed to restore layer "${layerInfo.name}":`, error);
                        }
                    } else {
                        layersAlreadyVisible++;
                    }
                }
            });
            
            console.log(`✅ Layer visibility check complete: ${layersAlreadyVisible} already visible, ${layersRestored} restored`);
            
            if (layersRestored > 0) {
                // Force map refresh if layers were restored
                map.invalidateSize();
            }
        }
        
        // **DEBUG FUNCTION: Test export and layer restoration**
        window.debugExportLayerFix = function() {
            console.log('🧪 Testing export layer fix...');
            console.log('📋 Current layer state before test:');
            
            let visibleBefore = 0;
            let onMapBefore = 0;
            
            layers.forEach((layerInfo, layerId) => {
                const isVisible = layerInfo.visible;
                const isOnMap = map.hasLayer(layerInfo.layer);
                
                console.log(`  - ${layerInfo.name}: visible=${isVisible}, onMap=${isOnMap}`);
                
                if (isVisible) visibleBefore++;
                if (isOnMap) onMapBefore++;
            });
            
            console.log(`📊 Summary - Visible in list: ${visibleBefore}, On map: ${onMapBefore}`);
            
            // Run safety check
            ensureAllLayersVisible();
            
            console.log('✅ Test complete - layers should now be restored');
            return { visibleBefore, onMapBefore };
        };
        
        // Render basemap tiles to canvas
        async function renderBasemapToCanvas(ctx, mapInstance, width, height) {
            return new Promise((resolve) => {
                console.log('🌍 Rendering basemap tiles...');
                
                // Find the tile layer
                let tileLayer = null;
                mapInstance.eachLayer(layer => {
                    if (layer._url && layer._url.includes('arcgisonline')) {
                        tileLayer = layer;
                    }
                });
                
                if (!tileLayer) {
                    console.warn('No tile layer found');
                    resolve();
                    return;
                }
                
                const bounds = mapInstance.getBounds();
                const zoom = mapInstance.getZoom();
                const mapSize = mapInstance.getSize();
                
                // Get tile grid info
                const tileSize = tileLayer.getTileSize();
                const pixelBounds = mapInstance.getPixelBounds();
                const tileRange = mapInstance._tileLayerTileBounds;
                
                let tilesLoaded = 0;
                let totalTiles = 0;
                
                // Count tiles in view
                if (tileLayer._tiles) {
                    totalTiles = Object.keys(tileLayer._tiles).length;
                }
                
                if (totalTiles === 0) {
                    console.log('No tiles to render');
                    resolve();
                    return;
                }
                
                function tileComplete() {
                    tilesLoaded++;
                    if (tilesLoaded >= totalTiles) {
                        console.log(`✅ Rendered ${tilesLoaded} basemap tiles`);
                        resolve();
                    }
                }
                
                // Render each visible tile
                Object.values(tileLayer._tiles).forEach(tile => {
                    if (tile.el && tile.el.complete) {
                        try {
                            // Calculate tile position relative to map container
                            const tilePoint = mapInstance.latLngToContainerPoint(
                                mapInstance.unproject(mapInstance.project(bounds.getNorthWest()).subtract([tile.coords.x * tileSize.x, tile.coords.y * tileSize.y]))
                            );
                            
                            ctx.drawImage(
                                tile.el,
                                Math.round(tilePoint.x),
                                Math.round(tilePoint.y),
                                tileSize.x,
                                tileSize.y
                            );
                        } catch (error) {
                            console.warn('Tile render error:', error);
                        }
                    }
                    tileComplete();
                });
            });
        }
        
        // Render vector layers to canvas
        async function renderVectorLayersToCanvas(ctx, mapInstance, width, height) {
            return new Promise((resolve) => {
                console.log('🎨 Rendering vector layers...');
                
                let vectorLayersProcessed = 0;
                let totalVectorLayers = 0;
                
                // Count vector layers
                mapInstance.eachLayer(layer => {
                    if (layer.feature || (layer._layers && Object.keys(layer._layers).length > 0)) {
                        totalVectorLayers++;
                    }
                });
                
                if (totalVectorLayers === 0) {
                    console.log('No vector layers to render');
                    resolve();
                    return;
                }
                
                function vectorLayerComplete() {
                    vectorLayersProcessed++;
                    if (vectorLayersProcessed >= totalVectorLayers) {
                        console.log(`✅ Rendered ${vectorLayersProcessed} vector layers`);
                        resolve();
                    }
                }
                
                // Process each vector layer
                mapInstance.eachLayer(layer => {
                    if (layer.feature || (layer._layers && Object.keys(layer._layers).length > 0)) {
                        try {
                            renderVectorLayerFeatures(ctx, layer, mapInstance);
                        } catch (error) {
                            console.warn('Vector layer render error:', error);
                        }
                        vectorLayerComplete();
                    }
                });
            });
        }
        
        // Render features of a vector layer
        function renderVectorLayerFeatures(ctx, layer, mapInstance) {
            const features = [];
            
            // Collect all features
            if (layer._layers) {
                Object.values(layer._layers).forEach(sublayer => {
                    if (sublayer.feature) {
                        features.push({
                            feature: sublayer.feature,
                            options: sublayer.options || {}
                        });
                    }
                });
            } else if (layer.feature) {
                features.push({
                    feature: layer.feature,
                    options: layer.options || {}
                });
            }
            
            console.log(`🔍 Rendering ${features.length} features from vector layer`);
            
            // Draw each feature
            features.forEach(({ feature, options }) => {
                drawFeatureOnCanvas(feature, options, ctx, mapInstance);
            });
        }
        
        // Draw individual feature on canvas
        function drawFeatureOnCanvas(feature, options, ctx, mapInstance) {
            try {
                const geom = feature.geometry;
                
                // Set drawing style
                const fillColor = options.fillColor || options.color || '#3388ff';
                const strokeColor = options.color || '#3388ff';
                const fillOpacity = options.fillOpacity !== undefined ? options.fillOpacity : 0.2;
                const strokeOpacity = options.opacity !== undefined ? options.opacity : 1.0;
                const strokeWidth = options.weight || 3;
                
                // Configure context
                ctx.fillStyle = hexToRgba(fillColor, fillOpacity);
                ctx.strokeStyle = hexToRgba(strokeColor, strokeOpacity);
                ctx.lineWidth = strokeWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Draw based on geometry type
                if (geom.type === 'Polygon') {
                    drawPolygonOnCanvas(geom.coordinates, ctx, mapInstance);
                } else if (geom.type === 'MultiPolygon') {
                    geom.coordinates.forEach(polygon => {
                        drawPolygonOnCanvas(polygon, ctx, mapInstance);
                    });
                } else if (geom.type === 'LineString') {
                    drawLineStringOnCanvas(geom.coordinates, ctx, mapInstance);
                } else if (geom.type === 'MultiLineString') {
                    geom.coordinates.forEach(line => {
                        drawLineStringOnCanvas(line, ctx, mapInstance);
                    });
                } else if (geom.type === 'Point') {
                    drawPointOnCanvas(geom.coordinates, ctx, mapInstance, strokeWidth);
                } else if (geom.type === 'MultiPoint') {
                    geom.coordinates.forEach(point => {
                        drawPointOnCanvas(point, ctx, mapInstance, strokeWidth);
                    });
                }
                
            } catch (error) {
                console.warn('Feature drawing error:', error);
            }
        }
        
        // Convert hex color to rgba
        function hexToRgba(hex, alpha = 1) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (result) {
                const r = parseInt(result[1], 16);
                const g = parseInt(result[2], 16);
                const b = parseInt(result[3], 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
            return hex;
        }
        
        // Draw polygon on canvas
        function drawPolygonOnCanvas(coordinates, ctx, mapInstance) {
            coordinates.forEach((ring, ringIndex) => {
                ctx.beginPath();
                
                ring.forEach((coord, index) => {
                    const point = mapInstance.latLngToContainerPoint([coord[1], coord[0]]);
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                
                ctx.closePath();
                
                if (ringIndex === 0) {
                    // Fill and stroke the main polygon
                    ctx.fill();
                    ctx.stroke();
                } else {
                    // For holes, just stroke
                    ctx.stroke();
                }
            });
        }
        
        // Draw line string on canvas
        function drawLineStringOnCanvas(coordinates, ctx, mapInstance) {
            if (coordinates.length < 2) return;
            
            ctx.beginPath();
            
            coordinates.forEach((coord, index) => {
                const point = mapInstance.latLngToContainerPoint([coord[1], coord[0]]);
                if (index === 0) {
                    ctx.moveTo(point.x, point.y);
                } else {
                    ctx.lineTo(point.x, point.y);
                }
            });
            
            ctx.stroke();
        }
        
        // Draw point on canvas
        function drawPointOnCanvas(coordinates, ctx, mapInstance, radius = 5) {
            const point = mapInstance.latLngToContainerPoint([coordinates[1], coordinates[0]]);
            
            ctx.beginPath();
            ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }
        
        // Fallback html2canvas export method
        async function fallbackHtml2CanvasExport(canvas, mapFrame, title, exportBtn) {
            console.log('🔄 Using fallback html2canvas method...');
            
            const printMapContainer = document.getElementById('printMapContainer');
            
            // Step 1: Force multiple render cycles to ensure proper alignment
            for (let i = 0; i < 2; i++) {
                await new Promise(resolve => {
                    window.printMap.once('moveend', resolve);
                    window.printMap.setView(window.printMap.getCenter(), window.printMap.getZoom());
                });
                console.log(`🔄 Completed render cycle ${i+1}/2`);
            }
            
            // Step 2: Make sure map is at full size with complete redraw
            window.printMap.invalidateSize({animate: false, pan: false, debounceMoveend: true});
            
            // Step 3: Trigger redraw for all vector layers specifically to fix alignment
            let vectorLayerCount = 0;
            window.printMap.eachLayer(layer => {
                // Check if this is a vector layer (GeoJSON)
                if (layer.feature || (layer._layers && !layer._url)) {
                    vectorLayerCount++;
                    // Force redraw by toggling visibility
                    if (layer.bringToFront) {
                        layer.bringToFront();
                    }
                    // For multipolygons/complex features, need to redraw individual parts
                    if (layer._layers) {
                        Object.values(layer._layers).forEach(sublayer => {
                            if (sublayer.bringToFront) {
                                sublayer.bringToFront();
                            }
                        });
                    }
                }
            });
            console.log(`🔄 Triggered redraw for ${vectorLayerCount} vector layers`);
            
            // Step 4: Wait for map to finish loading completely with enhanced stability checks
            await new Promise(resolve => {
                // First wait for the basic map ready state
                window.printMap.whenReady(async () => {
                    console.log('📍 Map base ready, checking tile and vector completeness...');
                    
                    // Enhanced tile check function
                    const checkTiles = () => {
                        // Get current tiles and check their load state
                        const tiles = window.printMap._tiles || {};
                        const loadingTiles = Object.values(tiles).filter(t => t && !t.loaded && !t.complete);
                        
                        if (loadingTiles.length === 0) {
                            console.log('✅ All map tiles loaded successfully');
                            return true;
                        }
                        console.log(`⏳ Still waiting for ${loadingTiles.length} tiles to load`);
                        return false;
                    };
                    
                    // Wait for tiles in a loop with timeout safety
                    let attempts = 0;
                    while (!checkTiles() && attempts < 30) { // Increased max attempts
                        await new Promise(r => setTimeout(r, 200));
                        attempts++;
                    }
                    
                    // Force additional redraw specifically for vector layers
                    window.printMap.invalidateSize({animate: false, pan: false});
                    
                    // Additional check to ensure vector layers are properly positioned
                    window.printMap.eachLayer(layer => {
                        if (layer.feature || (layer._layers && !layer._url)) {
                            if (layer.bringToFront) {
                                layer.bringToFront();
                            }
                        }
                    });
                    
                    // Critical: Extended wait for DOM update and vector alignment
                    // Increased from 800ms to 2000ms as suggested
                    console.log('⏳ Extended wait for vector layer stabilization (2000ms)...');
                    await new Promise(r => setTimeout(r, 2000));
                    
                    console.log('🔄 Final map rendering stabilized after', attempts, 'attempts');
                    resolve();
                });
            });

            // Capture with enhanced settings
            const mapCanvas = await html2canvas(printMapContainer, {
                backgroundColor: null,
                scale: 2, // Higher scale for better quality
                useCORS: true,
                allowTaint: false,
                logging: true, // Enable logging for debugging
                foreignObjectRendering: true, // Try to use foreignObject for better SVG rendering
                removeContainer: false, // Keep the container for better element structure
                ignoreElements: (element) => {
                    // Only ignore attribution and zoom controls, keep all vector elements
                    return element.classList.contains('leaflet-control-attribution') ||
                           (element.classList.contains('leaflet-control') && 
                            !element.classList.contains('leaflet-overlay-pane'));
                },
                onclone: function(clonedDoc) {
                    const clonedContainer = clonedDoc.getElementById('printMapContainer');
                    if (clonedContainer) {
                        // Ensure the cloned container is fully visible
                        clonedContainer.style.visibility = 'visible';
                        clonedContainer.style.opacity = '1';
                        clonedContainer.style.transform = 'none';
                        clonedContainer.style.width = printMapContainer.offsetWidth + 'px';
                        clonedContainer.style.height = printMapContainer.offsetHeight + 'px';
                        
                        // Ensure all vector elements are visible in the clone
                        const vectorPanes = clonedContainer.querySelectorAll('.leaflet-overlay-pane, .leaflet-pane');
                        vectorPanes.forEach(pane => {
                            pane.style.visibility = 'visible';
                            pane.style.opacity = '1';
                            pane.style.display = 'block';
                            // Ensure vectors aren't clipped
                            pane.style.overflow = 'visible'; 
                        });
                    }
                }
            });
            
            // Create final export - similar to the main method
            const frameRect = mapFrame.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            const frameLeft = frameRect.left - canvasRect.left;
            const frameTop = frameRect.top - canvasRect.top;
            const frameWidth = frameRect.width;
            const frameHeight = frameRect.height;
            
            const actualCanvasWidth = parseInt(canvas.getAttribute('data-actual-width')) || 1980;
            const actualCanvasHeight = parseInt(canvas.getAttribute('data-actual-height')) || 1080;
            const displayWidth = canvasRect.width;
            const displayHeight = canvasRect.height;
            const scaleX = actualCanvasWidth / displayWidth;
            const scaleY = actualCanvasHeight / displayHeight;
            
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = actualCanvasWidth;
            exportCanvas.height = actualCanvasHeight;
            const ctx = exportCanvas.getContext('2d');
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, actualCanvasWidth, actualCanvasHeight);
            
            const titleValue = document.getElementById('layoutTitle').value;
            if (titleValue && titleValue.trim()) {
                ctx.fillStyle = '#1f2937';
                ctx.font = `bold ${Math.round(24 * scaleX)}px Inter, Arial, sans-serif`;
                ctx.textAlign = 'left';
                ctx.fillText(titleValue.trim(), Math.round(16 * scaleX), Math.round(40 * scaleY));
            }
            
            const scaledFrameLeft = Math.round(frameLeft * scaleX);
            const scaledFrameTop = Math.round(frameTop * scaleY);
            const scaledFrameWidth = Math.round(frameWidth * scaleX);
            const scaledFrameHeight = Math.round(frameHeight * scaleY);
            
            ctx.drawImage(mapCanvas, scaledFrameLeft, scaledFrameTop, scaledFrameWidth, scaledFrameHeight);
            
            const link = document.createElement('a');
            link.download = `${title.replace(/[^a-z0-9]/gi, '_')}.png`;
            link.href = exportCanvas.toDataURL('image/png', 1.0);
            link.click();
            
            console.log('✅ Fallback export completed');
            
            exportBtn.innerHTML = '<i class="fas fa-check"></i> <span>Exported!</span>';
            setTimeout(() => {
                exportBtn.innerHTML = '<i class="fas fa-download"></i> <span>Export Layout</span>';
                exportBtn.disabled = false;
            }, 2000);
        }
        
        // Helper function to wait for map to fully load
        function waitForMapToLoad(mapInstance) {
            return new Promise((resolve) => {
                let tilesLoading = 0;
                let tilesLoaded = 0;
                let vectorLayersReady = false;
                
                function checkComplete() {
                    if ((tilesLoading === 0 || tilesLoaded >= tilesLoading) && vectorLayersReady) {
                        console.log(`🔄 Map fully loaded: ${tilesLoaded}/${tilesLoading} tiles, vectors ready`);
                        // Increased from 500ms to 2000ms for better vector layer stabilization
                        setTimeout(resolve, 2000); // Extended delay for final rendering
                    }
                }
                
                // Track tile loading
                mapInstance.eachLayer(layer => {
                    if (layer._url) { // This is a tile layer
                        layer.on('loading', () => {
                            tilesLoading++;
                            console.log(`🔄 Tile loading started: ${tilesLoading} total tiles loading`);
                        });
                        layer.on('load', () => {
                            tilesLoaded++;
                            console.log(`✅ Tile loaded: ${tilesLoaded}/${tilesLoading}`);
                            checkComplete();
                        });
                        layer.on('tileerror', () => {
                            tilesLoaded++; // Count errors as complete
                            console.log(`⚠️ Tile error: ${tilesLoaded}/${tilesLoading}`);
                            checkComplete();
                        });
                    }
                });
                
                // Force redraw of vector layers to fix alignment issues
                let vectorLayerCount = 0;
                mapInstance.eachLayer(layer => {
                    if (layer.feature || (layer._layers && !layer._url)) {
                        vectorLayerCount++;
                        // Force redraw by bringing to front
                        if (layer.bringToFront) {
                            layer.bringToFront();
                        }
                        // For multipolygons/complex features
                        if (layer._layers) {
                            Object.values(layer._layers).forEach(sublayer => {
                                if (sublayer.bringToFront) {
                                    sublayer.bringToFront();
                                }
                            });
                        }
                    }
                });
                console.log(`🔄 Enhanced ${vectorLayerCount} vector layers for proper rendering`);
                
                // Extended wait for vector layers readiness
                setTimeout(() => {
                    console.log('🔄 Vector layers stabilization period completed');
                    vectorLayersReady = true;
                    checkComplete();
                }, 1000); // Increased from 200ms to 1000ms
                
                // Fallback timeout for reliability
                setTimeout(() => {
                    console.log('⏰ Map load timeout reached, resolving anyway');
                    resolve();
                }, 6000); // Increased from 4000ms to 6000ms
                
                // Initial check in case no tiles are loading
                setTimeout(checkComplete, 100);
            });
        }

        // Setup symbology listeners (kept for compatibility but not used)
        function setupSymbologyListeners() {
            // Old modal listeners - kept for backward compatibility but not used
            // The new symbology editor handles its own listeners
            return;
        }

        // Open symbology editor panel
        function openSymbologyEditor(layerId) {
            console.log('Opening symbology editor for layer:', layerId);
            const layerInfo = layers.get(layerId);
            if (!layerInfo) {
                console.error('Layer not found:', layerId);
                return;
            }

            console.log('Layer info:', layerInfo);

            // Create symbology editor panel
            const editorPanel = document.createElement('div');
            editorPanel.id = 'symbologyEditor';
            editorPanel.className = 'symbology-editor-draggable';
            editorPanel.style.top = '100px';
            editorPanel.style.right = '20px';
            
            // Get current layer opacity (stored as a value between 0 and 1)
            const currentOpacity = layerInfo.opacity || 1.0;
            const opacityPercent = Math.round(currentOpacity * 100);
            
            editorPanel.innerHTML = `
                <div class="symbology-editor-header" id="symbologyEditorHeader">
                    <div class="flex items-center justify-between">
                        <h3 class="text-lg font-semibold text-white flex items-center">
                            <i class="fas fa-palette mr-2 text-teal-400"></i>
                            Symbology Editor
                        </h3>
                        <button id="closeSymbologyEditor" class="text-gray-400 hover:text-white transition-colors">
                            <i class="fas fa-times text-lg"></i>
                        </button>
                    </div>
                    <div class="text-sm text-gray-300 mt-1">Layer: ${layerInfo.name}</div>
                </div>
                
                <div class="symbology-editor-content">
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Symbology Type</label>
                        <select id="symbologyType" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent">
                            <option value="single">Single Symbol</option>
                            <option value="categorical">Categorical</option>
                        </select>
                    </div>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Layer Opacity</label>
                        <input type="range" id="opacitySlider" class="opacity-slider" 
                               min="0" max="100" value="${opacityPercent}" step="1">
                        <div class="opacity-value" id="opacityValue">${opacityPercent}%</div>
                    </div>
                    
                    <div id="singleSymbolOptions" class="border-t border-gray-600 pt-4 mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Fill Color</label>
                        <div class="flex items-center space-x-3 mb-4">
                            <input type="color" id="singleFillColor" value="#888888" 
                                   class="w-16 h-10 bg-transparent border border-gray-600 rounded cursor-pointer">
                            <span class="text-sm text-gray-400">Choose color for all features</span>
                        </div>
                        
                        <label class="block text-sm font-medium text-gray-300 mb-2">Stroke Color</label>
                        <div class="flex items-center space-x-3 mb-4">
                            <input type="color" id="singleStrokeColor" value="#ffffff" 
                                   class="w-16 h-10 bg-transparent border border-gray-600 rounded cursor-pointer">
                            <span class="text-sm text-gray-400">Choose stroke color for all features</span>
                        </div>
                        
                        <label class="block text-sm font-medium text-gray-300 mb-2">Stroke Width (px)</label>
                        <div class="flex items-center space-x-3">
                            <input type="number" id="singleStrokeWidth" value="2" min="0" max="100" step="0.5" 
                                   class="w-20 px-2 py-1 bg-gray-700 border border-gray-600 rounded text-white text-sm">
                            <span class="text-sm text-gray-400">Stroke width in pixels</span>
                        </div>
                    </div>
                    
                    <div id="categoricalOptions" class="border-t border-gray-600 pt-4 mb-4 hidden">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Classification Field</label>
                        <select id="classificationField" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent mb-4">
                            <option value="">Select a field...</option>
                        </select>
                        
                        <label class="block text-sm font-medium text-gray-300 mb-2">Stroke Color</label>
                        <div class="flex items-center space-x-3 mb-4">
                            <input type="color" id="categoricalStrokeColor" value="#ffffff" 
                                   class="w-16 h-10 bg-transparent border border-gray-600 rounded cursor-pointer">
                            <span class="text-sm text-gray-400">Stroke color for all categories</span>
                        </div>
                        
                        <label class="block text-sm font-medium text-gray-300 mb-2">Stroke Width (px)</label>
                        <div class="flex items-center space-x-3">
                            <input type="number" id="categoricalStrokeWidth" value="2" min="0" max="100" step="0.5" 
                                   class="w-20 px-2 py-1 bg-gray-700 border border-gray-600 rounded text-white text-sm">
                            <span class="text-sm text-gray-400">Stroke width in pixels</span>
                        </div>
                    </div>
                    
                    <div id="legendPreview" class="mb-4 hidden">
                        <h4 class="text-sm font-medium text-gray-300 mb-2">Live Legend</h4>
                        <div id="legendItems" class="space-y-2 max-h-48 overflow-y-auto"></div>
                    </div>
                    
                    <div class="flex space-x-2 mt-4">
                        <button id="applySymbology" class="flex-1 bg-teal-600 hover:bg-teal-700 text-white px-4 py-2 rounded-lg transition-colors">
                            Apply
                        </button>
                        <button id="resetSymbology" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg transition-colors">
                            Reset
                        </button>
                    </div>
                </div>
            `;

            // Remove any existing symbology editor
            const existingEditor = document.getElementById('symbologyEditor');
            if (existingEditor) {
                console.log('Removing existing editor');
                existingEditor.remove();
            }

            console.log('Appending new editor panel to body');
            document.body.appendChild(editorPanel);
            
            // Make the panel draggable
            makeDraggable(editorPanel);
            
            // Close panel when clicking outside
            setupOutsideClickClose(editorPanel);

            // Populate field dropdown
            const fieldSelect = editorPanel.querySelector('#classificationField');
            const features = layerInfo.data.features;
            if (features && features.length > 0) {
                const properties = features[0].properties || {};
                Object.keys(properties).forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = key;
                    fieldSelect.appendChild(option);
                });
            }
            
            // Set initial single symbol color from current layer style
            const singleFillColorInput = editorPanel.querySelector('#singleFillColor');
            if (singleFillColorInput && layerInfo.style && layerInfo.style.fillColor) {
                singleFillColorInput.value = layerInfo.style.fillColor;
            }
            
            // Set initial stroke color from current layer style
            const singleStrokeColorInput = editorPanel.querySelector('#singleStrokeColor');
            if (singleStrokeColorInput && layerInfo.style && layerInfo.style.color) {
                singleStrokeColorInput.value = layerInfo.style.color;
            }
            
            // Set initial stroke width from current layer style
            const singleStrokeWidthInput = editorPanel.querySelector('#singleStrokeWidth');
            if (singleStrokeWidthInput && layerInfo.style && layerInfo.style.weight) {
                singleStrokeWidthInput.value = layerInfo.style.weight;
            }
            
            // Set initial categorical stroke values
            const categoricalStrokeColorInput = editorPanel.querySelector('#categoricalStrokeColor');
            if (categoricalStrokeColorInput && layerInfo.style && layerInfo.style.color) {
                categoricalStrokeColorInput.value = layerInfo.style.color;
            }
            
            const categoricalStrokeWidthInput = editorPanel.querySelector('#categoricalStrokeWidth');
            if (categoricalStrokeWidthInput && layerInfo.style && layerInfo.style.weight) {
                categoricalStrokeWidthInput.value = layerInfo.style.weight;
            }
            
            // Set initial categorical field selection if there's existing classification
            if (layerInfo.classification && layerInfo.classification.field) {
                const fieldSelect = editorPanel.querySelector('#classificationField');
                if (fieldSelect) {
                    fieldSelect.value = layerInfo.classification.field;
                    console.log('Restored categorical field selection:', layerInfo.classification.field);
                }
                
                // Set symbology type to categorical if we have classification
                const symbologyTypeSelect = editorPanel.querySelector('#symbologyType');
                if (symbologyTypeSelect) {
                    symbologyTypeSelect.value = 'categorical';
                    
                    // Show categorical options and hide single symbol options
                    const singleSymbolOptions = editorPanel.querySelector('#singleSymbolOptions');
                    const categoricalOptions = editorPanel.querySelector('#categoricalOptions');
                    if (singleSymbolOptions && categoricalOptions) {
                        singleSymbolOptions.classList.add('hidden');
                        categoricalOptions.classList.remove('hidden');
                    }
                }
            }

            // Store current layer for the editor
            editorPanel.dataset.layerId = layerId;

            // Setup event listeners
            setupSymbologyEditorListeners(editorPanel);
        }

        // Setup symbology editor event listeners
        function setupSymbologyEditorListeners(editorPanel) {
            const layerId = editorPanel.dataset.layerId;
            const layerInfo = layers.get(layerId);
            
            // Get UI elements
            const symbologyTypeSelect = editorPanel.querySelector('#symbologyType');
            const singleSymbolOptions = editorPanel.querySelector('#singleSymbolOptions');
            const categoricalOptions = editorPanel.querySelector('#categoricalOptions');
            const singleFillColor = editorPanel.querySelector('#singleFillColor');
            const classificationField = editorPanel.querySelector('#classificationField');
            const legendPreview = editorPanel.querySelector('#legendPreview');
            const applyBtn = editorPanel.querySelector('#applySymbology');
            
            // Opacity slider handling
            const opacitySlider = editorPanel.querySelector('#opacitySlider');
            const opacityValue = editorPanel.querySelector('#opacityValue');
            
            if (opacitySlider && opacityValue) {
                opacitySlider.addEventListener('input', function() {
                    const opacityPercent = parseInt(this.value);
                    const opacityDecimal = opacityPercent / 100;
                    
                    // Update display
                    opacityValue.textContent = opacityPercent + '%';
                    
                    // Update layer opacity immediately
                    updateLayerOpacity(layerId, opacityDecimal);
                });
            }
            
            // Symbology type change handler
            symbologyTypeSelect.addEventListener('change', function() {
                const selectedType = this.value;
                
                if (selectedType === 'single') {
                    // Show single symbol options, hide categorical options
                    singleSymbolOptions.classList.remove('hidden');
                    categoricalOptions.classList.add('hidden');
                    legendPreview.classList.add('hidden');
                } else if (selectedType === 'categorical') {
                    // Show categorical options, hide single symbol options
                    singleSymbolOptions.classList.add('hidden');
                    categoricalOptions.classList.remove('hidden');
                    
                    // Enable Apply button for categorical (field selection will handle further logic)
                    applyBtn.disabled = false;
                }
            });
            
            // Single fill color change handler
            singleFillColor.addEventListener('input', function() {
                const selectedColor = this.value;
                console.log(`Single symbol color changed to: ${selectedColor}`);
                
                // Apply single symbol with current stroke settings
                const strokeColor = editorPanel.querySelector('#singleStrokeColor').value;
                const strokeWidth = editorPanel.querySelector('#singleStrokeWidth').value;
                applySingleSymbolWithStroke(layerId, selectedColor, strokeColor, strokeWidth);
            });
            
            // Single stroke color change handler
            const singleStrokeColor = editorPanel.querySelector('#singleStrokeColor');
            singleStrokeColor.addEventListener('input', function() {
                const strokeColor = this.value;
                console.log(`Single symbol stroke color changed to: ${strokeColor}`);
                
                // Apply single symbol with current fill and stroke settings
                const fillColor = singleFillColor.value;
                const strokeWidth = editorPanel.querySelector('#singleStrokeWidth').value;
                applySingleSymbolWithStroke(layerId, fillColor, strokeColor, strokeWidth);
            });
            
            // Single stroke width change handler
            const singleStrokeWidth = editorPanel.querySelector('#singleStrokeWidth');
            singleStrokeWidth.addEventListener('input', function() {
                const strokeWidth = this.value;
                console.log(`Single symbol stroke width changed to: ${strokeWidth}px`);
                
                // Apply single symbol with current fill and stroke settings
                const fillColor = singleFillColor.value;
                const strokeColor = singleStrokeColor.value;
                applySingleSymbolWithStroke(layerId, fillColor, strokeColor, strokeWidth);
            });
            
            // Categorical stroke color change handler
            const categoricalStrokeColor = editorPanel.querySelector('#categoricalStrokeColor');
            categoricalStrokeColor.addEventListener('input', function() {
                const field = classificationField.value;
                if (field) {
                    console.log(`Categorical stroke color changed to: ${this.value}`);
                    applyCategoricalSymbologyWithStroke(layerId, field);
                }
            });
            
            // Categorical stroke width change handler
            const categoricalStrokeWidth = editorPanel.querySelector('#categoricalStrokeWidth');
            categoricalStrokeWidth.addEventListener('input', function() {
                const field = classificationField.value;
                if (field) {
                    console.log(`Categorical stroke width changed to: ${this.value}px`);
                    applyCategoricalSymbologyWithStroke(layerId, field);
                }
            });
            
            // Close button
            editorPanel.querySelector('#closeSymbologyEditor').addEventListener('click', () => {
                editorPanel.remove();
            });

            // Field selection change for categorical symbology
            classificationField.addEventListener('change', function() {
                const field = this.value;
                
                if (field) {
                    console.log(`Classification field selected: ${field}`);
                    generateLegendPreview(layerId, field, editorPanel);
                    legendPreview.classList.remove('hidden');
                    
                    // Apply categorical symbology - check if we have existing colors
                    const layerInfo = layers.get(layerId);
                    if (layerInfo.classification && layerInfo.classification.field === field && layerInfo.classification.colorMap) {
                        // Use existing custom colors
                        console.log('Using existing custom colors for field:', field);
                        applyCategoricalSymbologyWithCustomColors(layerId, field, layerInfo.classification.colorMap);
                    } else {
                        // Apply with auto-generated colors
                        console.log('Applying with auto-generated colors for field:', field);
                        applyCategoricalSymbologyWithStroke(layerId, field);
                    }
                } else {
                    legendPreview.classList.add('hidden');
                }
            });
            
            // Apply button
            applyBtn.addEventListener('click', function() {
                const symbologyType = symbologyTypeSelect.value;
                
                if (symbologyType === 'single') {
                    const fillColor = singleFillColor.value;
                    const strokeColor = editorPanel.querySelector('#singleStrokeColor').value;
                    const strokeWidth = editorPanel.querySelector('#singleStrokeWidth').value;
                    applySingleSymbolWithStroke(layerId, fillColor, strokeColor, strokeWidth);
                } else if (symbologyType === 'categorical') {
                    const field = classificationField.value;
                    if (field) {
                        // Check if we have existing custom colors or need to collect from color pickers
                        const layerInfo = layers.get(layerId);
                        let customColorMap = null;
                        
                        // Try to get colors from the legend preview color pickers
                        const colorPickers = editorPanel.querySelectorAll('#legendItems .color-picker');
                        if (colorPickers.length > 0) {
                            customColorMap = {};
                            colorPickers.forEach(picker => {
                                const value = picker.dataset.value;
                                const color = picker.value;
                                customColorMap[value] = color;
                            });
                            console.log('Collected custom colors from color pickers:', customColorMap);
                            applyCategoricalSymbologyWithCustomColors(layerId, field, customColorMap);
                        } else if (layerInfo.classification && layerInfo.classification.field === field && layerInfo.classification.colorMap) {
                            // Use existing colors
                            console.log('Using existing custom colors from layer info');
                            applyCategoricalSymbologyWithCustomColors(layerId, field, layerInfo.classification.colorMap);
                        } else {
                            // Fall back to auto-generated colors
                            console.log('Using auto-generated colors');
                            applyCategoricalSymbologyWithStroke(layerId, field);
                        }
                    }
                }
                
                // Close the editor after applying
                editorPanel.remove();
            });
            
            // Reset button
            editorPanel.querySelector('#resetSymbology').addEventListener('click', function() {
                resetLayerSymbology(layerId);
                editorPanel.remove();
            });
            
            // Initialize legend preview if there's existing categorical classification
            if (layerInfo.classification && layerInfo.classification.field) {
                const field = layerInfo.classification.field;
                console.log('Initializing legend preview for existing classification field:', field);
                const legendPreview = editorPanel.querySelector('#legendPreview');
                generateLegendPreview(layerId, field, editorPanel);
                legendPreview.classList.remove('hidden');
            }
        }

        // Apply single symbol styling to layer
        function applySingleSymbol(layerId, color) {
            console.log(`Applying single symbol with color ${color} to layer ${layerId}`);
            
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;
            
            // Update the layer style
            const newStyle = {
                color: color,
                fillColor: color,
                weight: 2,
                opacity: 1.0,
                fillOpacity: 0.7
            };
            
            // Apply style to the layer
            layerInfo.layer.setStyle(newStyle);
            layerInfo.style = newStyle;
            
            // Update legend
            updateLegend();
            
            console.log(`Single symbol applied successfully`);
        }

        // Apply single symbol styling with stroke controls
        function applySingleSymbolWithStroke(layerId, fillColor, strokeColor, strokeWidth) {
            console.log(`Applying single symbol with fill ${fillColor}, stroke ${strokeColor}, width ${strokeWidth} to layer ${layerId}`);
            
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;
            
            // Update the layer style with stroke controls
            const newStyle = {
                color: strokeColor,
                fillColor: fillColor,
                weight: parseFloat(strokeWidth),
                opacity: 1.0,
                fillOpacity: 0.7
            };
            
            // Apply style to the layer
            layerInfo.layer.setStyle(newStyle);
            layerInfo.style = newStyle;
            
            // Save symbology settings to Supabase
            const symbologyData = {
                symbology_type: 'single',
                fill_color: fillColor,
                stroke_color: strokeColor,
                stroke_weight: parseFloat(strokeWidth),
                fill_opacity: 0.7,
                stroke_opacity: 1.0
            };
            
            saveSymbologyToSupabase(layerId, symbologyData);
            
            // Update legend
            updateLegend();
            
            console.log(`Single symbol with stroke applied successfully`);
        }

        // Apply categorical symbology to layer
        function applyCategoricalSymbology(layerId, field) {
            console.log(`Applying categorical symbology for field ${field} to layer ${layerId}`);
            
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;
            
            const features = layerInfo.data.features;
            if (!features || features.length === 0) return;
            
            // Get unique values and generate colors
            const uniqueValues = [...new Set(features.map(f => f.properties[field]).filter(v => v !== null && v !== undefined))];
            const colorMap = generateColorMap(uniqueValues);
            
            // Apply the styling
            layerInfo.layer.setStyle(function(feature) {
                const value = feature.properties[field];
                const color = colorMap[value] || '#999999';
                return {
                    color: color,
                    fillColor: color,
                    weight: 2,
                    opacity: 1.0,
                    fillOpacity: 0.7
                };
            });
            
            // Store the classification info
            layerInfo.classification = {
                field: field,
                colorMap: colorMap
            };
            
            // Update legend
            updateLegend();
            
            console.log(`Categorical symbology applied successfully`);
        }

        // Apply categorical symbology with stroke controls
        function applyCategoricalSymbologyWithStroke(layerId, field) {
            console.log(`Applying categorical symbology with stroke controls for field ${field} to layer ${layerId}`);
            
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;
            
            const features = layerInfo.data.features;
            if (!features || features.length === 0) return;
            
            // Get stroke settings from the editor panel
            const editorPanel = document.getElementById('symbologyEditor');
            const strokeColor = editorPanel ? editorPanel.querySelector('#categoricalStrokeColor').value : '#ffffff';
            const strokeWidth = editorPanel ? parseFloat(editorPanel.querySelector('#categoricalStrokeWidth').value) : 2;
            
            // Get unique values and generate colors
            const uniqueValues = [...new Set(features.map(f => f.properties[field]).filter(v => v !== null && v !== undefined))];
            const colorMap = generateColorMap(uniqueValues);
            
            // Apply the styling with stroke controls
            layerInfo.layer.setStyle(function(feature) {
                const value = feature.properties[field];
                const fillColor = colorMap[value] || '#999999';
                return {
                    color: strokeColor,
                    fillColor: fillColor,
                    weight: strokeWidth,
                    opacity: 1.0,
                    fillOpacity: 0.7
                };
            });
            
            // Store the classification info with stroke settings
            layerInfo.classification = {
                field: field,
                colorMap: colorMap,
                strokeColor: strokeColor,
                strokeWidth: strokeWidth
            };
            
            // Save symbology settings to Supabase
            const categories = uniqueValues.map(value => ({
                value: value,
                color: colorMap[value]
            }));
            
            const symbologyData = {
                symbology_type: 'categorical',
                stroke_color: strokeColor,
                stroke_weight: strokeWidth,
                fill_opacity: 0.7,
                stroke_opacity: 1.0,
                classification_field: field,
                categories: categories
            };
            
            saveSymbologyToSupabase(layerId, symbologyData);
            
            // Update legend
            updateLegend();
            
            console.log(`Categorical symbology with stroke applied successfully`);
        }

        // Apply categorical symbology with custom user-selected colors
        function applyCategoricalSymbologyWithCustomColors(layerId, field, customColorMap) {
            console.log(`Applying categorical symbology with custom colors for field ${field} to layer ${layerId}`, customColorMap);
            
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;
            
            const features = layerInfo.data.features;
            if (!features || features.length === 0) return;
            
            // Get stroke settings from the editor panel
            const editorPanel = document.getElementById('symbologyEditor');
            const strokeColor = editorPanel ? editorPanel.querySelector('#categoricalStrokeColor').value : '#ffffff';
            const strokeWidth = editorPanel ? parseFloat(editorPanel.querySelector('#categoricalStrokeWidth').value) : 2;
            
            // Apply the styling with custom colors
            layerInfo.layer.setStyle(function(feature) {
                const value = feature.properties[field];
                const fillColor = customColorMap[value] || '#999999';
                return {
                    color: strokeColor,
                    fillColor: fillColor,
                    weight: strokeWidth,
                    opacity: 1.0,
                    fillOpacity: 0.7
                };
            });
            
            // Store the classification info with custom colors
            layerInfo.classification = {
                field: field,
                colorMap: customColorMap,
                strokeColor: strokeColor,
                strokeWidth: strokeWidth
            };
            
            // Save symbology settings to Supabase with custom colors
            const categories = Object.keys(customColorMap).map(value => ({
                value: value,
                color: customColorMap[value]
            }));
            
            const symbologyData = {
                symbology_type: 'categorical',
                stroke_color: strokeColor,
                stroke_weight: strokeWidth,
                fill_opacity: 0.7,
                stroke_opacity: 1.0,
                classification_field: field,
                categories: categories
            };
            
            saveSymbologyToSupabase(layerId, symbologyData);
            
            // Update legend
            updateLegend();
            
            console.log(`Categorical symbology with custom colors applied and saved successfully`);
        }

        // Generate legend preview for categorical symbology
        function generateLegendPreview(layerId, field, editorPanel) {
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;
            
            const features = layerInfo.data.features;
            if (!features || features.length === 0) return;
            
            // Get unique values
            const uniqueValues = [...new Set(features.map(f => f.properties[field]).filter(v => v !== null && v !== undefined))];
            
            if (uniqueValues.length === 0) return;
            
            // Check if we have existing colors from previous classification or use generated colors
            let colorMap;
            if (layerInfo.classification && layerInfo.classification.field === field && layerInfo.classification.colorMap) {
                // Use existing color map if available
                colorMap = layerInfo.classification.colorMap;
            } else {
                // Generate new colors
                colorMap = generateColorMap(uniqueValues);
            }
            
            // Update legend preview
            const legendItems = editorPanel.querySelector('#legendItems');
            legendItems.innerHTML = '';
            
            uniqueValues.forEach(value => {
                const color = colorMap[value] || '#999999';
                const legendItem = document.createElement('div');
                legendItem.className = 'flex items-center space-x-3 text-sm';
                legendItem.innerHTML = `
                    <div class="w-4 h-4 rounded border border-gray-500" style="background-color: ${color}"></div>
                    <span class="text-gray-300 flex-1">${value}</span>
                    <input type="color" value="${color}" class="w-6 h-6 rounded border-0 cursor-pointer color-picker" data-value="${value}">
                `;
                legendItems.appendChild(legendItem);
            });
            
            // Add color picker listeners that update both map and save to database
            legendItems.querySelectorAll('.color-picker').forEach(picker => {
                picker.addEventListener('change', function() {
                    const value = this.dataset.value;
                    const newColor = this.value;
                    
                    console.log(`Manual color change for category "${value}": ${newColor}`);
                    
                    // Update the color map
                    colorMap[value] = newColor;
                    
                    // Update the visual preview
                    const colorDiv = this.parentElement.querySelector('div');
                    colorDiv.style.backgroundColor = newColor;
                    
                    // Apply the updated categorical symbology to the map immediately
                    applyCategoricalSymbologyWithCustomColors(layerId, field, colorMap);
                });
            });
        }

        // Generate color map for unique values
        function generateColorMap(uniqueValues) {
            const colors = [
                '#e53e3e', '#dd6b20', '#d69e2e', '#38a169', '#319795', 
                '#3182ce', '#553c9a', '#b83280', '#805ad5', '#ed8936'
            ];
            
            const colorMap = {};
            uniqueValues.forEach((value, index) => {
                colorMap[value] = colors[index % colors.length];
            });
            
            return colorMap;
        }

        // Reset layer symbology to default
        function resetLayerSymbology(layerId) {
            console.log(`Resetting symbology for layer ${layerId}`);
            
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;
            
            // Reset to default style
            let defaultStyle = {
                color: '#ffffff',
                weight: 2,
                opacity: 1.0,
                fillColor: '#888888',
                fillOpacity: 0.7
            };

            // No special defaults - use neutral styling for all layers
            
            layerInfo.layer.setStyle(defaultStyle);
            layerInfo.style = defaultStyle;
            
            // Clear classification info
            if (layerInfo.classification) {
                delete layerInfo.classification;
            }
            
            // Save default symbology to Supabase
            const symbologyData = {
                symbology_type: 'single',
                fill_color: defaultStyle.fillColor,
                stroke_color: defaultStyle.color,
                stroke_weight: defaultStyle.weight,
                fill_opacity: defaultStyle.fillOpacity,
                stroke_opacity: defaultStyle.opacity
            };
            
            saveSymbologyToSupabase(layerId, symbologyData);
            
            // Update legend
            updateLegend();
            
            console.log(`Layer symbology reset to default`);
        }

        // Make panel draggable
        function makeDraggable(element) {
            const header = element.querySelector('#symbologyEditorHeader');
            if (!header) return;
            
            let isDragging = false;
            let startX, startY, startLeft, startTop;

            header.addEventListener('mousedown', function(e) {
                // Don't drag if clicking on close button
                if (e.target.closest('#closeSymbologyEditor')) {
                    return;
                }
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startLeft = element.offsetLeft;
                startTop = element.offsetTop;
                
                // Add dragging class for visual feedback
                header.style.cursor = 'grabbing';
                element.style.userSelect = 'none';
                
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;
                
                // Keep panel within viewport bounds
                const rect = element.getBoundingClientRect();
                const maxLeft = window.innerWidth - rect.width;
                const maxTop = window.innerHeight - rect.height;
                
                newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                newTop = Math.max(0, Math.min(newTop, maxTop));
                
                element.style.left = newLeft + 'px';
                element.style.top = newTop + 'px';
                element.style.right = 'auto';
            });

            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    header.style.cursor = 'move';
                    element.style.userSelect = '';
                }
            });
        }

        // Setup outside click to close panel
        function setupOutsideClickClose(element) {
            // Add a small delay to prevent immediate closing
            setTimeout(() => {
                document.addEventListener('click', function closeOnOutsideClick(e) {
                    if (!element.contains(e.target)) {
                        element.remove();
                        document.removeEventListener('click', closeOnOutsideClick);
                    }
                });
            }, 100);
        }

        // Update layer opacity
        function updateLayerOpacity(layerId, opacityValue) {
            const layerInfo = layers.get(layerId);
            if (!layerInfo || !layerInfo.layer) return;
            
            // Store opacity in layer info
            layerInfo.opacity = opacityValue;
            
            // Update layer style with new opacity
            layerInfo.layer.eachLayer(function(layer) {
                if (layer.setStyle) {
                    const currentStyle = layer.options;
                    
                    // Store original style values if not already stored
                    if (!layer._originalOpacity) {
                        layer._originalOpacity = {
                            fillOpacity: currentStyle.fillOpacity || 1.0,
                            opacity: currentStyle.opacity || 1.0
                        };
                    }
                    
                    // Calculate new opacity values
                    // At 100% (1.0), use full opacity values; at 0% (0.0), use 0 opacity
                    const newFillOpacity = layer._originalOpacity.fillOpacity * opacityValue;
                    const newStrokeOpacity = layer._originalOpacity.opacity * opacityValue;
                    
                    layer.setStyle({
                        ...currentStyle,
                        fillOpacity: newFillOpacity,
                        opacity: newStrokeOpacity
                    });
                }
            });
        }

        // Apply categorical symbology from editor
        function applyCategoricalSymbologyFromEditor(layerId, field, colorMap) {
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;

            // Remove existing layer
            map.removeLayer(layerInfo.layer);

            // Create new styled layer
            const newLayer = L.geoJSON(layerInfo.data, {
                renderer: L.canvas(), // Force canvas rendering for leaflet-image export compatibility
                style: (feature) => {
                    const value = feature.properties[field];
                    const color = colorMap[value] || '#14b8a6';
                    return {
                        color: '#ffffff',
                        weight: 2,
                        opacity: 1.0,
                        fillColor: color,
                        fillOpacity: 1.0
                    };
                },
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="text-sm">';
                        for (let key in feature.properties) {
                            popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                        popupContent += '</div>';
                        
                        safeBindPopup(layer, popupContent, {
                            maxWidth: 400,
                            maxHeight: 300,
                            autoPan: false,
                            closePopupOnClick: true,
                            autoClose: true,
                            className: 'custom-popup',
                            offset: [0, -10]
                        });
                    }
                }
            }).addTo(map);

            // Update layer info
            layerInfo.layer = newLayer;
            layerInfo.style = { categoricalField: field, colorMap: colorMap };

            // Reapply opacity if it's not default
            if (layerInfo.opacity !== undefined && layerInfo.opacity !== 1.0) {
                updateLayerOpacity(layerId, layerInfo.opacity);
            }

            updateLegend();
        }

        // Reset layer symbology to default
        function resetLayerSymbology(layerId) {
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;

            const defaultStyle = {
                color: '#ffffff',
                weight: 2,
                opacity: 1.0,
                fillColor: '#14b8a6',
                fillOpacity: 1.0
            };

            // Remove existing layer
            map.removeLayer(layerInfo.layer);

            // Create new layer with default style
            const newLayer = L.geoJSON(layerInfo.data, {
                renderer: L.canvas(), // Force canvas rendering for leaflet-image export compatibility
                style: defaultStyle,
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="text-sm">';
                        for (let key in feature.properties) {
                            popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                        popupContent += '</div>';
                        
                        safeBindPopup(layer, popupContent, {
                            maxWidth: 400,
                            maxHeight: 300,
                            autoPan: false,
                            closePopupOnClick: true,
                            autoClose: true,
                            className: 'custom-popup',
                            offset: [0, -10]
                        });
                        
                        layer.on('click', function(e) {
                            if (isSelectionActive) {
                                e.originalEvent.preventDefault();
                                e.originalEvent.stopPropagation();
                                return false;
                            }
                        });
                    }
                }
            }).addTo(map);

            // Update layer info
            layerInfo.layer = newLayer;
            layerInfo.style = defaultStyle;

            // Reapply opacity if it's not default
            if (layerInfo.opacity !== undefined && layerInfo.opacity !== 1.0) {
                updateLayerOpacity(layerId, layerInfo.opacity);
            }

            updateLegend();
        }

        // Toggle symbology options (legacy - kept for compatibility)
        function toggleSymbologyOptions() {
            // Legacy function - not used with new symbology editor
            return;
        }

        // Apply symbology (legacy - kept for compatibility)
        function applySymbology() {
            // Legacy function - not used with new symbology editor
            return;
        }

        // Apply single symbol
        function applySingleSymbol(layerId, color) {
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;

            const newStyle = {
                color: '#ffffff',
                weight: 2,
                opacity: 1.0,
                fillColor: color,
                fillOpacity: 1.0
            };

            // Remove existing layer
            map.removeLayer(layerInfo.layer);

            // Create new styled layer
            const newLayer = L.geoJSON(layerInfo.data, {
                renderer: L.canvas(), // Force canvas rendering for leaflet-image export compatibility
                style: newStyle,
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="text-sm">';
                        for (let key in feature.properties) {
                            popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                        popupContent += '</div>';
                        
                        // Bind popup with custom options to prevent map movement and ensure proper sizing
                        safeBindPopup(layer, popupContent, {
                            maxWidth: 400,
                            maxHeight: 300,
                            autoPan: false, // Prevent map from panning to show popup
                            closePopupOnClick: true,
                            autoClose: true, // Close previous popup when opening new one
                            className: 'custom-popup',
                            offset: [0, -10] // Slight offset to avoid covering the clicked feature
                        });
                    }
                }
            }).addTo(map);

            // Update layer info
            layerInfo.layer = newLayer;
            layerInfo.style = newStyle;

            updateLegend();
        }

        // Apply categorical symbol
        function applyCategoricalSymbol(layerId, field) {
            const layerInfo = layers.get(layerId);
            if (!layerInfo) return;

            // Get unique values
            const features = layerInfo.data.features;
            const uniqueValues = [...new Set(features.map(f => f.properties[field]))];
            
            // Generate colors
            const colors = generateColors(uniqueValues.length);
            const colorMap = {};
            uniqueValues.forEach((value, index) => {
                colorMap[value] = colors[index];
            });

            // Remove existing layer
            map.removeLayer(layerInfo.layer);

            // Create new styled layer
            const newLayer = L.geoJSON(layerInfo.data, {
                renderer: L.canvas(), // Force canvas rendering for leaflet-image export compatibility
                style: (feature) => {
                    const value = feature.properties[field];
                    const color = colorMap[value] || '#14b8a6';
                    return {
                        color: '#ffffff',
                        weight: 2,
                        opacity: 1.0,
                        fillColor: color,
                        fillOpacity: 1.0
                    };
                },
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div class="text-sm">';
                        for (let key in feature.properties) {
                            popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                        popupContent += '</div>';
                        
                        // Bind popup with custom options to prevent map movement and ensure proper sizing
                        safeBindPopup(layer, popupContent, {
                            maxWidth: 400,
                            maxHeight: 300,
                            autoPan: false, // Prevent map from panning to show popup
                            closePopupOnClick: true,
                            autoClose: true, // Close previous popup when opening new one
                            className: 'custom-popup',
                            offset: [0, -10] // Slight offset to avoid covering the clicked feature
                        });
                    }
                }
            }).addTo(map);

            // Update layer info
            layerInfo.layer = newLayer;
            layerInfo.style = { categoricalField: field, colorMap: colorMap };

            updateLegend();
        }

        // Generate distinct colors
        function generateColors(count) {
            const colors = [
                '#14b8a6', '#06b6d4', '#8b5cf6', '#f59e0b',
                '#ef4444', '#10b981', '#3b82f6', '#f97316',
                '#ec4899', '#84cc16', '#6366f1', '#eab308'
            ];

            if (count <= colors.length) {
                return colors.slice(0, count);
            }

            // Generate additional colors if needed
            const additionalColors = [];
            for (let i = colors.length; i < count; i++) {
                const hue = (i * 137.508) % 360; // Golden angle approximation
                additionalColors.push(`hsl(${hue}, 70%, 50%)`);
            }

            return [...colors, ...additionalColors];
        }

        // Initialize selection tools
        function initializeSelectionTools() {
            // Create a layer group for drawn items
            drawnItems = new L.FeatureGroup();
            map.addLayer(drawnItems);

            // Remove the old draw control - we'll implement custom freehand drawing
            drawControl = null;
        }

        // Initialize middle mouse button panning
        function initializeMiddleMousePanning() {
            const mapContainer = map.getContainer();
            let isDraggingWithMiddle = false;
            let startPoint = null;
            
            // Prevent context menu on middle button
            mapContainer.addEventListener('contextmenu', function(e) {
                if (e.button === 1) {
                    e.preventDefault();
                }
            });

            // Handle middle mouse button down - start custom panning
            mapContainer.addEventListener('mousedown', function(e) {
                if (e.button === 1) { // Middle mouse button
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isMiddleMouseDown = true;
                    isDraggingWithMiddle = false;
                    startPoint = { x: e.clientX, y: e.clientY };
                    
                    // Change cursor to indicate panning mode
                    mapContainer.style.cursor = 'grab';
                }
            });

            // Handle mouse move for middle button panning
            mapContainer.addEventListener('mousemove', function(e) {
                if (isMiddleMouseDown && startPoint) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (!isDraggingWithMiddle) {
                        // Start dragging - change cursor to grabbing
                        mapContainer.style.cursor = 'grabbing';
                        isDraggingWithMiddle = true;
                    }
                    
                    // Calculate movement delta
                    const deltaX = e.clientX - startPoint.x;
                    const deltaY = e.clientY - startPoint.y;
                    
                    // Only pan if there's significant movement to avoid jitter
                    if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                        // Get current map center
                        const currentCenter = map.getCenter();
                        
                        // Convert pixel movement to lat/lng movement
                        const pixelBounds = map.getPixelBounds();
                        const pixelOrigin = map.getPixelOrigin();
                        
                        // Calculate new center based on pixel movement
                        const currentPixel = map.latLngToContainerPoint(currentCenter);
                        const newPixel = L.point(currentPixel.x - deltaX, currentPixel.y - deltaY);
                        const newCenter = map.containerPointToLatLng(newPixel);
                        
                        // Pan to new center
                        map.panTo(newCenter, { animate: false });
                        
                        // Update start point for next movement
                        startPoint = { x: e.clientX, y: e.clientY };
                    }
                }
            });

            // Handle middle mouse button up - stop custom panning
            mapContainer.addEventListener('mouseup', function(e) {
                if (e.button === 1 && isMiddleMouseDown) { // Middle mouse button
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isMiddleMouseDown = false;
                    isDraggingWithMiddle = false;
                    startPoint = null;
                    
                    // Restore appropriate cursor based on current tool
                    if (isSelectionActive) {
                        mapContainer.style.cursor = 'crosshair';
                    } else {
                        mapContainer.style.cursor = '';
                    }
                }
            });

            // Handle mouse leave - stop panning if middle button was held
            mapContainer.addEventListener('mouseleave', function(e) {
                if (isMiddleMouseDown) {
                    isMiddleMouseDown = false;
                    isDraggingWithMiddle = false;
                    startPoint = null;
                    
                    // Restore appropriate cursor
                    if (isSelectionActive) {
                        mapContainer.style.cursor = 'crosshair';
                    } else {
                        mapContainer.style.cursor = '';
                    }
                }
            });

            // Prevent middle button from interfering with other mouse events
            mapContainer.addEventListener('click', function(e) {
                if (e.button === 1) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
        }

        // Initialize Ctrl+Right-Click Zoom Box functionality
        function initializeZoomBox(mapInstance) {
            const mapContainer = mapInstance.getContainer();
            let isZoomBoxActive = false;
            let startPoint = null;
            let zoomBox = null;
            
            // Create zoom box element
            function createZoomBox() {
                const box = document.createElement('div');
                box.style.position = 'absolute';
                box.style.border = '2px dashed #0078d4';
                box.style.backgroundColor = 'rgba(0, 120, 212, 0.1)';
                box.style.pointerEvents = 'none';
                box.style.zIndex = '1000';
                box.style.display = 'none';
                mapContainer.appendChild(box);
                return box;
            }
            
            // Initialize zoom box element
            zoomBox = createZoomBox();
            
            // Handle right mouse button down with Ctrl
            mapContainer.addEventListener('mousedown', function(e) {
                // Only activate on right mouse button (2) with Ctrl key
                if (e.button === 2 && e.ctrlKey) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isZoomBoxActive = true;
                    startPoint = { x: e.clientX, y: e.clientY };
                    
                    // Get container offset for positioning
                    const rect = mapContainer.getBoundingClientRect();
                    const containerX = e.clientX - rect.left;
                    const containerY = e.clientY - rect.top;
                    
                    // Position zoom box at mouse location
                    zoomBox.style.left = containerX + 'px';
                    zoomBox.style.top = containerY + 'px';
                    zoomBox.style.width = '0px';
                    zoomBox.style.height = '0px';
                    zoomBox.style.display = 'block';
                    
                    // Disable map dragging during zoom box operation
                    mapInstance.dragging.disable();
                    
                    // Change cursor to crosshair
                    mapContainer.style.cursor = 'crosshair';
                }
            });
            
            // Handle mouse move for zoom box drawing
            mapContainer.addEventListener('mousemove', function(e) {
                if (isZoomBoxActive && startPoint) {
                    e.preventDefault();
                    
                    const rect = mapContainer.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;
                    const startX = startPoint.x - rect.left;
                    const startY = startPoint.y - rect.top;
                    
                    // Calculate box dimensions
                    const left = Math.min(startX, currentX);
                    const top = Math.min(startY, currentY);
                    const width = Math.abs(currentX - startX);
                    const height = Math.abs(currentY - startY);
                    
                    // Update zoom box position and size
                    zoomBox.style.left = left + 'px';
                    zoomBox.style.top = top + 'px';
                    zoomBox.style.width = width + 'px';
                    zoomBox.style.height = height + 'px';
                }
            });
            
            // Handle right mouse button up - complete zoom box
            mapContainer.addEventListener('mouseup', function(e) {
                if (e.button === 2 && isZoomBoxActive) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const rect = mapContainer.getBoundingClientRect();
                    const endX = e.clientX - rect.left;
                    const endY = e.clientY - rect.top;
                    const startX = startPoint.x - rect.left;
                    const startY = startPoint.y - rect.top;
                    
                    // Calculate minimum box size (prevent accidental tiny zooms)
                    const minBoxSize = 10;
                    const width = Math.abs(endX - startX);
                    const height = Math.abs(endY - startY);
                    
                    if (width > minBoxSize && height > minBoxSize) {
                        // Convert screen coordinates to map coordinates
                        const corner1 = mapInstance.containerPointToLatLng([startX, startY]);
                        const corner2 = mapInstance.containerPointToLatLng([endX, endY]);
                        
                        // Create bounds from the two corners
                        const bounds = L.latLngBounds([corner1, corner2]);
                        
                        // Zoom to the drawn rectangle with smooth animation
                        mapInstance.fitBounds(bounds, {
                            animate: true,
                            duration: 0.5,
                            padding: [5, 5] // Small padding for better visual appearance
                        });
                    }
                    
                    // Clean up
                    isZoomBoxActive = false;
                    startPoint = null;
                    zoomBox.style.display = 'none';
                    
                    // Re-enable map dragging
                    mapInstance.dragging.enable();
                    
                    // Reset cursor
                    mapContainer.style.cursor = '';
                }
            });
            
            // Handle context menu prevention during zoom box operation
            mapContainer.addEventListener('contextmenu', function(e) {
                if (e.ctrlKey || isZoomBoxActive) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            
            // Clean up on mouse leave
            mapContainer.addEventListener('mouseleave', function(e) {
                if (isZoomBoxActive) {
                    isZoomBoxActive = false;
                    startPoint = null;
                    zoomBox.style.display = 'none';
                    mapInstance.dragging.enable();
                    mapContainer.style.cursor = '';
                }
            });
        }

        // Setup selection tool event listeners
        function setupSelectionListeners() {
            document.getElementById('activateSelectTool').addEventListener('click', activateSelectionTool);
            document.getElementById('clearSelection').addEventListener('click', clearSelection);
            document.getElementById('showStatistics').addEventListener('click', toggleStatisticsPanel);

            // Real-time statistics field selection handler
            document.getElementById('statisticsFieldSelect').addEventListener('change', function(e) {
                calculateAndUpdateStatistics();
            });

            // Real-time statistics operations checkboxes handlers
            document.addEventListener('change', function(e) {
                if (e.target.classList.contains('statistics-operation-checkbox')) {
                    calculateAndUpdateStatistics();
                }
            });

            // Layer selection dropdown handler
            document.getElementById('activeLayerSelect').addEventListener('change', function(e) {
                activeSelectionLayerId = e.target.value;
                const activateBtn = document.getElementById('activateSelectTool');
                const statisticsBtn = document.getElementById('showStatistics');
                
                if (activeSelectionLayerId) {
                    activateBtn.disabled = false;
                    activateBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    
                    // Enable Statistics button when layer is selected
                    statisticsBtn.disabled = false;
                } else {
                    activateBtn.disabled = true;
                    activateBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    
                    // Disable Statistics button when no layer is selected
                    statisticsBtn.disabled = true;
                    
                    // Hide statistics panel when no layer is selected
                    document.getElementById('statisticsPanel').style.display = 'none';
                    
                    // If selection is active and no layer is selected, deactivate
                    if (isSelectionActive) {
                        deactivateSelectionTool();
                    }
                }
            });

            // Two-click freehand drawing event handlers
            function handleMouseDown(e) {
                if (!isSelectionActive || isMiddleMouseDown) return;
                
                // Only handle left mouse button for selection
                if (e.originalEvent.button !== 0) return;
                
                // ALWAYS prevent default and popup behavior during selection
                e.originalEvent.preventDefault();
                e.originalEvent.stopPropagation();
                
                if (!hasStartedDrawing) {
                    // First click - start drawing
                    hasStartedDrawing = true;
                    isDrawing = true;
                    drawingPath = [e.latlng];
                    
                    // Clear any existing drawing layers
                    if (currentDrawingLayer) {
                        map.removeLayer(currentDrawingLayer);
                    }
                    if (currentFillLayer) {
                        map.removeLayer(currentFillLayer);
                    }
                    
                    // Create initial drawing layer (line only)
                    currentDrawingLayer = L.polyline([e.latlng], {
                        color: '#ff7800',
                        weight: 3,
                        opacity: 0.8,
                        smoothFactor: 1
                    }).addTo(map);
                    
                    // Create initial fill layer (semi-transparent orange fill)
                    currentFillLayer = L.polygon([e.latlng, e.latlng], {
                        color: '#ff7800',
                        weight: 1,
                        opacity: 0.3,
                        fillColor: '#ff7800',
                        fillOpacity: 0.15,
                        smoothFactor: 1
                    }).addTo(map);
                } else {
                    // Second click - end drawing and perform selection
                    hasStartedDrawing = false;
                    isDrawing = false;
                    
                    // Add final point to the path
                    drawingPath.push(e.latlng);
                    
                    // Close the shape and perform selection
                    if (drawingPath.length > 1) {
                        // Close the polygon - use the exact drawn path without buffering
                        const closedPath = [...drawingPath, drawingPath[0]];
                        
                        // Capture modifier key state at the time of selection
                        const modifierKeys = {
                            shiftKey: e.originalEvent.shiftKey || false,
                            ctrlKey: e.originalEvent.ctrlKey || e.originalEvent.metaKey || false
                        };
                        
                        findIntersectingFeaturesWithPolygon(closedPath, modifierKeys);
                    }
                    
                    // Remove the drawing layers after a brief delay to show completion
                    setTimeout(() => {
                        if (currentDrawingLayer) {
                            map.removeLayer(currentDrawingLayer);
                            currentDrawingLayer = null;
                        }
                        if (currentFillLayer) {
                            map.removeLayer(currentFillLayer);
                            currentFillLayer = null;
                        }
                    }, 200);
                    
                    // Clear the drawing path
                    drawingPath = [];
                }
            }

            function handleMouseMove(e) {
                if (!isSelectionActive || !isDrawing || isMiddleMouseDown) return;
                
                // Continuously add points to the drawing path for true freehand drawing
                if (hasStartedDrawing) {
                    // Add current mouse position to the path for smooth freehand drawing
                    drawingPath.push(e.latlng);
                    
                    // Update the drawing layer with the full freehand path
                    if (currentDrawingLayer) {
                        currentDrawingLayer.setLatLngs(drawingPath);
                    }
                    
                    // Update fill layer - create closed shape from the complete drawn path
                    if (currentFillLayer && drawingPath.length > 2) {
                        const fillPath = [...drawingPath, drawingPath[0]]; // Close the shape
                        currentFillLayer.setLatLngs([fillPath]);
                    }
                }
            }

            // Remove the mouse up handler since we're using two-click mode
            function handleMouseUp(e) {
                // No longer needed for two-click mode
                return;
            }

            // Store event handlers for later removal
            map._freehandHandlers = {
                mousedown: handleMouseDown,
                mousemove: handleMouseMove,
                mouseup: handleMouseUp
            };
        }

        // Activate selection tool
        function activateSelectionTool() {
            // Check if an active layer is selected
            if (!activeSelectionLayerId) {
                showWarning('Please select a layer from the dropdown before activating the selection tool.', 'Layer Required');
                return;
            }
            
            if (!isSelectionActive) {
                isSelectionActive = true;
                
                // Clear previous selection
                clearSelection();
                
                // Reset drawing state
                hasStartedDrawing = false;
                isDrawing = false;
                
                // DISABLE popups on all layers during selection mode
                disablePopupsOnAllLayers();
                
                // DISABLE map dragging completely when selection tool is active
                map.dragging.disable();
                
                // Add freehand drawing event listeners
                map.on('mousedown', map._freehandHandlers.mousedown);
                map.on('mousemove', map._freehandHandlers.mousemove);
                map.on('mouseup', map._freehandHandlers.mouseup);
                
                // Update button states 
                document.getElementById('activateSelectTool').innerHTML = '<i class="fas fa-draw-polygon mr-2"></i>Selection Active (Shift: Add | Ctrl: Remove)';
                document.getElementById('activateSelectTool').classList.remove('bg-teal-600', 'hover:bg-teal-700');
                document.getElementById('activateSelectTool').classList.add('bg-orange-600', 'hover:bg-orange-700');
                
                // Change cursor to crosshair
                map.getContainer().style.cursor = 'crosshair';
                
                // Add a click handler to deactivate (optional - for user control)
                document.getElementById('activateSelectTool').removeEventListener('click', activateSelectionTool);
                document.getElementById('activateSelectTool').addEventListener('click', deactivateSelectionTool);
            }
        }

        // Deactivate selection tool
        function deactivateSelectionTool() {
            if (isSelectionActive) {
                isSelectionActive = false;
                isDrawing = false;
                hasStartedDrawing = false;
                
                // Remove freehand drawing event listeners
                map.off('mousedown', map._freehandHandlers.mousedown);
                map.off('mousemove', map._freehandHandlers.mousemove);
                map.off('mouseup', map._freehandHandlers.mouseup);
                
                // Clean up any current drawing
                if (currentDrawingLayer) {
                    map.removeLayer(currentDrawingLayer);
                    currentDrawingLayer = null;
                }
                if (currentFillLayer) {
                    map.removeLayer(currentFillLayer);
                    currentFillLayer = null;
                }
                drawingPath = [];
                
                // RE-ENABLE popups on all layers after selection mode
                enablePopupsOnAllLayers();
                
                // RE-ENABLE map dragging when selection tool is deactivated
                map.dragging.enable();
                
                // Reset cursor
                map.getContainer().style.cursor = '';
                
                // Update button states
                document.getElementById('activateSelectTool').innerHTML = '<i class="fas fa-draw-polygon mr-2"></i>Activate Selection Tool';
                document.getElementById('activateSelectTool').classList.remove('bg-orange-600', 'hover:bg-orange-700');
                document.getElementById('activateSelectTool').classList.add('bg-teal-600', 'hover:bg-teal-700');
                
                // Restore original click handler
                document.getElementById('activateSelectTool').removeEventListener('click', deactivateSelectionTool);
                document.getElementById('activateSelectTool').addEventListener('click', activateSelectionTool);
            }
        }

        // Disable popups on all layers during selection mode
        function disablePopupsOnAllLayers() {
            if (popupsDisabled) return; // Already disabled
            
            popupsDisabled = true;
            layers.forEach((layerInfo, layerId) => {
                if (layerInfo.layer) {
                    // Store the original popup content for restoration later
                    layerInfo._originalPopup = layerInfo.layer.getPopup();
                    // Unbind the popup to prevent it from appearing
                    layerInfo.layer.unbindPopup();
                }
            });
            
            console.log('🚫 Popups disabled for all layers during selection mode');
        }

        // Re-enable popups on all layers after selection mode
        function enablePopupsOnAllLayers() {
            if (!popupsDisabled) return; // Already enabled
            
            popupsDisabled = false;
            layers.forEach((layerInfo, layerId) => {
                if (layerInfo.layer) {
                    // First, restore original popups that were stored (convert to right-click)
                    if (layerInfo._originalPopup) {
                        const originalContent = layerInfo._originalPopup.getContent();
                        // Use safeBindPopup to convert to right-click
                        layerInfo.layer.eachLayer(function(sublayer) {
                            if (sublayer && originalContent) {
                                safeBindPopup(sublayer, originalContent);
                            }
                        });
                        delete layerInfo._originalPopup;
                    }
                    
                    // Also handle any pending popup content from layers created during selection
                    layerInfo.layer.eachLayer(function(sublayer) {
                        if (sublayer._pendingPopupContent) {
                            // Use safeBindPopup for right-click behavior
                            safeBindPopup(sublayer, sublayer._pendingPopupContent);
                            delete sublayer._pendingPopupContent;
                        }
                    });
                }
            });
            
            console.log('✅ Popups re-enabled for all layers after selection mode');
        }

        // Helper function to safely bind popups (respects selection mode) - RIGHT-CLICK ONLY
        function safeBindPopup(layer, popupContent) {
            if (!popupsDisabled) {
                // Remove any existing popup bindings first
                layer.unbindPopup();
                
                // Bind popup to right-click (contextmenu) event only
                layer.on('contextmenu', function(e) {
                    // Prevent the default browser context menu for this feature
                    e.originalEvent.preventDefault();
                    e.originalEvent.stopPropagation();
                    
                    // Create modern styled popup content
                    const modernPopupContent = createModernPopupContent(layer.feature ? layer.feature.properties : {});
                    
                    // Create and show popup at the clicked location
                    const popup = L.popup({
                        maxWidth: 350,
                        maxHeight: 400,
                        autoPan: true,
                        closePopupOnClick: true,
                        autoClose: true,
                        className: 'modern-feature-popup',
                        offset: [0, -15]
                    })
                    .setLatLng(e.latlng)
                    .setContent(modernPopupContent)
                    .openOn(map);
                });
            } else {
                // Store popup content for later binding when popups are re-enabled
                layer._pendingPopupContent = popupContent;
            }
        }

        // Create modern styled popup content
        function createModernPopupContent(properties) {
            if (!properties || Object.keys(properties).length === 0) {
                return `
                    <div class="modern-popup-container">
                        <div class="modern-popup-header">
                            <i class="fas fa-info-circle mr-2"></i>
                            <span>Feature Information</span>
                        </div>
                        <div class="modern-popup-body">
                            <p class="no-data-text">No property data available</p>
                        </div>
                    </div>
                `;
            }

            let propertiesHtml = '';
            for (let key in properties) {
                const value = properties[key];
                if (value !== null && value !== undefined && value !== '') {
                    propertiesHtml += `
                        <div class="property-row">
                            <span class="property-key">${key}:</span>
                            <span class="property-value">${value}</span>
                        </div>
                    `;
                }
            }

            return `
                <div class="modern-popup-container">
                    <div class="modern-popup-header">
                        <i class="fas fa-layer-group mr-2"></i>
                        <span>Feature Properties</span>
                    </div>
                    <div class="modern-popup-body">
                        ${propertiesHtml || '<p class="no-data-text">No valid properties found</p>'}
                    </div>
                </div>
            `;
        }

        // Find features that intersect with the drawn freehand polygon using Turf.js
        function findIntersectingFeaturesWithPolygon(polygonPath, modifierKeys = {}) {
            console.log('🔍 Starting strict selection process...');
            
            // Store current selection for modifier key operations
            const previousSelectedFeatures = [...selectedFeatures];
            const newSelectedFeatures = [];
            
            // Only clear highlights and selection if no modifier keys are held
            if (!modifierKeys.shiftKey && !modifierKeys.ctrlKey) {
                selectedFeatures = [];
                clearHighlights();
            } else {
                console.log('🎹 Modifier key detected:', modifierKeys.shiftKey ? 'Shift' : '', modifierKeys.ctrlKey ? 'Ctrl' : '');
            }
            
            // Validate polygon path
            if (!polygonPath || polygonPath.length < 4) { // Need at least 4 points for a closed polygon
                console.warn('❌ Invalid polygon path for selection:', polygonPath);
                updateSelectionInfo();
                return;
            }
            
            // Check if active layer is selected
            if (!activeSelectionLayerId || !layers.has(activeSelectionLayerId)) {
                console.warn('❌ No valid active layer selected for selection');
                showError('Please select a valid layer for selection.', 'Selection Error');
                updateSelectionInfo();
                return;
            }
            
            const activeLayerInfo = layers.get(activeSelectionLayerId);
            if (!activeLayerInfo.visible || !activeLayerInfo.layer) {
                console.warn('❌ Active layer is not visible or has no layer object');
                showError('The selected layer is not visible on the map.', 'Selection Error');
                updateSelectionInfo();
                return;
            }
            
            console.log('✅ Selection polygon path:', polygonPath.length, 'points');
            console.log('✅ Active layer for selection:', activeSelectionLayerId, activeLayerInfo.name);
            
            // Check if Turf.js is available
            if (typeof turf === 'undefined') {
                console.error('❌ Turf.js is not loaded! Using fallback selection...');
                performBoundsBasedSelectionOnActiveLayer(polygonPath);
                return;
            }
            
            // Convert the drawn path to a Turf Polygon for selection
            const coordinates = polygonPath.map(point => [point.lng, point.lat]);
            console.log('📍 Raw selection coordinates:', coordinates.length, 'points');
            console.log('📍 First 3 coordinates [lng,lat]:', coordinates.slice(0, 3));
            console.log('📍 Last 3 coordinates [lng,lat]:', coordinates.slice(-3));
            
            // Validate coordinate ranges (basic sanity check)
            const validCoords = coordinates.every(coord => 
                coord[0] >= -180 && coord[0] <= 180 && coord[1] >= -90 && coord[1] <= 90
            );
            console.log('📍 All coordinates within valid ranges:', validCoords);
            
            // Ensure the polygon is properly closed for Turf.js
            const firstPoint = coordinates[0];
            const lastPoint = coordinates[coordinates.length - 1];
            if (firstPoint[0] !== lastPoint[0] || firstPoint[1] !== lastPoint[1]) {
                coordinates.push(firstPoint);
                console.log('🔄 Auto-closed polygon - added first point to end');
            } else {
                console.log('✅ Polygon was already closed');
            }
            
            // Ensure minimum points for valid polygon (need at least 4: 3 unique + 1 closing)
            if (coordinates.length < 4) {
                console.warn('❌ Not enough points for polygon:', coordinates.length);
                performBoundsBasedSelectionOnActiveLayer(polygonPath);
                return;
            }
            
            let drawnPolygon;
            try {
                // Always create a polygon for area-based selection
                drawnPolygon = turf.polygon([coordinates]);
                const bbox = turf.bbox(drawnPolygon);
                console.log('✅ Created selection polygon with', coordinates.length, 'coordinates');
                console.log('✅ Polygon bounding box [minX, minY, maxX, maxY]:', bbox);
                console.log('✅ Polygon area (sq degrees):', turf.area(drawnPolygon));
                
                // Remove center point containment test
                console.log('🎯 Skipping center point test – using polygon directly for intersection checks');
                
            } catch (error) {
                console.warn('❌ Failed to create selection polygon:', error);
                console.error('Invalid coordinates:', coordinates);
                // Fallback to simple bounds-based selection
                performBoundsBasedSelectionOnActiveLayer(polygonPath);
                return;
            }
            
            // Check only the active layer for intersecting features
            let layerFeatureCount = 0;
            let layerSelectedCount = 0;
            
            console.log(`🔎 Checking active layer with STRICT intersection: "${activeLayerInfo.name}"`);
            console.log('🔍 Active layer object:', activeLayerInfo.layer);
            console.log('🔍 Layer has eachLayer method:', typeof activeLayerInfo.layer.eachLayer === 'function');
            
            activeLayerInfo.layer.eachLayer(function(leafletFeature) {
                layerFeatureCount++;
                console.log(`📊 Processing feature ${layerFeatureCount}/${activeLayerInfo.layer.getLayers().length}:`, leafletFeature);
                
                // Additional debugging for Aera.geojson features
                if (activeLayerInfo.name === 'Aera') {
                    console.log('🗺️ Processing Aera.geojson feature:');
                    console.log('   Feature type:', leafletFeature.feature ? leafletFeature.feature.type : 'No feature object');
                    console.log('   Geometry type:', leafletFeature.feature && leafletFeature.feature.geometry ? leafletFeature.feature.geometry.type : 'No geometry');
                    console.log('   Has getLatLng:', typeof leafletFeature.getLatLng === 'function');
                    console.log('   Has getLatLngs:', typeof leafletFeature.getLatLngs === 'function');
                    if (leafletFeature.getLatLngs) {
                        const latLngs = leafletFeature.getLatLngs();
                        console.log('   LatLngs structure depth:', Array.isArray(latLngs) ? (Array.isArray(latLngs[0]) ? (Array.isArray(latLngs[0][0]) ? 3 : 2) : 1) : 0);
                    }
                }
                
                try {
                    // Validate feature before processing
                    if (!leafletFeature.feature || leafletFeature.feature.type !== 'Feature') {
                        console.log('⚠️ Skipping feature: not a valid GeoJSON Feature');
                        return;
                    }
                    
                    const geometryType = leafletFeature.feature.geometry ? leafletFeature.feature.geometry.type : null;
                    
                    // Convert Leaflet feature to GeoJSON for Turf.js
                    let geoJsonFeature;
                    let intersects = false;
                    
                    if (leafletFeature.getLatLng) {
                        // Point feature - test if point is inside the selection polygon
                        const point = leafletFeature.getLatLng();
                        geoJsonFeature = turf.point([point.lng, point.lat]);
                        
                        intersects = turf.booleanPointInPolygon(geoJsonFeature, drawnPolygon);
                        console.log(`📍 Point [${point.lat.toFixed(6)}, ${point.lng.toFixed(6)}] inside polygon: ${intersects}`);
                        
                        // Debug: Also log the point coordinates vs polygon bounds
                        const bbox = turf.bbox(drawnPolygon);
                        const inBounds = point.lng >= bbox[0] && point.lng <= bbox[2] && point.lat >= bbox[1] && point.lat <= bbox[3];
                        console.log(`📍 Point in polygon bounds: ${inBounds} (bounds check)`);
                        
                    } else if (leafletFeature.getLatLngs) {
                        // Only process Polygon and MultiPolygon features
                        if (geometryType !== 'Polygon' && geometryType !== 'MultiPolygon') {
                            console.log(`⚠️ Skipping feature: geometry type '${geometryType}' not supported (only Polygon/MultiPolygon allowed)`);
                            return;
                        }
                        
                        // Polygon or LineString feature
                        const latLngs = leafletFeature.getLatLngs();

                        if (Array.isArray(latLngs[0])) {
                            // Multi-ring polygon or MultiPolygon feature
                            try {
                                // Check if this is a MultiPolygon (nested arrays) or regular polygon with holes
                                let coordinates = [];
                                let isMultiPolygon = Array.isArray(latLngs[0][0]);
                                
                                console.log(`🔶 Processing ${isMultiPolygon ? 'MultiPolygon' : 'Polygon'} feature`);
                                
                                if (isMultiPolygon) {
                                    // This is a MultiPolygon - each top-level element is a complete polygon
                                    latLngs.forEach((polygon, polygonIndex) => {
                                        const rings = polygon.map(ring => {
                                            if (!Array.isArray(ring) || ring.length < 3) return null;
                                            const coords = ring.map(point => [point.lng, point.lat]);
                                            // Ensure ring is closed
                                            if (coords[0][0] !== coords[coords.length-1][0] || coords[0][1] !== coords[coords.length-1][1]) {
                                                coords.push(coords[0]);
                                            }
                                            return coords;
                                        }).filter(ring => ring !== null && ring.length >= 4);
                                        
                                        if (rings.length > 0) {
                                            coordinates.push(rings);
                                        }
                                    });
                                    
                                    // For MultiPolygon, test each polygon part separately
                                    for (let i = 0; i < coordinates.length; i++) {
                                        try {
                                            const singlePolygon = turf.polygon(coordinates[i]);
                                            intersects = turf.booleanIntersects(singlePolygon, drawnPolygon);
                                            console.log(`🔶 MultiPolygon part ${i+1}/${coordinates.length} intersection: ${intersects}`);
                                            if (intersects) break; // Found intersection, no need to test other parts
                                        } catch (partError) {
                                            console.warn(`⚠️ MultiPolygon part ${i+1} processing failed:`, partError);
                                        }
                                    }
                                } else {
                                    // This is a regular polygon with potential holes
                                    coordinates = latLngs.map(ring => {
                                        if (!Array.isArray(ring) || ring.length < 3) return null;
                                        const coords = ring.map(point => [point.lng, point.lat]);
                                        // Ensure ring is closed
                                        if (coords[0][0] !== coords[coords.length-1][0] || coords[0][1] !== coords[coords.length-1][1]) {
                                            coords.push(coords[0]);
                                        }
                                        return coords;
                                    }).filter(ring => ring !== null && ring.length >= 4);

                                    if (coordinates.length > 0) {
                                        geoJsonFeature = turf.polygon(coordinates);
                                        intersects = turf.booleanIntersects(geoJsonFeature, drawnPolygon);
                                        console.log(`🔶 Polygon feature intersection: ${intersects}`);
                                    }
                                }
                            } catch (polyError) {
                                console.warn('⚠️ Polygon processing failed:', polyError);
                            }
                        } else {
                            // Simple LineString feature
                            try {
                                if (latLngs.length >= 2) {
                                    const coordinates = latLngs.map(point => [point.lng, point.lat]);
                                    geoJsonFeature = turf.lineString(coordinates);

                                    // Strict geometry-to-geometry intersection test
                                    intersects = turf.booleanIntersects(geoJsonFeature, drawnPolygon);
                                    console.log(`📏 LineString feature intersection: ${intersects}`);
                                }
                            } catch (lineError) {
                                console.warn('⚠️ LineString processing failed:', lineError);
                            }
                        }
                    }
                    
                    if (intersects) {
                        layerSelectedCount++;
                        console.log('🎯 Feature INTERSECTS! Adding to selection...');
                        newSelectedFeatures.push({
                            layerId: activeSelectionLayerId,
                            layerName: activeLayerInfo.name,
                            feature: leafletFeature,
                            properties: leafletFeature.feature ? leafletFeature.feature.properties : {}
                        });
                    } else {
                        console.log('❌ Feature does NOT intersect selection polygon');
                    }
                    
                } catch (error) {
                    console.warn('⚠️ Feature processing failed:', error);
                    console.log('Feature type:', typeof leafletFeature);
                    console.log('Has getLatLng:', typeof leafletFeature.getLatLng);
                    console.log('Has getLatLngs:', typeof leafletFeature.getLatLngs);
                }
            });
            
            console.log(`📊 Selection complete: ${layerFeatureCount} total features, ${layerSelectedCount} selected`);
            console.log('New intersected features:', newSelectedFeatures.length);
            
            // Apply modifier key logic
            if (modifierKeys.shiftKey) {
                // Shift + Selection: Add to current selection
                console.log('➕ Shift+Selection: Adding to existing selection');
                
                // Create a Set of existing feature references for efficient lookup
                const existingFeatureRefs = new Set(selectedFeatures.map(item => item.feature));
                
                // Add new features that aren't already selected
                newSelectedFeatures.forEach(newItem => {
                    if (!existingFeatureRefs.has(newItem.feature)) {
                        selectedFeatures.push(newItem);
                        highlightFeature(newItem.feature);
                    }
                });
                
            } else if (modifierKeys.ctrlKey) {
                // Ctrl + Selection: Remove from current selection
                console.log('➖ Ctrl+Selection: Removing from existing selection');
                
                // Create a Set of features to remove for efficient lookup
                const featuresToRemove = new Set(newSelectedFeatures.map(item => item.feature));
                
                // Filter out intersected features from current selection and remove highlights
                selectedFeatures = selectedFeatures.filter(existingItem => {
                    if (featuresToRemove.has(existingItem.feature)) {
                        // Remove highlight from this feature
                        if (existingItem.feature._originalStyle) {
                            existingItem.feature.setStyle(existingItem.feature._originalStyle);
                            delete existingItem.feature._originalStyle;
                        }
                        return false; // Remove from selection
                    }
                    return true; // Keep in selection
                });
                
                // Remove from highlighted layers array
                highlightedLayers = highlightedLayers.filter(layer => !featuresToRemove.has(layer));
                
            } else {
                // Default behavior: Replace selection entirely
                console.log('🔄 Default selection: Replacing current selection');
                selectedFeatures = [...newSelectedFeatures];
                
                // Clear all previous highlights first
                clearHighlights();
                
                // Highlight all newly selected features
                newSelectedFeatures.forEach(item => {
                    highlightFeature(item.feature);
                });
            }
            
            console.log('Final selected features:', selectedFeatures.length);
            
            // Update selection info
            updateSelectionInfo();
        }
        
        // Check if point is inside polygon (updated for LatLng objects)
        function isPointInPolygon(point, polygon) {
            const x = point.lat, y = point.lng;
            let inside = false;
            
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].lat, yi = polygon[i].lng;
                const xj = polygon[j].lat, yj = polygon[j].lng;
                
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // Strict point-in-polygon test for accurate selection
        function isPointInPolygonStrict(point, polygon) {
            const x = point.lat, y = point.lng;
            let inside = false;
            
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].lat, yi = polygon[i].lng;
                const xj = polygon[j].lat, yj = polygon[j].lng;
                
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // Check if bounds intersect with polygon (simplified)
        function boundsIntersectPolygon(bounds, polygon) {
            const corners = [
                bounds.getNorthWest(),
                bounds.getNorthEast(),
                bounds.getSouthEast(),
                bounds.getSouthWest()
            ];
            
            // Check if any corner is inside the polygon
            return corners.some(corner => isPointInPolygon(corner, polygon));
        }

        // Highlight selected feature
        function highlightFeature(feature) {
            // Store current style before highlighting
            if (!feature._originalStyle) {
                feature._originalStyle = {
                    color: feature.options.color,
                    weight: feature.options.weight,
                    opacity: feature.options.opacity,
                    fillColor: feature.options.fillColor,
                    fillOpacity: feature.options.fillOpacity
                };
            }
            
            const highlightStyle = {
                color: '#ffff00',
                weight: 4,
                opacity: 1,
                fillColor: '#ffff00',
                fillOpacity: 0.7
            };
            
            feature.setStyle(highlightStyle);
            highlightedLayers.push(feature);
        }

        // Clear all highlights
        function clearHighlights() {
            highlightedLayers.forEach(feature => {
                if (feature._originalStyle) {
                    feature.setStyle(feature._originalStyle);
                    delete feature._originalStyle;
                } else {
                    // Restore default style from the layer
                    const layerInfo = Array.from(layers.values()).find(layer => 
                        layer.layer.hasLayer && layer.layer.hasLayer(feature)
                    );
                    if (layerInfo && layerInfo.style) {
                        feature.setStyle(layerInfo.style);
                    }
                }
            });
            highlightedLayers = [];
        }

        // Clear selection
        function clearSelection() {
            selectedFeatures = [];
            clearHighlights();
            updateSelectionInfo();
            
            // Stop any current drawing and reset drawing state
            if (isDrawing || hasStartedDrawing) {
                isDrawing = false;
                hasStartedDrawing = false;
                
                if (currentDrawingLayer) {
                    map.removeLayer(currentDrawingLayer);
                    currentDrawingLayer = null;
                }
                if (currentFillLayer) {
                    map.removeLayer(currentFillLayer);
                    currentFillLayer = null;
                }
                drawingPath = [];
                
                // Only re-enable dragging if selection tool is not active
                if (!isSelectionActive) {
                    map.dragging.enable();
                }
            }
            
            // Update button states
            document.getElementById('clearSelection').disabled = true;
            document.getElementById('showStatistics').disabled = !activeSelectionLayerId;
        }

        // Update selection info panel
        function updateSelectionInfo() {
            const countNumberElement = document.getElementById('selectedCountNumber');
            const listElement = document.getElementById('selectedFeaturesList');
            const clearButton = document.getElementById('clearSelection');
            const statisticsButton = document.getElementById('showStatistics');
            
            const targetCount = selectedFeatures.length;
            const currentCount = parseInt(countNumberElement.textContent) || 0;
            
            // Update button states
            clearButton.disabled = targetCount === 0;
            // Statistics button is enabled when a layer is selected, not just when features are selected
            statisticsButton.disabled = !activeSelectionLayerId;
            
            // Only hide statistics panel if no layer is selected
            if (!activeSelectionLayerId) {
                document.getElementById('statisticsPanel').style.display = 'none';
                document.getElementById('statisticsResults').style.display = 'none';
                document.getElementById('statisticsResults').innerHTML = '';
            }
            
            // Animate the count change
            if (targetCount !== currentCount) {
                animateCounter(countNumberElement, currentCount, targetCount);
                
                // Trigger real-time statistics update when selection changes
                calculateAndUpdateStatistics();
            }
            
            // Update Filter Selected button state when selection changes
            if (typeof updateFilterSelectedButton === 'function') {
                updateFilterSelectedButton();
            }
            
            // Hide feature list - we only show the count now
            listElement.style.display = 'none';
            listElement.innerHTML = '';
        }

        // Animate counter from current value to target value
        function animateCounter(element, startValue, endValue) {
            const duration = Math.min(800, Math.abs(endValue - startValue) * 40); // Max 800ms, min based on difference
            const startTime = performance.now();
            
            // Add counting animation class
            element.classList.add('counting');
            
            function updateCounter(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Use easeOutCubic for smooth animation
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                const currentValue = Math.round(startValue + (endValue - startValue) * easeProgress);
                
                element.textContent = currentValue;
                
                if (progress < 1) {
                    requestAnimationFrame(updateCounter);
                } else {
                    // Animation complete
                    element.textContent = endValue;
                    element.classList.remove('counting');
                }
            }
            
            requestAnimationFrame(updateCounter);
        }

        // Statistics Panel Functions
        function toggleStatisticsPanel() {
            const panel = document.getElementById('statisticsPanel');
            const isVisible = panel.style.display !== 'none';
            
            if (isVisible) {
                panel.style.display = 'none';
            } else {
                panel.style.display = 'block';
                populateFieldDropdown();
            }
        }

        function populateFieldDropdown() {
            const fieldSelect = document.getElementById('statisticsFieldSelect');
            const results = document.getElementById('statisticsResults');
            
            // Clear previous options and results
            fieldSelect.innerHTML = '<option value="">Select a field</option>';
            results.style.display = 'none';
            results.innerHTML = '';
            
            // Check if we have an active layer selected (not just selected features)
            if (!activeSelectionLayerId || !layers.has(activeSelectionLayerId)) {
                return;
            }
            
            const activeLayerInfo = layers.get(activeSelectionLayerId);
            if (!activeLayerInfo || !activeLayerInfo.data || !activeLayerInfo.data.features) {
                return;
            }
            
            // Collect all unique field names from the active layer's features
            const fieldNames = new Set();
            const numericFields = new Set();
            
            activeLayerInfo.data.features.forEach(feature => {
                if (feature.properties) {
                    Object.keys(feature.properties).forEach(key => {
                        fieldNames.add(key);
                        
                        // Check if field is numeric
                        const value = feature.properties[key];
                        if (typeof value === 'number' || (!isNaN(parseFloat(value)) && isFinite(value))) {
                            numericFields.add(key);
                        }
                    });
                }
            });
            
            // Add numeric fields to dropdown
            Array.from(numericFields).sort().forEach(field => {
                const option = document.createElement('option');
                option.value = field;
                option.textContent = field;
                fieldSelect.appendChild(option);
            });
            
            // Add non-numeric fields for count operation only
            Array.from(fieldNames).filter(field => !numericFields.has(field)).sort().forEach(field => {
                const option = document.createElement('option');
                option.value = field;
                option.textContent = `${field} (text - count only)`;
                option.dataset.isText = 'true';
                fieldSelect.appendChild(option);
            });
        }

        // Real-time statistics calculation and display as floating cards
        function calculateAndUpdateStatistics() {
            const fieldSelect = document.getElementById('statisticsFieldSelect');
            const selectedField = fieldSelect.value;
            const floatingContainer = document.getElementById('floatingStatisticsContainer');
            
            // Get selected operations from checkboxes
            const selectedOperations = Array.from(document.querySelectorAll('.statistics-operation-checkbox:checked'))
                .map(checkbox => checkbox.value);
            
            // Hide container if no field or operations selected
            if (!selectedField || selectedOperations.length === 0) {
                floatingContainer.style.display = 'none';
                clearFloatingStatisticsCards();
                return;
            }
            
            // Show container
            floatingContainer.style.display = 'block';
            
            const isTextField = fieldSelect.options[fieldSelect.selectedIndex].dataset.isText === 'true';
            const hasSelectedFeatures = selectedFeatures.length > 0;
            
            // Get currently displayed operations to compare
            const existingCards = Array.from(floatingContainer.querySelectorAll('.floating-statistics-card'));
            const existingOperations = existingCards.map(card => card.dataset.operation);
            
            // Remove cards for unchecked operations
            existingCards.forEach(card => {
                const operation = card.dataset.operation;
                if (!selectedOperations.includes(operation)) {
                    card.style.animation = 'fadeOutAtPosition 0.3s ease-in forwards';
                    setTimeout(() => {
                        if (card.parentNode) {
                            card.remove();
                        }
                    }, 300);
                }
            });
            
            // Process each selected operation and create floating cards
            selectedOperations.forEach((operation) => {
                // Always update existing cards to ensure real-time responsiveness
                if (existingOperations.includes(operation)) {
                    // Force update existing card content for every selection change
                    updateExistingCard(operation, selectedField, isTextField, hasSelectedFeatures);
                    return; // Only return from this iteration, continue with next operation
                }
                
                let resultValue = null;
                let isValidOperation = true;
                
                if (!hasSelectedFeatures) {
                    resultValue = "No features selected";
                } else {
                    // Extract values from selected features
                    const values = selectedFeatures.map(feature => {
                        const value = feature.properties[selectedField];
                        if (isTextField) return value;
                        return typeof value === 'number' ? value : parseFloat(value);
                    }).filter(val => val !== null && val !== undefined && (!isTextField ? !isNaN(val) : true));
                    
                    // Calculate based on operation
                    switch (operation) {
                        case 'sum':
                            if (isTextField) isValidOperation = false;
                            else resultValue = values.reduce((sum, val) => sum + val, 0);
                            break;
                        case 'average':
                            if (isTextField) isValidOperation = false;
                            else resultValue = values.length > 0 ? values.reduce((sum, val) => sum + val, 0) / values.length : 0;
                            break;
                        case 'mode':
                            if (values.length > 0) {
                                const frequency = {};
                                values.forEach(val => frequency[val] = (frequency[val] || 0) + 1);
                                const maxFreq = Math.max(...Object.values(frequency));
                                const modes = Object.keys(frequency).filter(val => frequency[val] === maxFreq);
                                resultValue = modes.length === 1 ? (isTextField ? modes[0] : parseFloat(modes[0])) : modes.join(', ');
                            } else resultValue = isTextField ? 'N/A' : 0;
                            break;
                        case 'min':
                            if (isTextField) isValidOperation = false;
                            else resultValue = values.length > 0 ? Math.min(...values) : 0;
                            break;
                        case 'max':
                            if (isTextField) isValidOperation = false;
                            else resultValue = values.length > 0 ? Math.max(...values) : 0;
                            break;
                    }
                }
                
                // Only display if it's a valid operation - create new card
                if (isValidOperation) {
                    createFloatingStatisticsCard(selectedField, operation, resultValue, hasSelectedFeatures ? selectedFeatures.length : 0, hasSelectedFeatures);
                }
            });
        }

        // Update content of existing card without recreating it
        function updateExistingCard(operation, field, isTextField, hasSelectedFeatures) {
            const floatingContainer = document.getElementById('floatingStatisticsContainer');
            const existingCard = floatingContainer.querySelector(`[data-operation="${operation}"]`);
            
            if (!existingCard) return;
            
            let resultValue = null;
            
            if (!hasSelectedFeatures) {
                resultValue = "No features selected";
            } else {
                // Extract values from selected features
                const values = selectedFeatures.map(feature => {
                    const value = feature.properties[field];
                    if (isTextField) return value;
                    return typeof value === 'number' ? value : parseFloat(value);
                }).filter(val => val !== null && val !== undefined && (!isTextField ? !isNaN(val) : true));
                
                // Calculate based on operation
                switch (operation) {
                    case 'sum':
                        if (isTextField) resultValue = 'N/A';
                        else resultValue = values.reduce((sum, val) => sum + val, 0);
                        break;
                    case 'average':
                        if (isTextField) resultValue = 'N/A';
                        else resultValue = values.length > 0 ? values.reduce((sum, val) => sum + val, 0) / values.length : 0;
                        break;
                    case 'mode':
                        if (values.length > 0) {
                            const frequency = {};
                            values.forEach(val => frequency[val] = (frequency[val] || 0) + 1);
                            const maxFreq = Math.max(...Object.values(frequency));
                            const modes = Object.keys(frequency).filter(val => frequency[val] === maxFreq);
                            resultValue = modes.length === 1 ? (isTextField ? modes[0] : parseFloat(modes[0])) : modes.join(', ');
                        } else resultValue = isTextField ? 'N/A' : 0;
                        break;
                    case 'min':
                        if (isTextField) resultValue = 'N/A';
                        else resultValue = values.length > 0 ? Math.min(...values) : 0;
                        break;
                    case 'max':
                        if (isTextField) resultValue = 'N/A';
                        else resultValue = values.length > 0 ? Math.max(...values) : 0;
                        break;
                    default:
                        resultValue = 'N/A';
                        break;
                }
            }
            
            // Update the card content - always force updates for responsiveness
            const fieldElement = existingCard.querySelector('.floating-statistics-field');
            const numberElement = existingCard.querySelector('.floating-statistics-number');
            const noFeaturesElement = existingCard.querySelector('.floating-statistics-no-features');
            
            if (resultValue === "No features selected") {
                if (fieldElement) fieldElement.textContent = `of "${field}"`;
                if (noFeaturesElement) noFeaturesElement.textContent = resultValue;
                if (numberElement) numberElement.style.display = 'none';
            } else {
                // If transitioning from "No features" to actual values, recreate the card structure
                if (noFeaturesElement && !numberElement) {
                    // Recreate the card with proper structure for displaying values
                    existingCard.innerHTML = `
                        <div class="floating-statistics-header">
                            <div class="floating-statistics-operation">${operation}</div>
                            <div class="floating-statistics-field">of "${field}" (${selectedFeatures.length} features)</div>
                        </div>
                        <div class="floating-statistics-number" data-target-value="${typeof resultValue === 'number' ? resultValue : 0}">0</div>
                        <div class="floating-statistics-label">${operation}</div>
                    `;
                    
                    // Get the new number element after recreation
                    const newNumberElement = existingCard.querySelector('.floating-statistics-number');
                    if (newNumberElement && typeof resultValue === 'number') {
                        setTimeout(() => {
                            animateFloatingCounter(newNumberElement, 0, resultValue, operation);
                        }, 50);
                    } else if (newNumberElement) {
                        const formattedValue = typeof resultValue === 'number' ? 
                            Number(resultValue.toFixed(4)).toLocaleString() : 
                            resultValue;
                        newNumberElement.textContent = formattedValue;
                    }
                } else {
                    // Normal update for existing structure - force update every time
                    if (fieldElement) fieldElement.textContent = `of "${field}" (${selectedFeatures.length} features)`;
                    if (noFeaturesElement) noFeaturesElement.style.display = 'none';
                    if (numberElement) {
                        numberElement.style.display = 'block';
                        
                        // Get current displayed value (parse from formatted text)
                        const currentDisplayText = numberElement.textContent.replace(/,/g, '');
                        const currentValue = parseFloat(currentDisplayText) || 0;
                        
                        if (typeof resultValue === 'number' && hasSelectedFeatures) {
                            // Force animation even for identical values to provide visual feedback
                            // This ensures updates are visible even when switching between features with same values
                            animateFloatingCounter(numberElement, currentValue, resultValue, operation);
                        } else {
                            // For non-numeric values, update immediately
                            const formattedValue = typeof resultValue === 'number' ? 
                                Number(resultValue.toFixed(4)).toLocaleString() : 
                                resultValue;
                            numberElement.textContent = formattedValue;
                        }
                    }
                }
            }
        }

        // Clear all floating statistics cards
        function clearFloatingStatisticsCards() {
            const floatingContainer = document.getElementById('floatingStatisticsContainer');
            
            // Animate out existing cards simultaneously for smooth transition
            const existingCards = floatingContainer.querySelectorAll('.floating-statistics-card');
            existingCards.forEach((card) => {
                card.style.animation = 'fadeOutAtPosition 0.3s ease-in forwards';
            });
            
            // Remove all cards after animation completes
            setTimeout(() => {
                existingCards.forEach(card => {
                    if (card.parentNode) {
                        card.remove();
                    }
                });
            }, 300);
        }

        // Create animated floating statistics cards
        function createFloatingStatisticsCard(field, operation, value, count, hasFeatures) {
            const floatingContainer = document.getElementById('floatingStatisticsContainer');
            
            // Format the result value
            let formattedValue;
            let isNoFeaturesMessage = false;
            
            if (value === "No features selected") {
                formattedValue = value;
                isNoFeaturesMessage = true;
            } else if (typeof value === 'number') {
                if (operation === 'count') {
                    formattedValue = value.toLocaleString();
                } else {
                    formattedValue = Number(value.toFixed(4)).toLocaleString();
                }
            } else {
                formattedValue = value;
            }
            
            // Create the floating card
            const card = document.createElement('div');
            card.className = 'floating-statistics-card';
            card.dataset.operation = operation;
            
            if (isNoFeaturesMessage) {
                // Special styling for "No features selected" message
                card.innerHTML = `
                    <div class="floating-statistics-header">
                        <div class="floating-statistics-operation">${operation}</div>
                        <div class="floating-statistics-field">of "${field}"</div>
                    </div>
                    <div class="floating-statistics-no-features">${formattedValue}</div>
                    <div class="floating-statistics-help-text">Select features on the map to calculate statistics</div>
                `;
            } else {
                // Normal result display with animated counter
                card.innerHTML = `
                    <div class="floating-statistics-header">
                        <div class="floating-statistics-operation">${operation}</div>
                        <div class="floating-statistics-field">of "${field}" (${count} features)</div>
                    </div>
                    <div class="floating-statistics-number" data-target-value="${typeof value === 'number' ? value : 0}">0</div>
                    <div class="floating-statistics-label">${operation}</div>
                `;
            }
            
            floatingContainer.appendChild(card);
            
            // Animate the counter if it's a numeric value and we have features
            if (typeof value === 'number' && hasFeatures) {
                const numberElement = card.querySelector('.floating-statistics-number');
                if (numberElement) {
                    setTimeout(() => {
                        animateFloatingCounter(numberElement, 0, value, operation);
                    }, 50); // Reduced delay for smoother appearance
                }
            } else if (hasFeatures && typeof value !== 'number') {
                // For non-numeric values, just show the value directly
                const numberElement = card.querySelector('.floating-statistics-number');
                if (numberElement) {
                    numberElement.textContent = formattedValue;
                }
            }
        }

        // Animate floating statistics counter
        function animateFloatingCounter(element, startValue, endValue, operation) {
            // Remove any existing counting class to prevent conflicts
            element.classList.remove('counting');
            
            // If values are the same or very close, update immediately without animation
            if (Math.abs(endValue - startValue) < 0.0001) {
                const finalValue = Number(endValue.toFixed(4)).toLocaleString();
                element.textContent = finalValue;
                return;
            }
            
            const duration = Math.min(800, Math.abs(endValue - startValue) * 40);
            const startTime = performance.now();
            
            // Add counting animation class
            element.classList.add('counting');
            
            function updateCounter(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Use easeOutCubic for smooth animation
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                const currentValue = startValue + (endValue - startValue) * easeProgress;
                
                // Format the value based on operation type
                let displayValue;
                displayValue = Number(currentValue.toFixed(4)).toLocaleString();
                
                element.textContent = displayValue;
                
                if (progress < 1) {
                    requestAnimationFrame(updateCounter);
                } else {
                    // Animation complete
                    const finalValue = Number(endValue.toFixed(4)).toLocaleString();
                    element.textContent = finalValue;
                    element.classList.remove('counting');
                }
            }
            
            requestAnimationFrame(updateCounter);
        }

        // Add Data button functionality and drag-and-drop support
        (function() {
            // Wait for DOM to be fully loaded
            function initializeFileHandling() {
                // Allowed file types
                const allowedTypes = [
                    'application/geo+json', 'application/json', 'application/vnd.google-earth.kml+xml',
                    '.geojson', '.kml', '.kmz'
                ];
                const maxSize = 50 * 1024 * 1024; // 50MB

                // Define cleanup effects function first
                function cleanupEffects() {
                    // Remove all potential classes that might cause blur/lock effects
                    document.body.classList.remove('overflow-hidden', 'backdrop-blur', 'z-50', 'modal-open');
                    document.documentElement.classList.remove('overflow-hidden', 'backdrop-blur', 'z-50', 'modal-open');
                    
                    // Reset map container
                    const mapEl = document.getElementById('map');
                    if (mapEl) {
                        mapEl.style.pointerEvents = '';
                        mapEl.style.overflow = '';
                        mapEl.style.filter = '';
                        mapEl.style.opacity = '';
                        mapEl.classList.remove('blur', 'backdrop-blur');
                    }
                    
                    // Remove any modal overlays
                    const overlays = document.querySelectorAll('.modal-overlay');
                    overlays.forEach(overlay => {
                        overlay.classList.add('hidden');
                        overlay.style.display = 'none';
                    });
                    
                    // Reset header effects
                    const header = document.querySelector('header');
                    if (header) {
                        header.style.filter = '';
                        header.style.backdropFilter = '';
                        header.style.webkitBackdropFilter = '';
                        header.style.opacity = '';
                        header.style.pointerEvents = '';
                        header.classList.remove('blur', 'backdrop-blur');
                    }
                    
                    // Reset any other potentially affected elements
                    const mainContent = document.querySelector('.main-content-container');
                    if (mainContent) {
                        mainContent.style.filter = '';
                        mainContent.style.opacity = '';
                        mainContent.style.pointerEvents = '';
                    }
                    
                    // Force a complete page repaint
                    document.body.style.transform = 'translateZ(0)';
                    setTimeout(() => {
                        document.body.style.transform = '';
                    }, 10);
                }

                // Function to process file (shared between button and drag-drop)
                function processFile(file, fromDragDrop = false) {
                    // Validate file type
                    const ext = file.name.split('.').pop().toLowerCase();
                    if (!["geojson","kml","kmz"].includes(ext)) {
                        showError('Invalid file type. Only .geojson, .kml, and .kmz files are allowed.', 'File Type Error');
                        return;
                    }
                    
                    // Validate file size
                    if (file.size > maxSize) {
                        showError('File size exceeds 50MB limit.', 'File Too Large');
                        return;
                    }

                    // Show loading indicator for drag-drop
                    if (fromDragDrop) {
                        console.log(`Loading ${file.name}...`);
                    }

                    // Read file
                    const reader = new FileReader();
                    reader.onload = function(evt) {
                        let geojson = null;
                        try {
                            if (ext === 'geojson' || ext === 'json') {
                                geojson = JSON.parse(evt.target.result);
                            } else if (ext === 'kml') {
                                // KML to GeoJSON
                                const parser = new DOMParser();
                                const kmlDoc = parser.parseFromString(evt.target.result, 'text/xml');
                                geojson = toGeoJSON.kml(kmlDoc);
                            } else if (ext === 'kmz') {
                                // KMZ to GeoJSON (requires JSZip and togeojson)
                                function processKMZ(arrayBuffer, fileName) {
                                    JSZip.loadAsync(arrayBuffer).then(zip => {
                                        let kmlFile = null;
                                        zip.forEach((relativePath, zipEntry) => {
                                            if (relativePath.toLowerCase().endsWith('.kml')) {
                                                kmlFile = zipEntry;
                                            }
                                        });
                                        if (!kmlFile) {
                                            showError('No KML file found inside KMZ.', 'KMZ Error');
                                            return;
                                        }
                                        kmlFile.async('string').then(kmlText => {
                                            try {
                                                const parser = new DOMParser();
                                                const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
                                                const geojson = toGeoJSON.kml(kmlDoc);
                                                if (!geojson || geojson.type !== 'FeatureCollection' || !Array.isArray(geojson.features)) {
                                                    showError('Invalid or empty KML inside KMZ file.', 'KMZ Error');
                                                    return;
                                                }
                                                addDataToMap(geojson, fileName);
                                            } catch (err) {
                                                showError('Unable to read this file. Please upload a valid KMZ.', 'KMZ Error');
                                            }
                                        }).catch(() => {
                                            showError('Unable to read this file. Please upload a valid KMZ.', 'KMZ Error');
                                        });
                                    }).catch(() => {
                                        showError('Unable to read this file. Please upload a valid KMZ.', 'KMZ Error');
                                    });
                                }
                                if (typeof JSZip === 'undefined') {
                                    const script = document.createElement('script');
                                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                                    script.onload = () => processKMZ(evt.target.result, file.name);
                                    document.body.appendChild(script);
                                } else {
                                    processKMZ(evt.target.result, file.name);
                                }
                                return;
                            }
                        } catch (err) {
                            showError('Error parsing file. Please ensure it is a valid GeoJSON or KML/KMZ file.', 'Parse Error');
                            return;
                        }
                        if (!geojson || !geojson.type || geojson.type !== 'FeatureCollection') {
                            showError('Invalid or empty GeoJSON/KML file.', 'File Error');
                            return;
                        }
                        addDataToMap(geojson, file.name);
                        
                        // Restore map interactivity and force re-render
                        setTimeout(function() {
                            cleanupEffects();
                            if (typeof map !== 'undefined' && map) {
                                map.invalidateSize();
                            }
                        }, 100);
                    };
                    
                    if (ext === 'kmz') {
                        reader.readAsArrayBuffer(file);
                    } else {
                        reader.readAsText(file);
                    }
                }
                
                // Make processFile available globally for debugging
                window.processFile = processFile;

                // Create a hidden file input for Add Data button with improved positioning
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.geojson,.kml,.kmz,application/geo+json,application/json,application/vnd.google-earth.kml+xml';
                
                // FIXED: More robust hidden styling to prevent conflicts
                fileInput.style.cssText = `
                    position: absolute !important;
                    left: -9999px !important;
                    top: -9999px !important;
                    width: 1px !important;
                    height: 1px !important;
                    opacity: 0 !important;
                    z-index: -1 !important;
                    visibility: hidden !important;
                    pointer-events: none !important;
                    overflow: hidden !important;
                    border: none !important;
                    background: transparent !important;
                    outline: none !important;
                    margin: 0 !important;
                    padding: 0 !important;
                `;
                fileInput.multiple = false;
                fileInput.id = 'hidden-file-input-for-add-data';
                fileInput.tabIndex = -1;
                
                // FIXED: Safe DOM insertion with error handling
                try {
                    document.body.appendChild(fileInput);
                    console.log('📁 File input successfully added to DOM');
                } catch (error) {
                    console.error('❌ Failed to add file input to DOM:', error);
                    return; // Exit if we can't create the file input
                }
                
                // Verify it was added
                const addedInput = document.getElementById('hidden-file-input-for-add-data');
                if (!addedInput) {
                    console.error('❌ File input was not properly added to DOM');
                    return;
                }
                
                console.log('📁 File input created and verified in DOM');
                console.log('📁 File input parent:', addedInput.parentNode?.tagName);
                console.log('📁 File input position in body:', Array.from(document.body.children).indexOf(addedInput));

                // File input change handler with enhanced debugging
                fileInput.addEventListener('change', function(e) {
                    console.log('📁 File input change event triggered');
                    console.log('📁 Files selected:', e.target.files?.length || 0);
                    console.log('📁 Event target:', e.target);
                    console.log('📁 Event type:', e.type);
                    
                    const file = e.target.files?.[0];
                    
                    // Clean up effects regardless
                    cleanupEffects();
                    
                    // If no file selected (dialog was cancelled), return
                    if (!file) {
                        console.log('� No file selected (dialog cancelled or no files)');
                        return;
                    }

                    console.log('✅ File selected successfully:', {
                        name: file.name,
                        size: `${(file.size / 1024 / 1024).toFixed(2)} MB`,
                        type: file.type,
                        lastModified: new Date(file.lastModified).toISOString()
                    });
                    
                    // Process the selected file
                    processFile(file, false);
                }, { passive: false });

                // Add Data button click handler with comprehensive search and debugging
                let addDataButton = document.getElementById('addDataBtn');
                
                // If not found by ID, try multiple approaches
                if (!addDataButton) {
                    // Try finding by text content
                    addDataButton = Array.from(document.querySelectorAll('button')).find(btn => 
                        btn.textContent.trim().toLowerCase().includes('add data') || 
                        btn.textContent.trim().toLowerCase().includes('adddata')
                    );
                }
                
                // If still not found, try finding by class or other attributes
                if (!addDataButton) {
                    addDataButton = document.querySelector('[class*="add-data"], [class*="adddata"], [data-action="add-data"]');
                }
                
                console.log('🔍 Searching for Add Data button...');
                console.log('Button found:', !!addDataButton);
                console.log('Button element:', addDataButton);
                console.log('Button ID:', addDataButton?.id);
                console.log('Button classes:', addDataButton?.className);
                console.log('Button text:', addDataButton?.textContent?.trim());
                
                if (addDataButton) {
                    console.log('✅ Add Data button located successfully!');
                    
                    // FIXED: Use event delegation instead of cloning button
                    // This prevents issues with DOM replacement
                    document.addEventListener('click', function(e) {
                        if (e.target && (e.target.id === 'addDataBtn' || e.target.closest('#addDataBtn'))) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            
                            console.log('🔥 Add Data button clicked via event delegation!'); 
                            console.log('File input element exists:', !!fileInput);
                            console.log('File input in DOM:', !!fileInput.parentNode);
                            
                            // Ensure file input is properly reset
                            fileInput.value = '';
                            
                            // FIXED: Simplified and reliable file dialog trigger
                            try {
                                fileInput.style.display = 'block';
                                fileInput.style.position = 'fixed';
                                fileInput.style.top = '50%';
                                fileInput.style.left = '50%';
                                fileInput.style.zIndex = '999999';
                                fileInput.style.opacity = '0.01';
                                fileInput.focus();
                                fileInput.click();
                                
                                // Hide it again after click
                                setTimeout(() => {
                                    fileInput.style.display = 'none';
                                    fileInput.style.position = 'absolute';
                                    fileInput.style.top = '-9999px';
                                    fileInput.style.left = '-9999px';
                                    fileInput.style.opacity = '0';
                                    fileInput.style.zIndex = '-1';
                                }, 100);
                                
                                console.log('✅ File dialog triggered successfully');
                            } catch (error) {
                                console.error('❌ File dialog failed:', error);
                                // Fallback: Create fresh input
                                const fallbackInput = document.createElement('input');
                                fallbackInput.type = 'file';
                                fallbackInput.accept = '.geojson,.kml,.kmz';
                                fallbackInput.style.cssText = 'position: fixed; top: 50%; left: 50%; z-index: 999999; opacity: 0.1;';
                                
                                fallbackInput.addEventListener('change', function(e) {
                                    const file = e.target.files[0];
                                    if (file) {
                                        console.log('✅ Fallback file selected:', file.name);
                                        processFile(file, false);
                                    }
                                    document.body.removeChild(fallbackInput);
                                });
                                
                                document.body.appendChild(fallbackInput);
                                fallbackInput.click();
                                
                                console.log('✅ Used fallback method successfully');
                            }
                        }
                    });
                    
                    console.log('✅ Add Data button event delegation attached successfully');
                    
                    // Add visual feedback for debugging
                    addDataButton.style.outline = '2px solid #22c55e';
                    setTimeout(() => {
                        if (addDataButton && addDataButton.style) {
                            addDataButton.style.outline = '';
                        }
                    }, 2000);
                    
                } else {
                    console.error('❌ Add Data button not found anywhere in the DOM!');
                    console.log('📋 All available buttons:');
                    document.querySelectorAll('button').forEach((btn, index) => {
                        console.log(`Button ${index}:`, {
                            id: btn.id || 'no-id',
                            text: btn.textContent?.trim() || 'no-text',
                            classes: btn.className || 'no-classes'
                        });
                    });
                    
                    // Create manual test function as fallback
                    window.manualAddData = function() {
                        console.log('🔧 Manual Add Data function triggered');
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.accept = '.geojson,.kml,.kmz';
                        input.onchange = function(e) {
                            const file = e.target.files[0];
                            if (file) {
                                console.log('Manual file selected:', file.name);
                                processFile(file, false);
                            }
                        };
                        input.click();
                    };
                    console.log('💡 Use window.manualAddData() in console as a workaround');
                }

                // Add manual trigger for debugging (remove this later)
                window.testAddDataButton = function() {
                    console.log('🧪 Manual test triggered');
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.geojson,.kml,.kmz';
                    input.onchange = function(e) {
                        const file = e.target.files[0];
                        if (file) {
                            console.log('Manual test file selected:', file.name);
                            processFile(file, false);
                        }
                    };
                    input.click();
                };

                // Enhanced drag and drop functionality with comprehensive event prevention
                let dragCounter = 0;
                let dropZoneVisible = false;

                // Create drop zone overlay
                const dropZone = document.createElement('div');
                dropZone.id = 'file-drop-zone';
                dropZone.innerHTML = `
                    <div class="drop-zone-content">
                        <div class="drop-zone-icon">📁</div>
                        <div class="drop-zone-text">Drop GeoJSON, KML, or KMZ files here</div>
                        <div class="drop-zone-subtext">Supported formats: .geojson, .kml, .kmz (Max: 50MB)</div>
                    </div>
                `;
                dropZone.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    backdrop-filter: blur(5px);
                    -webkit-backdrop-filter: blur(5px);
                    display: none;
                    justify-content: center;
                    align-items: center;
                    z-index: 99999;
                    pointer-events: none;
                    user-select: none;
                `;
                
                dropZone.querySelector('.drop-zone-content').style.cssText = `
                    background: white;
                    padding: 40px;
                    border-radius: 12px;
                    text-align: center;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                    border: 3px dashed #3b82f6;
                    max-width: 400px;
                    pointer-events: none;
                    user-select: none;
                `;
                
                dropZone.querySelector('.drop-zone-icon').style.cssText = `
                    font-size: 48px;
                    margin-bottom: 16px;
                    user-select: none;
                `;
                
                dropZone.querySelector('.drop-zone-text').style.cssText = `
                    font-size: 18px;
                    font-weight: 600;
                    color: #1f2937;
                    margin-bottom: 8px;
                    user-select: none;
                `;
                
                dropZone.querySelector('.drop-zone-subtext').style.cssText = `
                    font-size: 14px;
                    color: #6b7280;
                    user-select: none;
                `;
                
                document.body.appendChild(dropZone);

                // Show drop zone
                function showDropZone() {
                    if (!dropZoneVisible) {
                        dropZone.style.display = 'flex';
                        dropZoneVisible = true;
                        console.log('🎯 Drop zone shown');
                    }
                }

                // Hide drop zone
                function hideDropZone() {
                    if (dropZoneVisible) {
                        dropZone.style.display = 'none';
                        dropZoneVisible = false;
                        dragCounter = 0;
                        console.log('🎯 Drop zone hidden');
                    }
                }

                // Comprehensive event prevention for drag and drop
                const dragEvents = ['dragenter', 'dragover', 'dragleave', 'drop'];
                
                // Prevent default behaviors on the entire document
                dragEvents.forEach(eventName => {
                    document.addEventListener(eventName, function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }, { passive: false, capture: true });
                    
                    window.addEventListener(eventName, function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }, { passive: false, capture: true });
                });

                // Prevent file opening in browser
                window.addEventListener('beforeunload', function(e) {
                    // This helps prevent accidental navigation
                    if (dragCounter > 0) {
                        e.preventDefault();
                        e.returnValue = '';
                        return '';
                    }
                });

                document.addEventListener('dragenter', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('📥 Drag enter detected');
                    
                    dragCounter++;
                    
                    // Only show for file drags
                    if (e.dataTransfer && e.dataTransfer.types && e.dataTransfer.types.includes('Files')) {
                        console.log('📥 File drag detected, showing drop zone');
                        showDropZone();
                    }
                }, { passive: false });

                document.addEventListener('dragleave', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    dragCounter--;
                    console.log('📤 Drag leave, counter:', dragCounter);
                    
                    if (dragCounter <= 0) {
                        hideDropZone();
                    }
                }, { passive: false });

                document.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (e.dataTransfer && e.dataTransfer.types && e.dataTransfer.types.includes('Files')) {
                        e.dataTransfer.dropEffect = 'copy';
                        console.log('📥 Drag over with files');
                    } else {
                        e.dataTransfer.dropEffect = 'none';
                    }
                }, { passive: false });

                document.addEventListener('drop', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('📦 Drop event triggered');
                    
                    hideDropZone();
                    
                    if (!e.dataTransfer || !e.dataTransfer.files || e.dataTransfer.files.length === 0) {
                        console.log('❌ No dataTransfer or files found');
                        return;
                    }
                    
                    const files = Array.from(e.dataTransfer.files);
                    console.log('📦 Files dropped:', files.length);
                    console.log('📦 File details:', files.map(f => ({ name: f.name, size: f.size, type: f.type })));
                    
                    const validFiles = files.filter(file => {
                        const ext = file.name.split('.').pop().toLowerCase();
                        return ["geojson", "kml", "kmz"].includes(ext);
                    });

                    console.log('📦 Valid files to process:', validFiles.length);

                    if (validFiles.length === 0) {
                        if (files.length > 0) {
                            showError('Please drop valid GeoJSON, KML, or KMZ files.', 'Invalid File Type');
                        }
                        return;
                    }

                    // Process each valid file
                    validFiles.forEach((file, index) => {
                        console.log(`📦 Processing file ${index + 1}/${validFiles.length}: ${file.name}`);
                        processFile(file, true);
                    });

                    if (validFiles.length !== files.length) {
                        const skipped = files.length - validFiles.length;
                        showSuccess(`${validFiles.length} file(s) processed successfully. ${skipped} file(s) skipped (invalid format).`, 'Files Processed');
                    } else if (validFiles.length > 0) {
                        console.log(`✅ All ${validFiles.length} files processed successfully`);
                    }
                }, { passive: false });
            }

            // Initialize when DOM is ready - FIXED VERSION
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function() {
                    // Additional delay to ensure all elements are rendered
                    setTimeout(initializeFileHandling, 100);
                });
            } else {
                // Document already loaded, but add small delay to ensure DOM is stable
                setTimeout(initializeFileHandling, 100);
            }
        })();

        // Reusable safeBind helper for debugging event listeners
        window.safeBind = function(id, event, callback) {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener(event, callback);
                console.log(`✅ Event listener attached: ${id}.${event}`);
                return true;
            } else {
                console.warn(`⚠️ Element not found for binding: ${id}.${event}`);
                return false;
            }
        };

        // Quick test function to verify Add Data button works
        window.testAddDataButton = function() {
            const button = document.getElementById('addDataBtn');
            if (button) {
                console.log('🧪 Testing Add Data button...');
                button.click();
                return true;
            } else {
                console.error('❌ Add Data button not found');
                return false;
            }
        };

        console.log('🚀 File handling system loaded - use window.testAddDataButton() to test manually');

        // Global openAddDataModal function for compatibility with inline onclick handlers
        window.openAddDataModal = function() {
            console.log('🔧 Global openAddDataModal function called');
            const button = document.getElementById('addDataBtn');
            if (button) {
                button.click();
            } else {
                console.error('❌ Add Data button not found for global function');
                // Direct file dialog as fallback
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.geojson,.kml,.kmz';
                input.style.cssText = 'position: fixed; top: 50%; left: 50%; z-index: 999999; opacity: 0.1;';
                input.onchange = function(e) {
                    const file = e.target.files[0];
                    if (file && window.processFile) {
                        window.processFile(file, false);
                    }
                    document.body.removeChild(input);
                };
                document.body.appendChild(input);
                input.click();
            }
        };

        // Enhanced validation function
        window.validateFileUploadSystem = function() {
            console.log('🔧 Validating file upload system...');
            
            const results = {
                button: !!document.getElementById('addDataBtn'),
                hiddenInput: !!document.getElementById('hidden-file-input-for-add-data'),
                dropZone: !!document.getElementById('file-drop-zone'),
                processFile: typeof window.processFile === 'function',
                openAddDataModal: typeof window.openAddDataModal === 'function',
                libraries: {
                    toGeoJSON: typeof toGeoJSON !== 'undefined',
                    JSZip: typeof JSZip !== 'undefined',
                    addDataToMap: typeof addDataToMap !== 'undefined'
                }
            };
            
            console.log('📊 Validation results:', results);
            
            // Check for CSS issues
            const button = document.getElementById('addDataBtn');
            if (button) {
                const style = window.getComputedStyle(button);
                const cssIssues = {
                    pointerEvents: style.pointerEvents,
                    display: style.display,
                    visibility: style.visibility,
                    zIndex: style.zIndex,
                    position: style.position
                };
                console.log('🎨 Button CSS properties:', cssIssues);
                
                // Check if button is covered
                const rect = button.getBoundingClientRect();
                const elementAtPoint = document.elementFromPoint(rect.left + rect.width/2, rect.top + rect.height/2);
                console.log('👆 Element at button center:', elementAtPoint);
                console.log('🔍 Is button accessible at click point:', elementAtPoint === button || button.contains(elementAtPoint));
            }
            
            return results;
        };

    </script>

    <!-- HTML2Canvas for map export -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
</body>
</html>
